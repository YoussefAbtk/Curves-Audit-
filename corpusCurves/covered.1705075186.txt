/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/@crytic/properties/contracts/util/Hevm.sol
  1 |     | // SPDX-License-Identifier: Unlicense
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | interface IHevm {
  5 |     |     // Set block.timestamp to newTimestamp
  6 |     |     function warp(uint256 newTimestamp) external;
  7 |     | 
  8 |     |     // Set block.number to newNumber
  9 |     |     function roll(uint256 newNumber) external;
 10 |     | 
 11 |     |     // Loads a storage slot from an address
 12 |     |     function load(address where, bytes32 slot) external returns (bytes32);
 13 |     | 
 14 |     |     // Stores a value to an address' storage slot
 15 |     |     function store(address where, bytes32 slot, bytes32 value) external;
 16 |     | 
 17 |     |     // Signs data (privateKey, digest) => (r, v, s)
 18 |     |     function sign(
 19 |     |         uint256 privateKey,
 20 |     |         bytes32 digest
 21 |     |     ) external returns (uint8 r, bytes32 v, bytes32 s);
 22 |     | 
 23 |     |     // Gets address for a given private key
 24 |     |     function addr(uint256 privateKey) external returns (address addr);
 25 |     | 
 26 |     |     // Performs a foreign function call via terminal
 27 |     |     function ffi(
 28 |     |         string[] calldata inputs
 29 |     |     ) external returns (bytes memory result);
 30 |     | 
 31 |     |     // Performs the next smart contract call with specified `msg.sender`
 32 |     |     function prank(address newSender) external;
 33 |     | }
 34 |     | 
 35 | *   | IHevm constant hevm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
 36 |     | 

/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/@crytic/properties/contracts/util/PropertiesConstants.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | 
  3 |     | abstract contract PropertiesConstants {
  4 |     |     // Constant echidna addresses
  5 | *   |     address constant USER1 = address(0x10000);
  6 | *   |     address constant USER2 = address(0x20000);
  7 | *   |     address constant USER3 = address(0x30000);
  8 |     |     uint256 constant INITIAL_BALANCE = 1000e18;
  9 |     | }
 10 |     | 

/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/@crytic/properties/contracts/util/PropertiesHelper.sol
   1 |     | pragma solidity ^0.8.0;
   2 |     | 
   3 |     | abstract contract PropertiesAsserts {
   4 |     |     event LogUint256(string, uint256);
   5 |     |     event LogAddress(string, address);
   6 |     |     event LogString(string);
   7 |     | 
   8 |     |     event AssertFail(string);
   9 |     |     event AssertEqFail(string);
  10 |     |     event AssertNeqFail(string);
  11 |     |     event AssertGteFail(string);
  12 |     |     event AssertGtFail(string);
  13 |     |     event AssertLteFail(string);
  14 |     |     event AssertLtFail(string);
  15 |     | 
  16 | *   |     function assertWithMsg(bool b, string memory reason) internal {
  17 | *   |         if (!b) {
  18 | *   |             emit AssertFail(reason);
  19 | *   |             assert(false);
  20 |     |         }
  21 |     |     }
  22 |     | 
  23 |     |     /// @notice asserts that a is equal to b. Violations are logged using reason.
  24 | *   |     function assertEq(uint256 a, uint256 b, string memory reason) internal {
  25 | *   |         if (a != b) {
  26 | *   |             string memory aStr = PropertiesLibString.toString(a);
  27 | *   |             string memory bStr = PropertiesLibString.toString(b);
  28 | *   |             bytes memory assertMsg = abi.encodePacked(
  29 |     |                 "Invalid: ",
  30 | *   |                 aStr,
  31 |     |                 "!=",
  32 | *   |                 bStr,
  33 |     |                 ", reason: ",
  34 | *   |                 reason
  35 |     |             );
  36 | *   |             emit AssertEqFail(string(assertMsg));
  37 | *   |             assert(false);
  38 |     |         }
  39 |     |     }
  40 |     | 
  41 |     |     /// @notice int256 version of assertEq
  42 |     |     function assertEq(int256 a, int256 b, string memory reason) internal {
  43 |     |         if (a != b) {
  44 |     |             string memory aStr = PropertiesLibString.toString(a);
  45 |     |             string memory bStr = PropertiesLibString.toString(b);
  46 |     |             bytes memory assertMsg = abi.encodePacked(
  47 |     |                 "Invalid: ",
  48 |     |                 aStr,
  49 |     |                 "!=",
  50 |     |                 bStr,
  51 |     |                 ", reason: ",
  52 |     |                 reason
  53 |     |             );
  54 |     |             emit AssertEqFail(string(assertMsg));
  55 |     |             assert(false);
  56 |     |         }
  57 |     |     }
  58 |     | 
  59 |     |     /// @notice asserts that a is not equal to b. Violations are logged using reason.
  60 |     |     function assertNeq(uint256 a, uint256 b, string memory reason) internal {
  61 |     |         if (a == b) {
  62 |     |             string memory aStr = PropertiesLibString.toString(a);
  63 |     |             string memory bStr = PropertiesLibString.toString(b);
  64 |     |             bytes memory assertMsg = abi.encodePacked(
  65 |     |                 "Invalid: ",
  66 |     |                 aStr,
  67 |     |                 "==",
  68 |     |                 bStr,
  69 |     |                 ", reason: ",
  70 |     |                 reason
  71 |     |             );
  72 |     |             emit AssertNeqFail(string(assertMsg));
  73 |     |             assert(false);
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     /// @notice int256 version of assertNeq
  78 |     |     function assertNeq(int256 a, int256 b, string memory reason) internal {
  79 |     |         if (a == b) {
  80 |     |             string memory aStr = PropertiesLibString.toString(a);
  81 |     |             string memory bStr = PropertiesLibString.toString(b);
  82 |     |             bytes memory assertMsg = abi.encodePacked(
  83 |     |                 "Invalid: ",
  84 |     |                 aStr,
  85 |     |                 "==",
  86 |     |                 bStr,
  87 |     |                 ", reason: ",
  88 |     |                 reason
  89 |     |             );
  90 |     |             emit AssertNeqFail(string(assertMsg));
  91 |     |             assert(false);
  92 |     |         }
  93 |     |     }
  94 |     | 
  95 |     |     /// @notice asserts that a is greater than or equal to b. Violations are logged using reason.
  96 | *   |     function assertGte(uint256 a, uint256 b, string memory reason) internal {
  97 | *   |         if (!(a >= b)) {
  98 |     |             string memory aStr = PropertiesLibString.toString(a);
  99 |     |             string memory bStr = PropertiesLibString.toString(b);
 100 |     |             bytes memory assertMsg = abi.encodePacked(
 101 |     |                 "Invalid: ",
 102 |     |                 aStr,
 103 |     |                 "<",
 104 |     |                 bStr,
 105 |     |                 " failed, reason: ",
 106 |     |                 reason
 107 |     |             );
 108 |     |             emit AssertGteFail(string(assertMsg));
 109 |     |             assert(false);
 110 |     |         }
 111 |     |     }
 112 |     | 
 113 |     |     /// @notice int256 version of assertGte
 114 |     |     function assertGte(int256 a, int256 b, string memory reason) internal {
 115 |     |         if (!(a >= b)) {
 116 |     |             string memory aStr = PropertiesLibString.toString(a);
 117 |     |             string memory bStr = PropertiesLibString.toString(b);
 118 |     |             bytes memory assertMsg = abi.encodePacked(
 119 |     |                 "Invalid: ",
 120 |     |                 aStr,
 121 |     |                 "<",
 122 |     |                 bStr,
 123 |     |                 " failed, reason: ",
 124 |     |                 reason
 125 |     |             );
 126 |     |             emit AssertGteFail(string(assertMsg));
 127 |     |             assert(false);
 128 |     |         }
 129 |     |     }
 130 |     | 
 131 |     |     /// @notice asserts that a is greater than b. Violations are logged using reason.
 132 | *   |     function assertGt(uint256 a, uint256 b, string memory reason) internal {
 133 | *   |         if (!(a > b)) {
 134 |     |             string memory aStr = PropertiesLibString.toString(a);
 135 |     |             string memory bStr = PropertiesLibString.toString(b);
 136 |     |             bytes memory assertMsg = abi.encodePacked(
 137 |     |                 "Invalid: ",
 138 |     |                 aStr,
 139 |     |                 "<=",
 140 |     |                 bStr,
 141 |     |                 " failed, reason: ",
 142 |     |                 reason
 143 |     |             );
 144 |     |             emit AssertGtFail(string(assertMsg));
 145 |     |             assert(false);
 146 |     |         }
 147 |     |     }
 148 |     | 
 149 |     |     /// @notice int256 version of assertGt
 150 |     |     function assertGt(int256 a, int256 b, string memory reason) internal {
 151 |     |         if (!(a > b)) {
 152 |     |             string memory aStr = PropertiesLibString.toString(a);
 153 |     |             string memory bStr = PropertiesLibString.toString(b);
 154 |     |             bytes memory assertMsg = abi.encodePacked(
 155 |     |                 "Invalid: ",
 156 |     |                 aStr,
 157 |     |                 "<=",
 158 |     |                 bStr,
 159 |     |                 " failed, reason: ",
 160 |     |                 reason
 161 |     |             );
 162 |     |             emit AssertGtFail(string(assertMsg));
 163 |     |             assert(false);
 164 |     |         }
 165 |     |     }
 166 |     | 
 167 |     |     /// @notice asserts that a is less than or equal to b. Violations are logged using reason.
 168 |     |     function assertLte(uint256 a, uint256 b, string memory reason) internal {
 169 |     |         if (!(a <= b)) {
 170 |     |             string memory aStr = PropertiesLibString.toString(a);
 171 |     |             string memory bStr = PropertiesLibString.toString(b);
 172 |     |             bytes memory assertMsg = abi.encodePacked(
 173 |     |                 "Invalid: ",
 174 |     |                 aStr,
 175 |     |                 ">",
 176 |     |                 bStr,
 177 |     |                 " failed, reason: ",
 178 |     |                 reason
 179 |     |             );
 180 |     |             emit AssertLteFail(string(assertMsg));
 181 |     |             assert(false);
 182 |     |         }
 183 |     |     }
 184 |     | 
 185 |     |     /// @notice int256 version of assertLte
 186 |     |     function assertLte(int256 a, int256 b, string memory reason) internal {
 187 |     |         if (!(a <= b)) {
 188 |     |             string memory aStr = PropertiesLibString.toString(a);
 189 |     |             string memory bStr = PropertiesLibString.toString(b);
 190 |     |             bytes memory assertMsg = abi.encodePacked(
 191 |     |                 "Invalid: ",
 192 |     |                 aStr,
 193 |     |                 ">",
 194 |     |                 bStr,
 195 |     |                 " failed, reason: ",
 196 |     |                 reason
 197 |     |             );
 198 |     |             emit AssertLteFail(string(assertMsg));
 199 |     |             assert(false);
 200 |     |         }
 201 |     |     }
 202 |     | 
 203 |     |     /// @notice asserts that a is less than b. Violations are logged using reason.
 204 | *   |     function assertLt(uint256 a, uint256 b, string memory reason) internal {
 205 | *   |         if (!(a < b)) {
 206 |     |             string memory aStr = PropertiesLibString.toString(a);
 207 |     |             string memory bStr = PropertiesLibString.toString(b);
 208 |     |             bytes memory assertMsg = abi.encodePacked(
 209 |     |                 "Invalid: ",
 210 |     |                 aStr,
 211 |     |                 ">=",
 212 |     |                 bStr,
 213 |     |                 " failed, reason: ",
 214 |     |                 reason
 215 |     |             );
 216 |     |             emit AssertLtFail(string(assertMsg));
 217 |     |             assert(false);
 218 |     |         }
 219 |     |     }
 220 |     | 
 221 |     |     /// @notice int256 version of assertLt
 222 |     |     function assertLt(int256 a, int256 b, string memory reason) internal {
 223 |     |         if (!(a < b)) {
 224 |     |             string memory aStr = PropertiesLibString.toString(a);
 225 |     |             string memory bStr = PropertiesLibString.toString(b);
 226 |     |             bytes memory assertMsg = abi.encodePacked(
 227 |     |                 "Invalid: ",
 228 |     |                 aStr,
 229 |     |                 ">=",
 230 |     |                 bStr,
 231 |     |                 " failed, reason: ",
 232 |     |                 reason
 233 |     |             );
 234 |     |             emit AssertLtFail(string(assertMsg));
 235 |     |             assert(false);
 236 |     |         }
 237 |     |     }
 238 |     | 
 239 |     |     /// @notice Clamps value to be between low and high, both inclusive
 240 | *   |     function clampBetween(
 241 |     |         uint256 value,
 242 |     |         uint256 low,
 243 |     |         uint256 high
 244 | *   |     ) internal returns (uint256) {
 245 | *   |         if (value < low || value > high) {
 246 | *   |             uint ans = low + (value % (high - low + 1));
 247 | *   |             string memory valueStr = PropertiesLibString.toString(value);
 248 | *   |             string memory ansStr = PropertiesLibString.toString(ans);
 249 | *   |             bytes memory message = abi.encodePacked(
 250 |     |                 "Clamping value ",
 251 | *   |                 valueStr,
 252 |     |                 " to ",
 253 | *   |                 ansStr
 254 |     |             );
 255 | *   |             emit LogString(string(message));
 256 | *   |             return ans;
 257 |     |         }
 258 | *   |         return value;
 259 |     |     }
 260 |     | 
 261 |     |     /// @notice int256 version of clampBetween
 262 |     |     function clampBetween(
 263 |     |         int256 value,
 264 |     |         int256 low,
 265 |     |         int256 high
 266 |     |     ) internal returns (int256) {
 267 |     |         if (value < low || value > high) {
 268 |     |             int range = high - low + 1;
 269 |     |             int clamped = (value - low) % (range);
 270 |     |             if (clamped < 0) clamped += range;
 271 |     |             int ans = low + clamped;
 272 |     |             string memory valueStr = PropertiesLibString.toString(value);
 273 |     |             string memory ansStr = PropertiesLibString.toString(ans);
 274 |     |             bytes memory message = abi.encodePacked(
 275 |     |                 "Clamping value ",
 276 |     |                 valueStr,
 277 |     |                 " to ",
 278 |     |                 ansStr
 279 |     |             );
 280 |     |             emit LogString(string(message));
 281 |     |             return ans;
 282 |     |         }
 283 |     |         return value;
 284 |     |     }
 285 |     | 
 286 |     |     /// @notice clamps a to be less than b
 287 |     |     function clampLt(uint256 a, uint256 b) internal returns (uint256) {
 288 |     |         if (!(a < b)) {
 289 |     |             assertNeq(
 290 |     |                 b,
 291 |     |                 0,
 292 |     |                 "clampLt cannot clamp value a to be less than zero. Check your inputs/assumptions."
 293 |     |             );
 294 |     |             uint256 value = a % b;
 295 |     |             string memory aStr = PropertiesLibString.toString(a);
 296 |     |             string memory valueStr = PropertiesLibString.toString(value);
 297 |     |             bytes memory message = abi.encodePacked(
 298 |     |                 "Clamping value ",
 299 |     |                 aStr,
 300 |     |                 " to ",
 301 |     |                 valueStr
 302 |     |             );
 303 |     |             emit LogString(string(message));
 304 |     |             return value;
 305 |     |         }
 306 |     |         return a;
 307 |     |     }
 308 |     | 
 309 |     |     /// @notice int256 version of clampLt
 310 |     |     function clampLt(int256 a, int256 b) internal returns (int256) {
 311 |     |         if (!(a < b)) {
 312 |     |             int256 value = b - 1;
 313 |     |             string memory aStr = PropertiesLibString.toString(a);
 314 |     |             string memory valueStr = PropertiesLibString.toString(value);
 315 |     |             bytes memory message = abi.encodePacked(
 316 |     |                 "Clamping value ",
 317 |     |                 aStr,
 318 |     |                 " to ",
 319 |     |                 valueStr
 320 |     |             );
 321 |     |             emit LogString(string(message));
 322 |     |             return value;
 323 |     |         }
 324 |     |         return a;
 325 |     |     }
 326 |     | 
 327 |     |     /// @notice clamps a to be less than or equal to b
 328 |     |     function clampLte(uint256 a, uint256 b) internal returns (uint256) {
 329 |     |         if (!(a <= b)) {
 330 |     |             uint256 value = a % (b + 1);
 331 |     |             string memory aStr = PropertiesLibString.toString(a);
 332 |     |             string memory valueStr = PropertiesLibString.toString(value);
 333 |     |             bytes memory message = abi.encodePacked(
 334 |     |                 "Clamping value ",
 335 |     |                 aStr,
 336 |     |                 " to ",
 337 |     |                 valueStr
 338 |     |             );
 339 |     |             emit LogString(string(message));
 340 |     |             return value;
 341 |     |         }
 342 |     |         return a;
 343 |     |     }
 344 |     | 
 345 |     |     /// @notice int256 version of clampLte
 346 |     |     function clampLte(int256 a, int256 b) internal returns (int256) {
 347 |     |         if (!(a <= b)) {
 348 |     |             int256 value = b;
 349 |     |             string memory aStr = PropertiesLibString.toString(a);
 350 |     |             string memory valueStr = PropertiesLibString.toString(value);
 351 |     |             bytes memory message = abi.encodePacked(
 352 |     |                 "Clamping value ",
 353 |     |                 aStr,
 354 |     |                 " to ",
 355 |     |                 valueStr
 356 |     |             );
 357 |     |             emit LogString(string(message));
 358 |     |             return value;
 359 |     |         }
 360 |     |         return a;
 361 |     |     }
 362 |     | 
 363 |     |     /// @notice clamps a to be greater than b
 364 |     |     function clampGt(uint256 a, uint256 b) internal returns (uint256) {
 365 |     |         if (!(a > b)) {
 366 |     |             assertNeq(
 367 |     |                 b,
 368 |     |                 type(uint256).max,
 369 |     |                 "clampGt cannot clamp value a to be larger than uint256.max. Check your inputs/assumptions."
 370 |     |             );
 371 |     |             uint256 value = b + 1;
 372 |     |             string memory aStr = PropertiesLibString.toString(a);
 373 |     |             string memory valueStr = PropertiesLibString.toString(value);
 374 |     |             bytes memory message = abi.encodePacked(
 375 |     |                 "Clamping value ",
 376 |     |                 aStr,
 377 |     |                 " to ",
 378 |     |                 valueStr
 379 |     |             );
 380 |     |             emit LogString(string(message));
 381 |     |             return value;
 382 |     |         } else {
 383 |     |             return a;
 384 |     |         }
 385 |     |     }
 386 |     | 
 387 |     |     /// @notice int256 version of clampGt
 388 |     |     function clampGt(int256 a, int256 b) internal returns (int256) {
 389 |     |         if (!(a > b)) {
 390 |     |             int256 value = b + 1;
 391 |     |             string memory aStr = PropertiesLibString.toString(a);
 392 |     |             string memory valueStr = PropertiesLibString.toString(value);
 393 |     |             bytes memory message = abi.encodePacked(
 394 |     |                 "Clamping value ",
 395 |     |                 aStr,
 396 |     |                 " to ",
 397 |     |                 valueStr
 398 |     |             );
 399 |     |             emit LogString(string(message));
 400 |     |             return value;
 401 |     |         } else {
 402 |     |             return a;
 403 |     |         }
 404 |     |     }
 405 |     | 
 406 |     |     /// @notice clamps a to be greater than or equal to b
 407 |     |     function clampGte(uint256 a, uint256 b) internal returns (uint256) {
 408 |     |         if (!(a > b)) {
 409 |     |             uint256 value = b;
 410 |     |             string memory aStr = PropertiesLibString.toString(a);
 411 |     |             string memory valueStr = PropertiesLibString.toString(value);
 412 |     |             bytes memory message = abi.encodePacked(
 413 |     |                 "Clamping value ",
 414 |     |                 aStr,
 415 |     |                 " to ",
 416 |     |                 valueStr
 417 |     |             );
 418 |     |             emit LogString(string(message));
 419 |     |             return value;
 420 |     |         }
 421 |     |         return a;
 422 |     |     }
 423 |     | 
 424 |     |     /// @notice int256 version of clampGte
 425 |     |     function clampGte(int256 a, int256 b) internal returns (int256) {
 426 |     |         if (!(a > b)) {
 427 |     |             int256 value = b;
 428 |     |             string memory aStr = PropertiesLibString.toString(a);
 429 |     |             string memory valueStr = PropertiesLibString.toString(value);
 430 |     |             bytes memory message = abi.encodePacked(
 431 |     |                 "Clamping value ",
 432 |     |                 aStr,
 433 |     |                 " to ",
 434 |     |                 valueStr
 435 |     |             );
 436 |     |             emit LogString(string(message));
 437 |     |             return value;
 438 |     |         }
 439 |     |         return a;
 440 |     |     }
 441 |     | }
 442 |     | 
 443 |     | /// @notice Efficient library for creating string representations of integers.
 444 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)
 445 |     | /// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)
 446 |     | /// @dev Name of the library is modified to prevent collisions with contract-under-test uses of LibString
 447 |     | library PropertiesLibString {
 448 |     |     function toString(int256 value) internal pure returns (string memory str) {
 449 |     |         uint256 absValue = value >= 0 ? uint256(value) : uint256(-value);
 450 |     |         str = toString(absValue);
 451 |     | 
 452 |     |         if (value < 0) {
 453 |     |             str = string(abi.encodePacked("-", str));
 454 |     |         }
 455 |     |     }
 456 |     | 
 457 | *   |     function toString(uint256 value) internal pure returns (string memory str) {
 458 |     |         /// @solidity memory-safe-assembly
 459 | *   |         assembly {
 460 |     |             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes
 461 |     |             // to keep the free memory pointer word aligned. We'll need 1 word for the length, 1 word for the
 462 |     |             // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.
 463 | *   |             let newFreeMemoryPointer := add(mload(0x40), 160)
 464 |     | 
 465 |     |             // Update the free memory pointer to avoid overriding our string.
 466 | *   |             mstore(0x40, newFreeMemoryPointer)
 467 |     | 
 468 |     |             // Assign str to the end of the zone of newly allocated memory.
 469 | *   |             str := sub(newFreeMemoryPointer, 32)
 470 |     | 
 471 |     |             // Clean the last word of memory it may not be overwritten.
 472 | *   |             mstore(str, 0)
 473 |     | 
 474 |     |             // Cache the end of the memory to calculate the length later.
 475 | *   |             let end := str
 476 |     | 
 477 |     |             // We write the string from rightmost digit to leftmost digit.
 478 |     |             // The following is essentially a do-while loop that also handles the zero case.
 479 |     |             // prettier-ignore
 480 | *   |             for { let temp := value } 1 {} {
 481 |     |                 // Move the pointer 1 byte to the left.
 482 | *   |                 str := sub(str, 1)
 483 |     | 
 484 |     |                 // Write the character to the pointer.
 485 |     |                 // The ASCII index of the '0' character is 48.
 486 | *   |                 mstore8(str, add(48, mod(temp, 10)))
 487 |     | 
 488 |     |                 // Keep dividing temp until zero.
 489 | *   |                 temp := div(temp, 10)
 490 |     | 
 491 |     |                  // prettier-ignore
 492 | *   |                 if iszero(temp) { break }
 493 |     |             }
 494 |     | 
 495 |     |             // Compute and cache the final total length of the string.
 496 | *   |             let length := sub(end, str)
 497 |     | 
 498 |     |             // Move the pointer 32 bytes leftwards to make room for the length.
 499 | *   |             str := sub(str, 32)
 500 |     | 
 501 |     |             // Store the string's length at the start of memory allocated for our string.
 502 | *   |             mstore(str, length)
 503 |     |         }
 504 |     |     }
 505 |     | 
 506 |     |     function toString(address value) internal pure returns (string memory str) {
 507 |     |         bytes memory s = new bytes(40);
 508 |     |         for (uint i = 0; i < 20; i++) {
 509 |     |             bytes1 b = bytes1(
 510 |     |                 uint8(uint(uint160(value)) / (2 ** (8 * (19 - i))))
 511 |     |             );
 512 |     |             bytes1 hi = bytes1(uint8(b) / 16);
 513 |     |             bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));
 514 |     |             s[2 * i] = char(hi);
 515 |     |             s[2 * i + 1] = char(lo);
 516 |     |         }
 517 |     |         return string(s);
 518 |     |     }
 519 |     | 
 520 |     |     function char(bytes1 b) internal pure returns (bytes1 c) {
 521 |     |         if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);
 522 |     |         else return bytes1(uint8(b) + 0x57);
 523 |     |     }
 524 |     | }
 525 |     | 

/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/@openzeppelin/contracts/access/Ownable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../utils/Context.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Contract module which provides a basic access control mechanism, where
 10 |     |  * there is an account (an owner) that can be granted exclusive access to
 11 |     |  * specific functions.
 12 |     |  *
 13 |     |  * By default, the owner account will be the one that deploys the contract. This
 14 |     |  * can later be changed with {transferOwnership}.
 15 |     |  *
 16 |     |  * This module is used through inheritance. It will make available the modifier
 17 |     |  * `onlyOwner`, which can be applied to your functions to restrict their use to
 18 |     |  * the owner.
 19 |     |  */
 20 |     | abstract contract Ownable is Context {
 21 |     |     address private _owner;
 22 |     | 
 23 |     |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
 24 |     | 
 25 |     |     /**
 26 |     |      * @dev Initializes the contract setting the deployer as the initial owner.
 27 |     |      */
 28 |     |     constructor() {
 29 |     |         _transferOwnership(_msgSender());
 30 |     |     }
 31 |     | 
 32 |     |     /**
 33 |     |      * @dev Throws if called by any account other than the owner.
 34 |     |      */
 35 |     |     modifier onlyOwner() {
 36 | *   |         _checkOwner();
 37 |     |         _;
 38 |     |     }
 39 |     | 
 40 |     |     /**
 41 |     |      * @dev Returns the address of the current owner.
 42 |     |      */
 43 | *   |     function owner() public view virtual returns (address) {
 44 | *   |         return _owner;
 45 |     |     }
 46 |     | 
 47 |     |     /**
 48 |     |      * @dev Throws if the sender is not the owner.
 49 |     |      */
 50 | *   |     function _checkOwner() internal view virtual {
 51 | *   |         require(owner() == _msgSender(), "Ownable: caller is not the owner");
 52 |     |     }
 53 |     | 
 54 |     |     /**
 55 |     |      * @dev Leaves the contract without owner. It will not be possible to call
 56 |     |      * `onlyOwner` functions. Can only be called by the current owner.
 57 |     |      *
 58 |     |      * NOTE: Renouncing ownership will leave the contract without an owner,
 59 |     |      * thereby disabling any functionality that is only available to the owner.
 60 |     |      */
 61 |     |     function renounceOwnership() public virtual onlyOwner {
 62 |     |         _transferOwnership(address(0));
 63 |     |     }
 64 |     | 
 65 |     |     /**
 66 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
 67 |     |      * Can only be called by the current owner.
 68 |     |      */
 69 |     |     function transferOwnership(address newOwner) public virtual onlyOwner {
 70 |     |         require(newOwner != address(0), "Ownable: new owner is the zero address");
 71 |     |         _transferOwnership(newOwner);
 72 |     |     }
 73 |     | 
 74 |     |     /**
 75 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
 76 |     |      * Internal function without access restriction.
 77 |     |      */
 78 |     |     function _transferOwnership(address newOwner) internal virtual {
 79 |     |         address oldOwner = _owner;
 80 |     |         _owner = newOwner;
 81 |     |         emit OwnershipTransferred(oldOwner, newOwner);
 82 |     |     }
 83 |     | }
 84 |     | 

/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC20.sol";
   7 |     | import "./extensions/IERC20Metadata.sol";
   8 |     | import "../../utils/Context.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Implementation of the {IERC20} interface.
  12 |     |  *
  13 |     |  * This implementation is agnostic to the way tokens are created. This means
  14 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  15 |     |  * For a generic mechanism see {ERC20PresetMinterPauser}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * The default value of {decimals} is 18. To change this, you should override
  22 |     |  * this function so it returns a different value.
  23 |     |  *
  24 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  25 |     |  * instead returning `false` on failure. This behavior is nonetheless
  26 |     |  * conventional and does not conflict with the expectations of ERC20
  27 |     |  * applications.
  28 |     |  *
  29 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  30 |     |  * This allows applications to reconstruct the allowance for all accounts just
  31 |     |  * by listening to said events. Other implementations of the EIP may not emit
  32 |     |  * these events, as it isn't required by the specification.
  33 |     |  *
  34 |     |  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
  35 |     |  * functions have been added to mitigate the well-known issues around setting
  36 |     |  * allowances. See {IERC20-approve}.
  37 |     |  */
  38 |     | contract ERC20 is Context, IERC20, IERC20Metadata {
  39 |     |     mapping(address => uint256) private _balances;
  40 |     | 
  41 |     |     mapping(address => mapping(address => uint256)) private _allowances;
  42 |     | 
  43 |     |     uint256 private _totalSupply;
  44 |     | 
  45 |     |     string private _name;
  46 |     |     string private _symbol;
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Sets the values for {name} and {symbol}.
  50 |     |      *
  51 |     |      * All two of these values are immutable: they can only be set once during
  52 |     |      * construction.
  53 |     |      */
  54 |     |     constructor(string memory name_, string memory symbol_) {
  55 |     |         _name = name_;
  56 |     |         _symbol = symbol_;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns the name of the token.
  61 |     |      */
  62 |     |     function name() public view virtual override returns (string memory) {
  63 |     |         return _name;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  68 |     |      * name.
  69 |     |      */
  70 |     |     function symbol() public view virtual override returns (string memory) {
  71 |     |         return _symbol;
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Returns the number of decimals used to get its user representation.
  76 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  77 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  78 |     |      *
  79 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  80 |     |      * Ether and Wei. This is the default value returned by this function, unless
  81 |     |      * it's overridden.
  82 |     |      *
  83 |     |      * NOTE: This information is only used for _display_ purposes: it in
  84 |     |      * no way affects any of the arithmetic of the contract, including
  85 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  86 |     |      */
  87 |     |     function decimals() public view virtual override returns (uint8) {
  88 |     |         return 18;
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev See {IERC20-totalSupply}.
  93 |     |      */
  94 |     |     function totalSupply() public view virtual override returns (uint256) {
  95 |     |         return _totalSupply;
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev See {IERC20-balanceOf}.
 100 |     |      */
 101 | *   |     function balanceOf(address account) public view virtual override returns (uint256) {
 102 | *   |         return _balances[account];
 103 |     |     }
 104 |     | 
 105 |     |     /**
 106 |     |      * @dev See {IERC20-transfer}.
 107 |     |      *
 108 |     |      * Requirements:
 109 |     |      *
 110 |     |      * - `to` cannot be the zero address.
 111 |     |      * - the caller must have a balance of at least `amount`.
 112 |     |      */
 113 |     |     function transfer(address to, uint256 amount) public virtual override returns (bool) {
 114 |     |         address owner = _msgSender();
 115 |     |         _transfer(owner, to, amount);
 116 |     |         return true;
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev See {IERC20-allowance}.
 121 |     |      */
 122 |     |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
 123 |     |         return _allowances[owner][spender];
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev See {IERC20-approve}.
 128 |     |      *
 129 |     |      * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
 130 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 131 |     |      *
 132 |     |      * Requirements:
 133 |     |      *
 134 |     |      * - `spender` cannot be the zero address.
 135 |     |      */
 136 |     |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
 137 |     |         address owner = _msgSender();
 138 |     |         _approve(owner, spender, amount);
 139 |     |         return true;
 140 |     |     }
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev See {IERC20-transferFrom}.
 144 |     |      *
 145 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 146 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 147 |     |      *
 148 |     |      * NOTE: Does not update the allowance if the current allowance
 149 |     |      * is the maximum `uint256`.
 150 |     |      *
 151 |     |      * Requirements:
 152 |     |      *
 153 |     |      * - `from` and `to` cannot be the zero address.
 154 |     |      * - `from` must have a balance of at least `amount`.
 155 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 156 |     |      * `amount`.
 157 |     |      */
 158 |     |     function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
 159 |     |         address spender = _msgSender();
 160 |     |         _spendAllowance(from, spender, amount);
 161 |     |         _transfer(from, to, amount);
 162 |     |         return true;
 163 |     |     }
 164 |     | 
 165 |     |     /**
 166 |     |      * @dev Atomically increases the allowance granted to `spender` by the caller.
 167 |     |      *
 168 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 169 |     |      * problems described in {IERC20-approve}.
 170 |     |      *
 171 |     |      * Emits an {Approval} event indicating the updated allowance.
 172 |     |      *
 173 |     |      * Requirements:
 174 |     |      *
 175 |     |      * - `spender` cannot be the zero address.
 176 |     |      */
 177 |     |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
 178 |     |         address owner = _msgSender();
 179 |     |         _approve(owner, spender, allowance(owner, spender) + addedValue);
 180 |     |         return true;
 181 |     |     }
 182 |     | 
 183 |     |     /**
 184 |     |      * @dev Atomically decreases the allowance granted to `spender` by the caller.
 185 |     |      *
 186 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 187 |     |      * problems described in {IERC20-approve}.
 188 |     |      *
 189 |     |      * Emits an {Approval} event indicating the updated allowance.
 190 |     |      *
 191 |     |      * Requirements:
 192 |     |      *
 193 |     |      * - `spender` cannot be the zero address.
 194 |     |      * - `spender` must have allowance for the caller of at least
 195 |     |      * `subtractedValue`.
 196 |     |      */
 197 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
 198 |     |         address owner = _msgSender();
 199 |     |         uint256 currentAllowance = allowance(owner, spender);
 200 |     |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
 201 |     |         unchecked {
 202 |     |             _approve(owner, spender, currentAllowance - subtractedValue);
 203 |     |         }
 204 |     | 
 205 |     |         return true;
 206 |     |     }
 207 |     | 
 208 |     |     /**
 209 |     |      * @dev Moves `amount` of tokens from `from` to `to`.
 210 |     |      *
 211 |     |      * This internal function is equivalent to {transfer}, and can be used to
 212 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 213 |     |      *
 214 |     |      * Emits a {Transfer} event.
 215 |     |      *
 216 |     |      * Requirements:
 217 |     |      *
 218 |     |      * - `from` cannot be the zero address.
 219 |     |      * - `to` cannot be the zero address.
 220 |     |      * - `from` must have a balance of at least `amount`.
 221 |     |      */
 222 |     |     function _transfer(address from, address to, uint256 amount) internal virtual {
 223 |     |         require(from != address(0), "ERC20: transfer from the zero address");
 224 |     |         require(to != address(0), "ERC20: transfer to the zero address");
 225 |     | 
 226 |     |         _beforeTokenTransfer(from, to, amount);
 227 |     | 
 228 |     |         uint256 fromBalance = _balances[from];
 229 |     |         require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
 230 |     |         unchecked {
 231 |     |             _balances[from] = fromBalance - amount;
 232 |     |             // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by
 233 |     |             // decrementing then incrementing.
 234 |     |             _balances[to] += amount;
 235 |     |         }
 236 |     | 
 237 |     |         emit Transfer(from, to, amount);
 238 |     | 
 239 |     |         _afterTokenTransfer(from, to, amount);
 240 |     |     }
 241 |     | 
 242 |     |     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
 243 |     |      * the total supply.
 244 |     |      *
 245 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 246 |     |      *
 247 |     |      * Requirements:
 248 |     |      *
 249 |     |      * - `account` cannot be the zero address.
 250 |     |      */
 251 | *   |     function _mint(address account, uint256 amount) internal virtual {
 252 | *   |         require(account != address(0), "ERC20: mint to the zero address");
 253 |     | 
 254 | *   |         _beforeTokenTransfer(address(0), account, amount);
 255 |     | 
 256 | *   |         _totalSupply += amount;
 257 |     |         unchecked {
 258 |     |             // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
 259 | *   |             _balances[account] += amount;
 260 |     |         }
 261 | *   |         emit Transfer(address(0), account, amount);
 262 |     | 
 263 | *   |         _afterTokenTransfer(address(0), account, amount);
 264 |     |     }
 265 |     | 
 266 |     |     /**
 267 |     |      * @dev Destroys `amount` tokens from `account`, reducing the
 268 |     |      * total supply.
 269 |     |      *
 270 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 271 |     |      *
 272 |     |      * Requirements:
 273 |     |      *
 274 |     |      * - `account` cannot be the zero address.
 275 |     |      * - `account` must have at least `amount` tokens.
 276 |     |      */
 277 | *   |     function _burn(address account, uint256 amount) internal virtual {
 278 | *   |         require(account != address(0), "ERC20: burn from the zero address");
 279 |     | 
 280 | *   |         _beforeTokenTransfer(account, address(0), amount);
 281 |     | 
 282 | *   |         uint256 accountBalance = _balances[account];
 283 | *   |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
 284 |     |         unchecked {
 285 | *   |             _balances[account] = accountBalance - amount;
 286 |     |             // Overflow not possible: amount <= accountBalance <= totalSupply.
 287 | *   |             _totalSupply -= amount;
 288 |     |         }
 289 |     | 
 290 | *   |         emit Transfer(account, address(0), amount);
 291 |     | 
 292 | *   |         _afterTokenTransfer(account, address(0), amount);
 293 |     |     }
 294 |     | 
 295 |     |     /**
 296 |     |      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
 297 |     |      *
 298 |     |      * This internal function is equivalent to `approve`, and can be used to
 299 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 300 |     |      *
 301 |     |      * Emits an {Approval} event.
 302 |     |      *
 303 |     |      * Requirements:
 304 |     |      *
 305 |     |      * - `owner` cannot be the zero address.
 306 |     |      * - `spender` cannot be the zero address.
 307 |     |      */
 308 |     |     function _approve(address owner, address spender, uint256 amount) internal virtual {
 309 |     |         require(owner != address(0), "ERC20: approve from the zero address");
 310 |     |         require(spender != address(0), "ERC20: approve to the zero address");
 311 |     | 
 312 |     |         _allowances[owner][spender] = amount;
 313 |     |         emit Approval(owner, spender, amount);
 314 |     |     }
 315 |     | 
 316 |     |     /**
 317 |     |      * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
 318 |     |      *
 319 |     |      * Does not update the allowance amount in case of infinite allowance.
 320 |     |      * Revert if not enough allowance is available.
 321 |     |      *
 322 |     |      * Might emit an {Approval} event.
 323 |     |      */
 324 |     |     function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {
 325 |     |         uint256 currentAllowance = allowance(owner, spender);
 326 |     |         if (currentAllowance != type(uint256).max) {
 327 |     |             require(currentAllowance >= amount, "ERC20: insufficient allowance");
 328 |     |             unchecked {
 329 |     |                 _approve(owner, spender, currentAllowance - amount);
 330 |     |             }
 331 |     |         }
 332 |     |     }
 333 |     | 
 334 |     |     /**
 335 |     |      * @dev Hook that is called before any transfer of tokens. This includes
 336 |     |      * minting and burning.
 337 |     |      *
 338 |     |      * Calling conditions:
 339 |     |      *
 340 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 341 |     |      * will be transferred to `to`.
 342 |     |      * - when `from` is zero, `amount` tokens will be minted for `to`.
 343 |     |      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
 344 |     |      * - `from` and `to` are never both zero.
 345 |     |      *
 346 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 347 |     |      */
 348 | *   |     function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 349 |     | 
 350 |     |     /**
 351 |     |      * @dev Hook that is called after any transfer of tokens. This includes
 352 |     |      * minting and burning.
 353 |     |      *
 354 |     |      * Calling conditions:
 355 |     |      *
 356 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 357 |     |      * has been transferred to `to`.
 358 |     |      * - when `from` is zero, `amount` tokens have been minted for `to`.
 359 |     |      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
 360 |     |      * - `from` and `to` are never both zero.
 361 |     |      *
 362 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 363 |     |      */
 364 | *   |     function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 365 |     | }
 366 |     | 

/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the amount of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the amount of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves `amount` tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 amount) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 54 |     |      *
 55 |     |      * Returns a boolean value indicating whether the operation succeeded.
 56 |     |      *
 57 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 58 |     |      * that someone may use both the old and the new allowance by unfortunate
 59 |     |      * transaction ordering. One possible solution to mitigate this race
 60 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 61 |     |      * desired value afterwards:
 62 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 63 |     |      *
 64 |     |      * Emits an {Approval} event.
 65 |     |      */
 66 |     |     function approve(address spender, uint256 amount) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Moves `amount` tokens from `from` to `to` using the
 70 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 71 |     |      * allowance.
 72 |     |      *
 73 |     |      * Returns a boolean value indicating whether the operation succeeded.
 74 |     |      *
 75 |     |      * Emits a {Transfer} event.
 76 |     |      */
 77 |     |     function transferFrom(address from, address to, uint256 amount) external returns (bool);
 78 |     | }
 79 |     | 

/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
 10 |     |  *
 11 |     |  * _Available since v4.1._
 12 |     |  */
 13 |     | interface IERC20Metadata is IERC20 {
 14 |     |     /**
 15 |     |      * @dev Returns the name of the token.
 16 |     |      */
 17 |     |     function name() external view returns (string memory);
 18 |     | 
 19 |     |     /**
 20 |     |      * @dev Returns the symbol of the token.
 21 |     |      */
 22 |     |     function symbol() external view returns (string memory);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the decimals places of the token.
 26 |     |      */
 27 |     |     function decimals() external view returns (uint8);
 28 |     | }
 29 |     | 

/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/@openzeppelin/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 | *   |     function _msgSender() internal view virtual returns (address) {
 18 | *   |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | }
 25 |     | 

/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/@openzeppelin/contracts/utils/Strings.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./math/Math.sol";
  7 |     | import "./math/SignedMath.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev String operations.
 11 |     |  */
 12 |     | library Strings {
 13 |     |     bytes16 private constant _SYMBOLS = "0123456789abcdef";
 14 |     |     uint8 private constant _ADDRESS_LENGTH = 20;
 15 |     | 
 16 |     |     /**
 17 |     |      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
 18 |     |      */
 19 | *   |     function toString(uint256 value) internal pure returns (string memory) {
 20 |     |         unchecked {
 21 | *   |             uint256 length = Math.log10(value) + 1;
 22 | *   |             string memory buffer = new string(length);
 23 | *   |             uint256 ptr;
 24 |     |             /// @solidity memory-safe-assembly
 25 |     |             assembly {
 26 | *   |                 ptr := add(buffer, add(32, length))
 27 |     |             }
 28 | *   |             while (true) {
 29 | *   |                 ptr--;
 30 |     |                 /// @solidity memory-safe-assembly
 31 |     |                 assembly {
 32 | *   |                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
 33 |     |                 }
 34 | *   |                 value /= 10;
 35 | *   |                 if (value == 0) break;
 36 |     |             }
 37 | *   |             return buffer;
 38 |     |         }
 39 |     |     }
 40 |     | 
 41 |     |     /**
 42 |     |      * @dev Converts a `int256` to its ASCII `string` decimal representation.
 43 |     |      */
 44 |     |     function toString(int256 value) internal pure returns (string memory) {
 45 |     |         return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMath.abs(value))));
 46 |     |     }
 47 |     | 
 48 |     |     /**
 49 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
 50 |     |      */
 51 |     |     function toHexString(uint256 value) internal pure returns (string memory) {
 52 |     |         unchecked {
 53 |     |             return toHexString(value, Math.log256(value) + 1);
 54 |     |         }
 55 |     |     }
 56 |     | 
 57 |     |     /**
 58 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
 59 |     |      */
 60 |     |     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
 61 |     |         bytes memory buffer = new bytes(2 * length + 2);
 62 |     |         buffer[0] = "0";
 63 |     |         buffer[1] = "x";
 64 |     |         for (uint256 i = 2 * length + 1; i > 1; --i) {
 65 |     |             buffer[i] = _SYMBOLS[value & 0xf];
 66 |     |             value >>= 4;
 67 |     |         }
 68 |     |         require(value == 0, "Strings: hex length insufficient");
 69 |     |         return string(buffer);
 70 |     |     }
 71 |     | 
 72 |     |     /**
 73 |     |      * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
 74 |     |      */
 75 |     |     function toHexString(address addr) internal pure returns (string memory) {
 76 |     |         return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
 77 |     |     }
 78 |     | 
 79 |     |     /**
 80 |     |      * @dev Returns true if the two strings are equal.
 81 |     |      */
 82 |     |     function equal(string memory a, string memory b) internal pure returns (bool) {
 83 |     |         return keccak256(bytes(a)) == keccak256(bytes(b));
 84 |     |     }
 85 |     | }
 86 |     | 

/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/@openzeppelin/contracts/utils/cryptography/MerkleProof.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev These functions deal with verification of Merkle Tree proofs.
   8 |     |  *
   9 |     |  * The tree and the proofs can be generated using our
  10 |     |  * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].
  11 |     |  * You will find a quickstart guide in the readme.
  12 |     |  *
  13 |     |  * WARNING: You should avoid using leaf values that are 64 bytes long prior to
  14 |     |  * hashing, or use a hash function other than keccak256 for hashing leaves.
  15 |     |  * This is because the concatenation of a sorted pair of internal nodes in
  16 |     |  * the merkle tree could be reinterpreted as a leaf value.
  17 |     |  * OpenZeppelin's JavaScript library generates merkle trees that are safe
  18 |     |  * against this attack out of the box.
  19 |     |  */
  20 |     | library MerkleProof {
  21 |     |     /**
  22 |     |      * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree
  23 |     |      * defined by `root`. For this, a `proof` must be provided, containing
  24 |     |      * sibling hashes on the branch from the leaf to the root of the tree. Each
  25 |     |      * pair of leaves and each pair of pre-images are assumed to be sorted.
  26 |     |      */
  27 |     |     function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {
  28 |     |         return processProof(proof, leaf) == root;
  29 |     |     }
  30 |     | 
  31 |     |     /**
  32 |     |      * @dev Calldata version of {verify}
  33 |     |      *
  34 |     |      * _Available since v4.7._
  35 |     |      */
  36 |     |     function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {
  37 |     |         return processProofCalldata(proof, leaf) == root;
  38 |     |     }
  39 |     | 
  40 |     |     /**
  41 |     |      * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up
  42 |     |      * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt
  43 |     |      * hash matches the root of the tree. When processing the proof, the pairs
  44 |     |      * of leafs & pre-images are assumed to be sorted.
  45 |     |      *
  46 |     |      * _Available since v4.4._
  47 |     |      */
  48 |     |     function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {
  49 |     |         bytes32 computedHash = leaf;
  50 |     |         for (uint256 i = 0; i < proof.length; i++) {
  51 |     |             computedHash = _hashPair(computedHash, proof[i]);
  52 |     |         }
  53 |     |         return computedHash;
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Calldata version of {processProof}
  58 |     |      *
  59 |     |      * _Available since v4.7._
  60 |     |      */
  61 |     |     function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {
  62 |     |         bytes32 computedHash = leaf;
  63 |     |         for (uint256 i = 0; i < proof.length; i++) {
  64 |     |             computedHash = _hashPair(computedHash, proof[i]);
  65 |     |         }
  66 |     |         return computedHash;
  67 |     |     }
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by
  71 |     |      * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.
  72 |     |      *
  73 |     |      * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.
  74 |     |      *
  75 |     |      * _Available since v4.7._
  76 |     |      */
  77 |     |     function multiProofVerify(
  78 |     |         bytes32[] memory proof,
  79 |     |         bool[] memory proofFlags,
  80 |     |         bytes32 root,
  81 |     |         bytes32[] memory leaves
  82 |     |     ) internal pure returns (bool) {
  83 |     |         return processMultiProof(proof, proofFlags, leaves) == root;
  84 |     |     }
  85 |     | 
  86 |     |     /**
  87 |     |      * @dev Calldata version of {multiProofVerify}
  88 |     |      *
  89 |     |      * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.
  90 |     |      *
  91 |     |      * _Available since v4.7._
  92 |     |      */
  93 |     |     function multiProofVerifyCalldata(
  94 |     |         bytes32[] calldata proof,
  95 |     |         bool[] calldata proofFlags,
  96 |     |         bytes32 root,
  97 |     |         bytes32[] memory leaves
  98 |     |     ) internal pure returns (bool) {
  99 |     |         return processMultiProofCalldata(proof, proofFlags, leaves) == root;
 100 |     |     }
 101 |     | 
 102 |     |     /**
 103 |     |      * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction
 104 |     |      * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another
 105 |     |      * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false
 106 |     |      * respectively.
 107 |     |      *
 108 |     |      * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree
 109 |     |      * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the
 110 |     |      * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).
 111 |     |      *
 112 |     |      * _Available since v4.7._
 113 |     |      */
 114 |     |     function processMultiProof(
 115 |     |         bytes32[] memory proof,
 116 |     |         bool[] memory proofFlags,
 117 |     |         bytes32[] memory leaves
 118 |     |     ) internal pure returns (bytes32 merkleRoot) {
 119 |     |         // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by
 120 |     |         // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the
 121 |     |         // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of
 122 |     |         // the merkle tree.
 123 |     |         uint256 leavesLen = leaves.length;
 124 |     |         uint256 proofLen = proof.length;
 125 |     |         uint256 totalHashes = proofFlags.length;
 126 |     | 
 127 |     |         // Check proof validity.
 128 |     |         require(leavesLen + proofLen - 1 == totalHashes, "MerkleProof: invalid multiproof");
 129 |     | 
 130 |     |         // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using
 131 |     |         // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's "pop".
 132 |     |         bytes32[] memory hashes = new bytes32[](totalHashes);
 133 |     |         uint256 leafPos = 0;
 134 |     |         uint256 hashPos = 0;
 135 |     |         uint256 proofPos = 0;
 136 |     |         // At each step, we compute the next hash using two values:
 137 |     |         // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we
 138 |     |         //   get the next hash.
 139 |     |         // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the
 140 |     |         //   `proof` array.
 141 |     |         for (uint256 i = 0; i < totalHashes; i++) {
 142 |     |             bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];
 143 |     |             bytes32 b = proofFlags[i]
 144 |     |                 ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])
 145 |     |                 : proof[proofPos++];
 146 |     |             hashes[i] = _hashPair(a, b);
 147 |     |         }
 148 |     | 
 149 |     |         if (totalHashes > 0) {
 150 |     |             require(proofPos == proofLen, "MerkleProof: invalid multiproof");
 151 |     |             unchecked {
 152 |     |                 return hashes[totalHashes - 1];
 153 |     |             }
 154 |     |         } else if (leavesLen > 0) {
 155 |     |             return leaves[0];
 156 |     |         } else {
 157 |     |             return proof[0];
 158 |     |         }
 159 |     |     }
 160 |     | 
 161 |     |     /**
 162 |     |      * @dev Calldata version of {processMultiProof}.
 163 |     |      *
 164 |     |      * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.
 165 |     |      *
 166 |     |      * _Available since v4.7._
 167 |     |      */
 168 |     |     function processMultiProofCalldata(
 169 |     |         bytes32[] calldata proof,
 170 |     |         bool[] calldata proofFlags,
 171 |     |         bytes32[] memory leaves
 172 |     |     ) internal pure returns (bytes32 merkleRoot) {
 173 |     |         // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by
 174 |     |         // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the
 175 |     |         // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of
 176 |     |         // the merkle tree.
 177 |     |         uint256 leavesLen = leaves.length;
 178 |     |         uint256 proofLen = proof.length;
 179 |     |         uint256 totalHashes = proofFlags.length;
 180 |     | 
 181 |     |         // Check proof validity.
 182 |     |         require(leavesLen + proofLen - 1 == totalHashes, "MerkleProof: invalid multiproof");
 183 |     | 
 184 |     |         // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using
 185 |     |         // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's "pop".
 186 |     |         bytes32[] memory hashes = new bytes32[](totalHashes);
 187 |     |         uint256 leafPos = 0;
 188 |     |         uint256 hashPos = 0;
 189 |     |         uint256 proofPos = 0;
 190 |     |         // At each step, we compute the next hash using two values:
 191 |     |         // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we
 192 |     |         //   get the next hash.
 193 |     |         // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the
 194 |     |         //   `proof` array.
 195 |     |         for (uint256 i = 0; i < totalHashes; i++) {
 196 |     |             bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];
 197 |     |             bytes32 b = proofFlags[i]
 198 |     |                 ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])
 199 |     |                 : proof[proofPos++];
 200 |     |             hashes[i] = _hashPair(a, b);
 201 |     |         }
 202 |     | 
 203 |     |         if (totalHashes > 0) {
 204 |     |             require(proofPos == proofLen, "MerkleProof: invalid multiproof");
 205 |     |             unchecked {
 206 |     |                 return hashes[totalHashes - 1];
 207 |     |             }
 208 |     |         } else if (leavesLen > 0) {
 209 |     |             return leaves[0];
 210 |     |         } else {
 211 |     |             return proof[0];
 212 |     |         }
 213 |     |     }
 214 |     | 
 215 |     |     function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {
 216 |     |         return a < b ? _efficientHash(a, b) : _efficientHash(b, a);
 217 |     |     }
 218 |     | 
 219 |     |     function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {
 220 |     |         /// @solidity memory-safe-assembly
 221 |     |         assembly {
 222 |     |             mstore(0x00, a)
 223 |     |             mstore(0x20, b)
 224 |     |             value := keccak256(0x00, 0x40)
 225 |     |         }
 226 |     |     }
 227 |     | }
 228 |     | 

/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/@openzeppelin/contracts/utils/math/Math.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Standard math utilities missing in the Solidity language.
   8 |     |  */
   9 |     | library Math {
  10 |     |     enum Rounding {
  11 |     |         Down, // Toward negative infinity
  12 |     |         Up, // Toward infinity
  13 |     |         Zero // Toward zero
  14 |     |     }
  15 |     | 
  16 |     |     /**
  17 |     |      * @dev Returns the largest of two numbers.
  18 |     |      */
  19 |     |     function max(uint256 a, uint256 b) internal pure returns (uint256) {
  20 |     |         return a > b ? a : b;
  21 |     |     }
  22 |     | 
  23 |     |     /**
  24 |     |      * @dev Returns the smallest of two numbers.
  25 |     |      */
  26 |     |     function min(uint256 a, uint256 b) internal pure returns (uint256) {
  27 |     |         return a < b ? a : b;
  28 |     |     }
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Returns the average of two numbers. The result is rounded towards
  32 |     |      * zero.
  33 |     |      */
  34 |     |     function average(uint256 a, uint256 b) internal pure returns (uint256) {
  35 |     |         // (a + b) / 2 can overflow.
  36 |     |         return (a & b) + (a ^ b) / 2;
  37 |     |     }
  38 |     | 
  39 |     |     /**
  40 |     |      * @dev Returns the ceiling of the division of two numbers.
  41 |     |      *
  42 |     |      * This differs from standard division with `/` in that it rounds up instead
  43 |     |      * of rounding down.
  44 |     |      */
  45 |     |     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
  46 |     |         // (a + b - 1) / b can overflow on addition, so we distribute.
  47 |     |         return a == 0 ? 0 : (a - 1) / b + 1;
  48 |     |     }
  49 |     | 
  50 |     |     /**
  51 |     |      * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
  52 |     |      * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)
  53 |     |      * with further edits by Uniswap Labs also under MIT license.
  54 |     |      */
  55 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {
  56 |     |         unchecked {
  57 |     |             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
  58 |     |             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
  59 |     |             // variables such that product = prod1 * 2^256 + prod0.
  60 |     |             uint256 prod0; // Least significant 256 bits of the product
  61 |     |             uint256 prod1; // Most significant 256 bits of the product
  62 |     |             assembly {
  63 |     |                 let mm := mulmod(x, y, not(0))
  64 |     |                 prod0 := mul(x, y)
  65 |     |                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
  66 |     |             }
  67 |     | 
  68 |     |             // Handle non-overflow cases, 256 by 256 division.
  69 |     |             if (prod1 == 0) {
  70 |     |                 // Solidity will revert if denominator == 0, unlike the div opcode on its own.
  71 |     |                 // The surrounding unchecked block does not change this fact.
  72 |     |                 // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.
  73 |     |                 return prod0 / denominator;
  74 |     |             }
  75 |     | 
  76 |     |             // Make sure the result is less than 2^256. Also prevents denominator == 0.
  77 |     |             require(denominator > prod1, "Math: mulDiv overflow");
  78 |     | 
  79 |     |             ///////////////////////////////////////////////
  80 |     |             // 512 by 256 division.
  81 |     |             ///////////////////////////////////////////////
  82 |     | 
  83 |     |             // Make division exact by subtracting the remainder from [prod1 prod0].
  84 |     |             uint256 remainder;
  85 |     |             assembly {
  86 |     |                 // Compute remainder using mulmod.
  87 |     |                 remainder := mulmod(x, y, denominator)
  88 |     | 
  89 |     |                 // Subtract 256 bit number from 512 bit number.
  90 |     |                 prod1 := sub(prod1, gt(remainder, prod0))
  91 |     |                 prod0 := sub(prod0, remainder)
  92 |     |             }
  93 |     | 
  94 |     |             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
  95 |     |             // See https://cs.stackexchange.com/q/138556/92363.
  96 |     | 
  97 |     |             // Does not overflow because the denominator cannot be zero at this stage in the function.
  98 |     |             uint256 twos = denominator & (~denominator + 1);
  99 |     |             assembly {
 100 |     |                 // Divide denominator by twos.
 101 |     |                 denominator := div(denominator, twos)
 102 |     | 
 103 |     |                 // Divide [prod1 prod0] by twos.
 104 |     |                 prod0 := div(prod0, twos)
 105 |     | 
 106 |     |                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
 107 |     |                 twos := add(div(sub(0, twos), twos), 1)
 108 |     |             }
 109 |     | 
 110 |     |             // Shift in bits from prod1 into prod0.
 111 |     |             prod0 |= prod1 * twos;
 112 |     | 
 113 |     |             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
 114 |     |             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
 115 |     |             // four bits. That is, denominator * inv = 1 mod 2^4.
 116 |     |             uint256 inverse = (3 * denominator) ^ 2;
 117 |     | 
 118 |     |             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
 119 |     |             // in modular arithmetic, doubling the correct bits in each step.
 120 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^8
 121 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^16
 122 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^32
 123 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^64
 124 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^128
 125 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^256
 126 |     | 
 127 |     |             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
 128 |     |             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
 129 |     |             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
 130 |     |             // is no longer required.
 131 |     |             result = prod0 * inverse;
 132 |     |             return result;
 133 |     |         }
 134 |     |     }
 135 |     | 
 136 |     |     /**
 137 |     |      * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
 138 |     |      */
 139 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {
 140 |     |         uint256 result = mulDiv(x, y, denominator);
 141 |     |         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
 142 |     |             result += 1;
 143 |     |         }
 144 |     |         return result;
 145 |     |     }
 146 |     | 
 147 |     |     /**
 148 |     |      * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.
 149 |     |      *
 150 |     |      * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
 151 |     |      */
 152 |     |     function sqrt(uint256 a) internal pure returns (uint256) {
 153 |     |         if (a == 0) {
 154 |     |             return 0;
 155 |     |         }
 156 |     | 
 157 |     |         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
 158 |     |         //
 159 |     |         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
 160 |     |         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
 161 |     |         //
 162 |     |         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
 163 |     |         //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
 164 |     |         //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
 165 |     |         //
 166 |     |         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
 167 |     |         uint256 result = 1 << (log2(a) >> 1);
 168 |     | 
 169 |     |         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
 170 |     |         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
 171 |     |         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
 172 |     |         // into the expected uint128 result.
 173 |     |         unchecked {
 174 |     |             result = (result + a / result) >> 1;
 175 |     |             result = (result + a / result) >> 1;
 176 |     |             result = (result + a / result) >> 1;
 177 |     |             result = (result + a / result) >> 1;
 178 |     |             result = (result + a / result) >> 1;
 179 |     |             result = (result + a / result) >> 1;
 180 |     |             result = (result + a / result) >> 1;
 181 |     |             return min(result, a / result);
 182 |     |         }
 183 |     |     }
 184 |     | 
 185 |     |     /**
 186 |     |      * @notice Calculates sqrt(a), following the selected rounding direction.
 187 |     |      */
 188 |     |     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
 189 |     |         unchecked {
 190 |     |             uint256 result = sqrt(a);
 191 |     |             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
 192 |     |         }
 193 |     |     }
 194 |     | 
 195 |     |     /**
 196 |     |      * @dev Return the log in base 2, rounded down, of a positive value.
 197 |     |      * Returns 0 if given 0.
 198 |     |      */
 199 |     |     function log2(uint256 value) internal pure returns (uint256) {
 200 |     |         uint256 result = 0;
 201 |     |         unchecked {
 202 |     |             if (value >> 128 > 0) {
 203 |     |                 value >>= 128;
 204 |     |                 result += 128;
 205 |     |             }
 206 |     |             if (value >> 64 > 0) {
 207 |     |                 value >>= 64;
 208 |     |                 result += 64;
 209 |     |             }
 210 |     |             if (value >> 32 > 0) {
 211 |     |                 value >>= 32;
 212 |     |                 result += 32;
 213 |     |             }
 214 |     |             if (value >> 16 > 0) {
 215 |     |                 value >>= 16;
 216 |     |                 result += 16;
 217 |     |             }
 218 |     |             if (value >> 8 > 0) {
 219 |     |                 value >>= 8;
 220 |     |                 result += 8;
 221 |     |             }
 222 |     |             if (value >> 4 > 0) {
 223 |     |                 value >>= 4;
 224 |     |                 result += 4;
 225 |     |             }
 226 |     |             if (value >> 2 > 0) {
 227 |     |                 value >>= 2;
 228 |     |                 result += 2;
 229 |     |             }
 230 |     |             if (value >> 1 > 0) {
 231 |     |                 result += 1;
 232 |     |             }
 233 |     |         }
 234 |     |         return result;
 235 |     |     }
 236 |     | 
 237 |     |     /**
 238 |     |      * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
 239 |     |      * Returns 0 if given 0.
 240 |     |      */
 241 |     |     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
 242 |     |         unchecked {
 243 |     |             uint256 result = log2(value);
 244 |     |             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
 245 |     |         }
 246 |     |     }
 247 |     | 
 248 |     |     /**
 249 |     |      * @dev Return the log in base 10, rounded down, of a positive value.
 250 |     |      * Returns 0 if given 0.
 251 |     |      */
 252 | *   |     function log10(uint256 value) internal pure returns (uint256) {
 253 | *   |         uint256 result = 0;
 254 |     |         unchecked {
 255 | *   |             if (value >= 10 ** 64) {
 256 |     |                 value /= 10 ** 64;
 257 |     |                 result += 64;
 258 |     |             }
 259 | *   |             if (value >= 10 ** 32) {
 260 |     |                 value /= 10 ** 32;
 261 |     |                 result += 32;
 262 |     |             }
 263 | *   |             if (value >= 10 ** 16) {
 264 |     |                 value /= 10 ** 16;
 265 |     |                 result += 16;
 266 |     |             }
 267 | *   |             if (value >= 10 ** 8) {
 268 |     |                 value /= 10 ** 8;
 269 |     |                 result += 8;
 270 |     |             }
 271 | *   |             if (value >= 10 ** 4) {
 272 |     |                 value /= 10 ** 4;
 273 |     |                 result += 4;
 274 |     |             }
 275 | *   |             if (value >= 10 ** 2) {
 276 |     |                 value /= 10 ** 2;
 277 |     |                 result += 2;
 278 |     |             }
 279 | *   |             if (value >= 10 ** 1) {
 280 |     |                 result += 1;
 281 |     |             }
 282 |     |         }
 283 | *   |         return result;
 284 |     |     }
 285 |     | 
 286 |     |     /**
 287 |     |      * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
 288 |     |      * Returns 0 if given 0.
 289 |     |      */
 290 |     |     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
 291 |     |         unchecked {
 292 |     |             uint256 result = log10(value);
 293 |     |             return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);
 294 |     |         }
 295 |     |     }
 296 |     | 
 297 |     |     /**
 298 |     |      * @dev Return the log in base 256, rounded down, of a positive value.
 299 |     |      * Returns 0 if given 0.
 300 |     |      *
 301 |     |      * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
 302 |     |      */
 303 |     |     function log256(uint256 value) internal pure returns (uint256) {
 304 |     |         uint256 result = 0;
 305 |     |         unchecked {
 306 |     |             if (value >> 128 > 0) {
 307 |     |                 value >>= 128;
 308 |     |                 result += 16;
 309 |     |             }
 310 |     |             if (value >> 64 > 0) {
 311 |     |                 value >>= 64;
 312 |     |                 result += 8;
 313 |     |             }
 314 |     |             if (value >> 32 > 0) {
 315 |     |                 value >>= 32;
 316 |     |                 result += 4;
 317 |     |             }
 318 |     |             if (value >> 16 > 0) {
 319 |     |                 value >>= 16;
 320 |     |                 result += 2;
 321 |     |             }
 322 |     |             if (value >> 8 > 0) {
 323 |     |                 result += 1;
 324 |     |             }
 325 |     |         }
 326 |     |         return result;
 327 |     |     }
 328 |     | 
 329 |     |     /**
 330 |     |      * @dev Return the log in base 256, following the selected rounding direction, of a positive value.
 331 |     |      * Returns 0 if given 0.
 332 |     |      */
 333 |     |     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
 334 |     |         unchecked {
 335 |     |             uint256 result = log256(value);
 336 |     |             return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);
 337 |     |         }
 338 |     |     }
 339 |     | }
 340 |     | 

/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Standard signed math utilities missing in the Solidity language.
  8 |     |  */
  9 |     | library SignedMath {
 10 |     |     /**
 11 |     |      * @dev Returns the largest of two signed numbers.
 12 |     |      */
 13 |     |     function max(int256 a, int256 b) internal pure returns (int256) {
 14 |     |         return a > b ? a : b;
 15 |     |     }
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Returns the smallest of two signed numbers.
 19 |     |      */
 20 |     |     function min(int256 a, int256 b) internal pure returns (int256) {
 21 |     |         return a < b ? a : b;
 22 |     |     }
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the average of two signed numbers without overflow.
 26 |     |      * The result is rounded towards zero.
 27 |     |      */
 28 |     |     function average(int256 a, int256 b) internal pure returns (int256) {
 29 |     |         // Formula from the book "Hacker's Delight"
 30 |     |         int256 x = (a & b) + ((a ^ b) >> 1);
 31 |     |         return x + (int256(uint256(x) >> 255) & (a ^ b));
 32 |     |     }
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Returns the absolute unsigned value of a signed value.
 36 |     |      */
 37 |     |     function abs(int256 n) internal pure returns (uint256) {
 38 |     |         unchecked {
 39 |     |             // must be unchecked in order to support `n = type(int256).min`
 40 |     |             return uint256(n >= 0 ? n : -n);
 41 |     |         }
 42 |     |     }
 43 |     | }
 44 |     | 

/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/contracts/Curves.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.7;
   3 |     | 
   4 |     | import "@openzeppelin/contracts/utils/Strings.sol";
   5 |     | import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
   6 |     | 
   7 |     | import "./CurvesERC20.sol";
   8 |     | import "./CurvesERC20Factory.sol";
   9 |     | 
  10 |     | import "./FeeSplitter.sol";
  11 |     | import "./Security.sol";
  12 |     | 
  13 |     | interface CurvesErrors {
  14 |     |     // Access-related
  15 |     |     error UnauthorizedCurvesTokenSubject();
  16 |     |     // Balance-related
  17 |     |     error InsufficientPayment();
  18 |     |     error CannotSendFunds();
  19 |     |     error InsufficientBalance();
  20 |     |     // ERC20-related
  21 |     |     error InvalidERC20Metadata();
  22 |     |     error ERC20TokenAlreadyMinted();
  23 |     |     // State-related
  24 |     |     error TokenAbsentForCurvesTokenSubject();
  25 |     |     error CurveAlreadyExists();
  26 |     |     // Transaction-related
  27 |     |     error LastTokenCannotBeSold();
  28 |     |     error ContractCannotReceiveTransfer();
  29 |     |     error ExceededMaxBuyAmount();
  30 |     |     error NonIntegerDepositAmount();
  31 |     |     // Proof-related
  32 |     |     error UnverifiedProof();
  33 |     |     // Presale-related
  34 |     |     error PresaleUnavailable();
  35 |     |     error InvalidPresaleStartTime();
  36 |     |     error SaleNotOpen();
  37 |     |     // Fee related
  38 |     |     error InvalidFeeDefinition();
  39 |     | }
  40 |     | 
  41 | *   | contract Curves is CurvesErrors, Security {
  42 |     |     address public curvesERC20Factory;
  43 |     |     FeeSplitter public feeRedistributor;
  44 |     |     string public constant DEFAULT_NAME = "Curves";
  45 |     |     string public constant DEFAULT_SYMBOL = "CURVES";
  46 |     |     // Counter for CURVES tokens minted
  47 |     |     uint256 private _curvesTokenCounter = 0;
  48 |     | 
  49 |     |     struct ExternalTokenMeta {
  50 |     |         string name;
  51 |     |         string symbol;
  52 |     |         address token;
  53 |     |     }
  54 |     | 
  55 |     |     struct PresaleMeta {
  56 |     |         uint256 startTime;
  57 |     |         bytes32 merkleRoot;
  58 |     |         uint256 maxBuy;
  59 |     |     }
  60 |     | 
  61 | *   |     mapping(address => ExternalTokenMeta) public externalCurvesTokens;
  62 |     |     mapping(address => address) public externalCurvesToSubject;
  63 |     |     mapping(string => address) public symbolToSubject;
  64 |     | 
  65 |     |     mapping(address => PresaleMeta) public presalesMeta;
  66 |     |     mapping(address => mapping(address => uint256)) public presalesBuys;
  67 |     | 
  68 |     |     struct FeesEconomics {
  69 |     |         address protocolFeeDestination;
  70 |     |         uint256 protocolFeePercent;
  71 |     |         uint256 subjectFeePercent;
  72 |     |         uint256 referralFeePercent;
  73 |     |         uint256 holdersFeePercent;
  74 |     |         uint256 maxFeePercent;
  75 |     |     }
  76 |     | 
  77 |     |     FeesEconomics public feesEconomics;
  78 |     |     mapping(address => address) public referralFeeDestination;
  79 |     |     event LogUint256(string, uint256);
  80 |     | 
  81 |     |     event Trade(
  82 |     |         address trader,
  83 |     |         address subject,
  84 |     |         bool isBuy,
  85 |     |         uint256 tokenAmount,
  86 |     |         uint256 ethAmount,
  87 |     |         uint256 protocolEthAmount,
  88 |     |         uint256 subjectEthAmount,
  89 |     |         uint256 supply
  90 |     |     );
  91 |     | 
  92 |     |     event Transfer(address indexed curvesTokenSubject, address indexed from, address indexed to, uint256 value);
  93 |     |     event WhitelistUpdated(address indexed presale, bytes32 indexed root);
  94 |     |     event TokenDeployed(address indexed curvesTokenSubject, address indexed erc20token, string name, string symbol);
  95 |     | 
  96 |     |     // TokenSubject => (Holder => Balance)
  97 | *   |     mapping(address => mapping(address => uint256)) public curvesTokenBalance;
  98 |     | 
  99 |     |     // TokenSubject => Supply
 100 | *   |     mapping(address => uint256) public curvesTokenSupply;
 101 |     | 
 102 |     |     mapping(address => address[]) private ownedCurvesTokenSubjects;
 103 |     | 
 104 |     |     modifier onlyTokenSubject(address curvesTokenSubject) {
 105 | *   |         if (curvesTokenSubject != msg.sender) revert UnauthorizedCurvesTokenSubject();
 106 |     |         _;
 107 |     |     }
 108 |     | 
 109 |     |     constructor(address curvesERC20Factory_, address feeRedistributor_) Security() {
 110 |     |         curvesERC20Factory = curvesERC20Factory_;
 111 |     |         feeRedistributor = FeeSplitter(payable(feeRedistributor_));
 112 |     |     }
 113 |     | 
 114 |     |     function setFeeRedistributor(address feeRedistributor_) external onlyOwner {
 115 |     |         feeRedistributor = FeeSplitter(payable(feeRedistributor_));
 116 |     |     }
 117 |     | 
 118 |     |     function setMaxFeePercent(uint256 maxFeePercent_) external onlyManager {
 119 |     |         if (
 120 |     |             feesEconomics.protocolFeePercent +
 121 |     |                 feesEconomics.subjectFeePercent +
 122 |     |                 feesEconomics.referralFeePercent +
 123 |     |                 feesEconomics.holdersFeePercent >
 124 |     |             maxFeePercent_
 125 |     |         ) revert InvalidFeeDefinition();
 126 |     |         feesEconomics.maxFeePercent = maxFeePercent_;
 127 |     |     }
 128 |     | 
 129 |     |     function setProtocolFeePercent(uint256 protocolFeePercent_, address protocolFeeDestination_) external onlyOwner {
 130 |     |         if (
 131 |     |             protocolFeePercent_ +
 132 |     |                 feesEconomics.subjectFeePercent +
 133 |     |                 feesEconomics.referralFeePercent +
 134 |     |                 feesEconomics.holdersFeePercent >
 135 |     |             feesEconomics.maxFeePercent ||
 136 |     |             protocolFeeDestination_ == address(0)
 137 |     |         ) revert InvalidFeeDefinition();
 138 |     |         feesEconomics.protocolFeePercent = protocolFeePercent_;
 139 |     |         feesEconomics.protocolFeeDestination = protocolFeeDestination_;
 140 |     |     }
 141 |     | 
 142 |     |     function setExternalFeePercent(
 143 |     |         uint256 subjectFeePercent_,
 144 |     |         uint256 referralFeePercent_,
 145 |     |         uint256 holdersFeePercent_
 146 |     |     ) external onlyManager {
 147 |     |         if (
 148 |     |             feesEconomics.protocolFeePercent + subjectFeePercent_ + referralFeePercent_ + holdersFeePercent_ >
 149 |     |             feesEconomics.maxFeePercent
 150 |     |         ) revert InvalidFeeDefinition();
 151 |     |         feesEconomics.subjectFeePercent = subjectFeePercent_;
 152 |     |         feesEconomics.referralFeePercent = referralFeePercent_;
 153 |     |         feesEconomics.holdersFeePercent = holdersFeePercent_;
 154 |     |     }
 155 |     | 
 156 |     |     function setReferralFeeDestination(
 157 |     |         address curvesTokenSubject,
 158 |     |         address referralFeeDestination_
 159 |     |     ) public onlyTokenSubject(curvesTokenSubject) {
 160 |     |         referralFeeDestination[curvesTokenSubject] = referralFeeDestination_;
 161 |     |     }
 162 |     | 
 163 |     |     function setERC20Factory(address factory_) external onlyOwner {
 164 |     |         curvesERC20Factory = factory_;
 165 |     |     }
 166 |     | 
 167 | *   |     function getFees(
 168 |     |         uint256 price
 169 |     |     )
 170 |     |         public
 171 |     |         view
 172 | *   |         returns (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holdersFee, uint256 totalFee)
 173 |     |     {
 174 | *   |         protocolFee = (price * feesEconomics.protocolFeePercent) / 1 ether;
 175 | *   |         subjectFee = (price * feesEconomics.subjectFeePercent) / 1 ether;
 176 | *   |         referralFee = (price * feesEconomics.referralFeePercent) / 1 ether;
 177 | *   |         holdersFee = (price * feesEconomics.holdersFeePercent) / 1 ether;
 178 | *   |         totalFee = protocolFee + subjectFee + referralFee + holdersFee;
 179 |     |     }
 180 |     | 
 181 | *   |     function getPrice(uint256 supply, uint256 amount) public pure returns (uint256) {
 182 | *   |         uint256 sum1 = supply == 0 ? 0 : ((supply - 1) * (supply) * (2 * (supply - 1) + 1)) / 6;
 183 | *   |         uint256 sum2 = supply == 0 && amount == 1
 184 | *   |             ? 0
 185 | *   |             : ((supply - 1 + amount) * (supply + amount) * (2 * (supply - 1 + amount) + 1)) / 6;
 186 | *   |         uint256 summation = sum2 - sum1;
 187 | *   |         return (summation * 1 ether) / 16000;
 188 |     |     }
 189 |     | 
 190 |     |     function getBuyPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) {
 191 |     |         return getPrice(curvesTokenSupply[curvesTokenSubject], amount);
 192 |     |     }
 193 |     | 
 194 |     |     function getSellPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) {
 195 |     |         return getPrice(curvesTokenSupply[curvesTokenSubject] - amount, amount);
 196 |     |     }
 197 |     | 
 198 |     |     function getBuyPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {
 199 |     |         uint256 price = getBuyPrice(curvesTokenSubject, amount);
 200 |     |         (, , , , uint256 totalFee) = getFees(price);
 201 |     | 
 202 |     |         return price + totalFee;
 203 |     |     }
 204 |     | 
 205 |     |     function getSellPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {
 206 |     |         uint256 price = getSellPrice(curvesTokenSubject, amount);
 207 |     |         (, , , , uint256 totalFee) = getFees(price);
 208 |     | 
 209 |     |         return price - totalFee;
 210 |     |     }
 211 |     | 
 212 | *   |     function buyCurvesToken(address curvesTokenSubject, uint256 amount) public payable {
 213 | *   |         uint256 startTime = presalesMeta[curvesTokenSubject].startTime;
 214 | *   |         if (startTime != 0 && startTime >= block.timestamp) revert SaleNotOpen();
 215 |     | 
 216 | *   |         _buyCurvesToken(curvesTokenSubject, amount);
 217 |     |     }
 218 |     | 
 219 | *   |     function _transferFees(
 220 |     |         address curvesTokenSubject,
 221 |     |         bool isBuy,
 222 |     |         uint256 price,
 223 |     |         uint256 amount,
 224 |     |         uint256 supply
 225 | *   |     ) internal {
 226 | *   |         (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holderFee, ) = getFees(price);
 227 | *   |         {
 228 | *   |             bool referralDefined = referralFeeDestination[curvesTokenSubject] != address(0);
 229 | *   |             {
 230 | *   |                 address firstDestination = isBuy ? feesEconomics.protocolFeeDestination : msg.sender;
 231 | *   |                 uint256 buyValue = referralDefined ? protocolFee : protocolFee + referralFee;
 232 | *   |                 uint256 sellValue = price - protocolFee - subjectFee - referralFee - holderFee;
 233 | *   |                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}("");
 234 | *   |                 if (!success1) revert CannotSendFunds();
 235 |     |             }
 236 | *   |             {
 237 | *   |                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}("");
 238 | *   |                 if (!success2) revert CannotSendFunds();
 239 |     |             }
 240 | *   |             {
 241 | *   |                 (bool success3, ) = referralDefined
 242 |     |                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}("")
 243 | *   |                     : (true, bytes(""));
 244 | *   |                 if (!success3) revert CannotSendFunds();
 245 |     |             }
 246 | *   |              emit LogUint256("Did we arrive here ?", 1);
 247 | *   |             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0)) {
 248 | *   |                              emit LogUint256("Did we arrive here ?", 2);
 249 |     | 
 250 | *   |                 feeRedistributor.onBalanceChange(curvesTokenSubject, msg.sender);
 251 | *   |                              emit LogUint256("Did we arrive here ?", 3);
 252 |     | 
 253 | *   |                 feeRedistributor.addFees{value: holderFee}(curvesTokenSubject);
 254 |     |             }
 255 |     |         }
 256 | *   |         emit Trade(
 257 | *   |             msg.sender,
 258 | *   |             curvesTokenSubject,
 259 | *   |             isBuy,
 260 | *   |             amount,
 261 | *   |             price,
 262 | *   |             protocolFee,
 263 | *   |             subjectFee,
 264 | *   |             isBuy ? supply + amount : supply - amount
 265 |     |         );
 266 |     |     }
 267 |     | 
 268 | *   |     function _buyCurvesToken(address curvesTokenSubject, uint256 amount) internal {
 269 | *   |         uint256 supply = curvesTokenSupply[curvesTokenSubject];
 270 | *   |         if (!(supply > 0 || curvesTokenSubject == msg.sender)) revert UnauthorizedCurvesTokenSubject();
 271 |     | 
 272 | *   |         uint256 price = getPrice(supply, amount);
 273 | *   |         (, , , , uint256 totalFee) = getFees(price);
 274 | *   |          emit LogUint256("this is the value", msg.value);
 275 | *   |           emit LogUint256("that is what we should pay.", price +totalFee);
 276 | *   |         if (msg.value < price + totalFee) revert InsufficientPayment();
 277 |     |         
 278 | *   |         curvesTokenBalance[curvesTokenSubject][msg.sender] += amount;
 279 | *   |         curvesTokenSupply[curvesTokenSubject] = supply + amount;
 280 | *   |         _transferFees(curvesTokenSubject, true, price, amount, supply);
 281 |     | 
 282 |     |         // If is the first token bought, add to the list of owned tokens
 283 | *   |         if (curvesTokenBalance[curvesTokenSubject][msg.sender] - amount == 0) {
 284 | *   |             _addOwnedCurvesTokenSubject(msg.sender, curvesTokenSubject);
 285 |     |         }
 286 |     |     }
 287 |     | 
 288 | *   |     function sellCurvesToken(address curvesTokenSubject, uint256 amount) public {
 289 | *   |         uint256 supply = curvesTokenSupply[curvesTokenSubject];
 290 | *   |         if (supply <= amount) revert LastTokenCannotBeSold();
 291 | *   |         if (curvesTokenBalance[curvesTokenSubject][msg.sender] < amount) revert InsufficientBalance();
 292 |     | 
 293 | *   |         uint256 price = getPrice(supply - amount, amount);
 294 |     | 
 295 | *   |         curvesTokenBalance[curvesTokenSubject][msg.sender] -= amount;
 296 | *   |         curvesTokenSupply[curvesTokenSubject] = supply - amount;
 297 |     | 
 298 | *   |         _transferFees(curvesTokenSubject, false, price, amount, supply);
 299 |     |     }
 300 |     | 
 301 |     |     // Transfers tokens from current owner to receiver. Can be used for gifting or distributing tokens.
 302 |     |     function transferCurvesToken(address curvesTokenSubject, address to, uint256 amount) external {
 303 |     |         if (to == address(this)) revert ContractCannotReceiveTransfer();
 304 |     |         _transfer(curvesTokenSubject, msg.sender, to, amount);
 305 |     |     }
 306 |     | 
 307 |     |     // Transfer the total balance of all my tokens to another address. Can be used for migrating tokens.
 308 |     |     function transferAllCurvesTokens(address to) external {
 309 |     |         if (to == address(this)) revert ContractCannotReceiveTransfer();
 310 |     |         address[] storage subjects = ownedCurvesTokenSubjects[msg.sender];
 311 |     |         for (uint256 i = 0; i < subjects.length; i++) {
 312 |     |             uint256 amount = curvesTokenBalance[subjects[i]][msg.sender];
 313 |     |             if (amount > 0) {
 314 |     |                 _transfer(subjects[i], msg.sender, to, amount);
 315 |     |             }
 316 |     |         }
 317 |     |     }
 318 |     | 
 319 | *   |     function _transfer(address curvesTokenSubject, address from, address to, uint256 amount) internal {
 320 | *   |         if (amount > curvesTokenBalance[curvesTokenSubject][from]) revert InsufficientBalance();
 321 |     | 
 322 |     |         // If transferring from oneself, skip adding to the list
 323 | *   |         if (from != to) {
 324 | *   |             _addOwnedCurvesTokenSubject(to, curvesTokenSubject);
 325 |     |         }
 326 |     | 
 327 | *   |         curvesTokenBalance[curvesTokenSubject][from] = curvesTokenBalance[curvesTokenSubject][from] - amount;
 328 | *   |         curvesTokenBalance[curvesTokenSubject][to] = curvesTokenBalance[curvesTokenSubject][to] + amount;
 329 |     | 
 330 | *   |         emit Transfer(curvesTokenSubject, from, to, amount);
 331 |     |     }
 332 |     | 
 333 |     |     // Internal function to add a curvesTokenSubject to the list if not already present
 334 | *   |     function _addOwnedCurvesTokenSubject(address owner_, address curvesTokenSubject) internal {
 335 | *   |         address[] storage subjects = ownedCurvesTokenSubjects[owner_];
 336 | *   |         for (uint256 i = 0; i < subjects.length; i++) {
 337 | *   |             if (subjects[i] == curvesTokenSubject) {
 338 | *   |                 return;
 339 |     |             }
 340 |     |         }
 341 | *   |         subjects.push(curvesTokenSubject);
 342 |     |     }
 343 |     | 
 344 | *   |     function _deployERC20(
 345 |     |         address curvesTokenSubject,
 346 |     |         string memory name,
 347 |     |         string memory symbol
 348 | *   |     ) internal returns (address) {
 349 |     |         // If the token's symbol is CURVES, append a counter value
 350 | *   |         if (keccak256(bytes(symbol)) == keccak256(bytes(DEFAULT_SYMBOL))) {
 351 | *   |             _curvesTokenCounter += 1;
 352 |     |             //@audit abi.encodePacked for strings.
 353 | *   |             name = string(abi.encodePacked(name, " ", Strings.toString(_curvesTokenCounter)));
 354 | *   |             symbol = string(abi.encodePacked(symbol, Strings.toString(_curvesTokenCounter)));
 355 |     |         }
 356 |     | 
 357 | *   |         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();
 358 |     | 
 359 | *   |         address tokenContract = CurvesERC20Factory(curvesERC20Factory).deploy(name, symbol, address(this));
 360 |     | 
 361 | *   |         externalCurvesTokens[curvesTokenSubject].token = tokenContract;
 362 | *   |         externalCurvesTokens[curvesTokenSubject].name = name;
 363 | *   |         externalCurvesTokens[curvesTokenSubject].symbol = symbol;
 364 | *   |         externalCurvesToSubject[tokenContract] = curvesTokenSubject;
 365 | *   |         symbolToSubject[symbol] = curvesTokenSubject;
 366 |     | 
 367 | *   |         emit TokenDeployed(curvesTokenSubject, tokenContract, name, symbol);
 368 | *   |         return address(tokenContract);
 369 |     |     }
 370 |     | 
 371 |     |     function buyCurvesTokenWithName(
 372 |     |         address curvesTokenSubject,
 373 |     |         uint256 amount,
 374 |     |         string memory name,
 375 |     |         string memory symbol
 376 |     |     ) public payable {
 377 |     |         uint256 supply = curvesTokenSupply[curvesTokenSubject];
 378 |     |         if (supply != 0) revert CurveAlreadyExists();
 379 |     | 
 380 |     |         _buyCurvesToken(curvesTokenSubject, amount);
 381 |     |         _mint(curvesTokenSubject, name, symbol);
 382 |     |     }
 383 |     | 
 384 |     |     function buyCurvesTokenForPresale(
 385 |     |         address curvesTokenSubject,
 386 |     |         uint256 amount,
 387 |     |         uint256 startTime,
 388 |     |         bytes32 merkleRoot,
 389 |     |         uint256 maxBuy
 390 |     |     ) public payable onlyTokenSubject(curvesTokenSubject) {
 391 |     |         if (startTime <= block.timestamp) revert InvalidPresaleStartTime();
 392 |     |         uint256 supply = curvesTokenSupply[curvesTokenSubject];
 393 |     |         if (supply != 0) revert CurveAlreadyExists();
 394 |     |         presalesMeta[curvesTokenSubject].startTime = startTime;
 395 |     |         presalesMeta[curvesTokenSubject].merkleRoot = merkleRoot;
 396 |     |         presalesMeta[curvesTokenSubject].maxBuy = (maxBuy == 0 ? type(uint256).max : maxBuy);
 397 |     | 
 398 |     |         _buyCurvesToken(curvesTokenSubject, amount);
 399 |     |     }
 400 |     | 
 401 |     |     function setWhitelist(bytes32 merkleRoot) external {
 402 |     |         uint256 supply = curvesTokenSupply[msg.sender];
 403 |     |         if (supply > 1) revert CurveAlreadyExists();
 404 |     | 
 405 |     |         if (presalesMeta[msg.sender].merkleRoot != merkleRoot) {
 406 |     |             presalesMeta[msg.sender].merkleRoot = merkleRoot;
 407 |     |             emit WhitelistUpdated(msg.sender, merkleRoot);
 408 |     |         }
 409 |     |     }
 410 |     | 
 411 |     |     function buyCurvesTokenWhitelisted(
 412 |     |         address curvesTokenSubject,
 413 |     |         uint256 amount,
 414 |     |         bytes32[] memory proof
 415 |     |     ) public payable {
 416 |     |         if (
 417 |     |             presalesMeta[curvesTokenSubject].startTime == 0 ||
 418 |     |             presalesMeta[curvesTokenSubject].startTime <= block.timestamp
 419 |     |         ) revert PresaleUnavailable();
 420 |     | 
 421 |     |         presalesBuys[curvesTokenSubject][msg.sender] += amount;
 422 |     |         uint256 tokenBought = presalesBuys[curvesTokenSubject][msg.sender];
 423 |     |         if (tokenBought > presalesMeta[curvesTokenSubject].maxBuy) revert ExceededMaxBuyAmount();
 424 |     | 
 425 |     |         verifyMerkle(curvesTokenSubject, msg.sender, proof);
 426 |     |         _buyCurvesToken(curvesTokenSubject, amount);
 427 |     |     }
 428 |     | 
 429 |     |     function verifyMerkle(address curvesTokenSubject, address caller, bytes32[] memory proof) public view {
 430 |     |         // Verify merkle proof
 431 |     |         bytes32 leaf = keccak256(abi.encodePacked(caller));
 432 |     |         if (!MerkleProof.verify(proof, presalesMeta[curvesTokenSubject].merkleRoot, leaf)) revert UnverifiedProof();
 433 |     |     }
 434 |     | 
 435 |     |     function setNameAndSymbol(
 436 |     |         address curvesTokenSubject,
 437 |     |         string memory name,
 438 |     |         string memory symbol
 439 |     |     ) external onlyTokenSubject(curvesTokenSubject) {
 440 |     |         if (externalCurvesTokens[curvesTokenSubject].token != address(0)) revert ERC20TokenAlreadyMinted();
 441 |     |         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();
 442 |     |         externalCurvesTokens[curvesTokenSubject].name = name;
 443 |     |         externalCurvesTokens[curvesTokenSubject].symbol = symbol;
 444 |     |     }
 445 |     | 
 446 | *   |     function mint(address curvesTokenSubject) external onlyTokenSubject(curvesTokenSubject) {
 447 | *   |         if (
 448 | *   |             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==
 449 | *   |             keccak256(abi.encodePacked("")) ||
 450 |     |             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==
 451 |     |             keccak256(abi.encodePacked(""))
 452 |     |         ) {
 453 | *   |             externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME;
 454 | *   |             externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL;
 455 |     |         }
 456 | *   |         _mint(
 457 | *   |             curvesTokenSubject,
 458 | *   |             externalCurvesTokens[curvesTokenSubject].name,
 459 | *   |             externalCurvesTokens[curvesTokenSubject].symbol
 460 |     |         );
 461 |     |     }
 462 |     | 
 463 | *   |     function _mint(
 464 |     |         address curvesTokenSubject,
 465 |     |         string memory name,
 466 |     |         string memory symbol
 467 | *   |     ) internal onlyTokenSubject(curvesTokenSubject) {
 468 | *   |         if (externalCurvesTokens[curvesTokenSubject].token != address(0)) revert ERC20TokenAlreadyMinted();
 469 | *   |         _deployERC20(curvesTokenSubject, name, symbol);
 470 |     |     }
 471 |     | 
 472 | *   |     function withdraw(address curvesTokenSubject, uint256 amount) public {
 473 | *   |         if (amount > curvesTokenBalance[curvesTokenSubject][msg.sender]) revert InsufficientBalance();
 474 |     | 
 475 | *   |         address externalToken = externalCurvesTokens[curvesTokenSubject].token;
 476 | *   |         if (externalToken == address(0)) {
 477 | *   |             if (
 478 | *   |                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==
 479 | *   |                 keccak256(abi.encodePacked("")) ||
 480 |     |                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==
 481 |     |                 keccak256(abi.encodePacked(""))
 482 |     |             ) {
 483 | *   |                 externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME;
 484 | *   |                 externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL;
 485 |     |             }
 486 | *   |             _deployERC20(
 487 | *   |                 curvesTokenSubject,
 488 | *   |                 externalCurvesTokens[curvesTokenSubject].name,
 489 | *   |                 externalCurvesTokens[curvesTokenSubject].symbol
 490 |     |             );
 491 | *   |             externalToken = externalCurvesTokens[curvesTokenSubject].token;
 492 |     |         }
 493 | *   |         _transfer(curvesTokenSubject, msg.sender, address(this), amount);
 494 | *   |         CurvesERC20(externalToken).mint(msg.sender, amount * 1 ether);
 495 |     |     }
 496 |     | 
 497 | *   |     function deposit(address curvesTokenSubject, uint256 amount) public {
 498 | *   |         if (amount % 1 ether != 0) revert NonIntegerDepositAmount();
 499 |     | 
 500 | *   |         address externalToken = externalCurvesTokens[curvesTokenSubject].token;
 501 | *   |         uint256 tokenAmount = amount / 1 ether;
 502 |     | 
 503 | *   |         if (externalToken == address(0)) revert TokenAbsentForCurvesTokenSubject();
 504 | *   |         if (amount > CurvesERC20(externalToken).balanceOf(msg.sender)) revert InsufficientBalance();
 505 | *   |         if (tokenAmount > curvesTokenBalance[curvesTokenSubject][address(this)]) revert InsufficientBalance();
 506 |     | 
 507 | *   |         CurvesERC20(externalToken).burn(msg.sender, amount);
 508 | *   |         _transfer(curvesTokenSubject, address(this), msg.sender, tokenAmount);
 509 |     |     }
 510 |     | 
 511 |     |     function sellExternalCurvesToken(address curvesTokenSubject, uint256 amount) public {
 512 |     |         if (externalCurvesTokens[curvesTokenSubject].token == address(0)) revert TokenAbsentForCurvesTokenSubject();
 513 |     | 
 514 |     |         deposit(curvesTokenSubject, amount);
 515 |     |         sellCurvesToken(curvesTokenSubject, amount / 1 ether);
 516 |     |     }
 517 |     | }
 518 |     | 

/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/contracts/CurvesERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.7;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/access/Ownable.sol";
  5 |     | import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  6 |     | 
  7 | *   | contract CurvesERC20 is ERC20, Ownable {
  8 |     |     constructor(string memory name_, string memory symbol_, address owner) ERC20(name_, symbol_) {
  9 |     |         transferOwnership(owner);
 10 |     |     }
 11 |     | 
 12 | *   |     function mint(address to, uint256 amount) public onlyOwner {
 13 | *   |         _mint(to, amount);
 14 |     |     }
 15 |     | 
 16 | *   |     function burn(address from, uint256 amount) public onlyOwner {
 17 | *   |         _burn(from, amount);
 18 |     |     }
 19 |     | }
 20 |     | 

/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/contracts/CurvesERC20Factory.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.7;
  3 |     | 
  4 |     | import "./CurvesERC20.sol";
  5 |     | 
  6 | *   | contract CurvesERC20Factory {
  7 | *   |     function deploy(string memory name, string memory symbol, address owner) public returns (address) {
  8 | *   |         CurvesERC20 tokenContract = new CurvesERC20(name, symbol, owner);
  9 | *   |         return address(tokenContract);
 10 |     |     }
 11 |     | }
 12 |     | 

/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/contracts/EchidnaCurves.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.7;
   3 |     | 
   4 |     | import "@crytic/properties/contracts/util/PropertiesHelper.sol";
   5 |     | import "@crytic/properties/contracts/util/PropertiesConstants.sol";
   6 |     | 
   7 |     | import "@crytic/properties/contracts/util/Hevm.sol";
   8 |     | import {Curves} from "./Curves.sol"; 
   9 |     | import {CurvesERC20} from "./CurvesERC20.sol";
  10 |     | import {CurvesERC20Factory} from "./CurvesERC20Factory.sol";
  11 |     | import {FeeSplitter} from "./FeeSplitter.sol";
  12 |     | 
  13 | *r  | contract EchidnaCurves is PropertiesAsserts, PropertiesConstants{
  14 |     |     Curves curves; 
  15 |     |     FeeSplitter feeSplitter; 
  16 |     |     mapping(address=> bool) hasAReference; 
  17 |     |     mapping(address => bool) isExternal;
  18 |     |     mapping(address=> mapping(address=> uint256)) amountDeposited;
  19 |     |     address owner= hevm.addr(666);
  20 |     |     uint256 amountExternal; 
  21 |     |     constructor() payable {
  22 |     |         CurvesERC20Factory factory = new CurvesERC20Factory(); 
  23 |     |         feeSplitter = new FeeSplitter();
  24 |     |         curves = new Curves(address(factory), address(feeSplitter));
  25 |     |         feeSplitter.setCurves(curves); 
  26 |     |         feeSplitter.setManager(address(curves), true);
  27 |     |         curves.setManager(address(this), false);
  28 |     |         curves.transferOwnership(owner); 
  29 |     |         hevm.prank(owner);
  30 |     |         curves.setManager(owner, true);
  31 |     |         hevm.prank(owner); 
  32 |     |         curves.setMaxFeePercent(0.4e18);
  33 |     |         hevm.prank(owner); 
  34 |     |         curves.setProtocolFeePercent(0.1e18, owner);
  35 |     |         hevm.prank(owner); 
  36 |     |         curves.setExternalFeePercent(0.2e18,0,0.1e18);
  37 |     | 
  38 |     | 
  39 |     |     }
  40 |     | 
  41 | *   |     function test_buyCurvesTokensForTheFirstTime(uint256 _amount) public payable  {
  42 | *   |         _amount=clampBetween(_amount, 0, 100_000);
  43 |     |          
  44 | *   |           uint256 supply = curves.curvesTokenSupply(msg.sender);
  45 | *   |           uint256 priceBefore = curves.getPrice(supply, 1);
  46 | *r  |           uint256 price = curves.getPrice(supply, _amount);
  47 | *   |           (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holdersFee, uint256 totalFee) = curves.getFees(price); 
  48 | *   |           if(msg.value > msg.sender.balance)return; 
  49 | *   |           if(msg.value < price +totalFee) return; 
  50 | *   |           emit LogUint256("this is the value", msg.value);
  51 | *   |           emit LogUint256("that is what we should pay.", price +totalFee);
  52 |     | 
  53 |     |           
  54 | *   |         hevm.prank(msg.sender); 
  55 | *   |         try curves.buyCurvesToken{value: msg.value }(msg.sender, _amount){
  56 | *   |             uint256 supplyAfter = curves.curvesTokenSupply(msg.sender);
  57 | *   |             uint256 priceAfter = curves.getPrice(supplyAfter, 1);
  58 | *   |             assertEq(supplyAfter, supply+_amount, "Supply didn't increase");
  59 | *   |             assertGte(priceAfter, priceBefore, "price should increase"); 
  60 | *   |             hasAReference[msg.sender]= true; 
  61 | *   |             amountDeposited[msg.sender][msg.sender]+=_amount; 
  62 |     |         } catch {
  63 | *   |         assertWithMsg(false, "buyCurvesToken should not revert.");
  64 |     |         }
  65 |     | 
  66 |     |         }
  67 | *   |         function test_buyCurvesTokensForUser(uint256 _amount, uint256 _whichUser) external payable  {
  68 | *   |          _whichUser = clampBetween(_whichUser, 1,3); 
  69 | *   |          address user = _chooseUser(_whichUser); 
  70 | *   |          if(!hasAReference[user])return; 
  71 | *   |          _amount=clampBetween(_amount, 0, 100_000);
  72 |     |       
  73 | *   |           uint256 supply = curves.curvesTokenSupply(user);
  74 | *   |             uint256 priceBefore = curves.getPrice(supply, 1);
  75 |     | 
  76 | *   |           uint256 price = curves.getPrice(supply, _amount);
  77 | *   |           (, , , , uint256 totalFee) = curves.getFees(price);
  78 | *   |           if(msg.value > msg.sender.balance)return; 
  79 | *   |           if(msg.value < price +totalFee) return; 
  80 | *   |            hevm.prank(msg.sender); 
  81 | *   |         try curves.buyCurvesToken{value: msg.value }(user, _amount){
  82 | *   |          uint256 supplyAfter = curves.curvesTokenSupply(user);
  83 | *   |             uint256 priceAfter = curves.getPrice(supplyAfter, 1);
  84 |     | 
  85 | *   |             assertEq(supplyAfter, supply+_amount, "Supply didn't increase");
  86 | *   |             if(supplyAfter>supply){
  87 | *   |             assertGt(priceAfter, priceBefore, "price should increase");
  88 |     |             } else {
  89 | *   |             assertEq(priceAfter, priceBefore, "price should be egal");
  90 |     |             }
  91 | *   |             assertEq(curves.curvesTokenBalance(user, USER1)+curves.curvesTokenBalance(user, USER2)+curves.curvesTokenBalance(user, USER3)+curves.curvesTokenBalance(user, address(curves)), supplyAfter, "The amount should be right");
  92 | *   |             amountDeposited[user][msg.sender]+=_amount; 
  93 |     | 
  94 |     |         } catch {
  95 | *   |         assertWithMsg(false, "buyCurvesToken should not revert.");
  96 |     |         }
  97 |     | 
  98 |     |         }
  99 |     |  
 100 | *r  |  function test_sellCurvesTokens(uint256 _whichUser, uint256 _amount ) external {
 101 | *   |     _whichUser = clampBetween(_whichUser, 1,3); 
 102 | *   |          address user = _chooseUser(_whichUser); 
 103 | *   |          if(!hasAReference[user])return; 
 104 | *   |          uint256 balancBefore = curves.curvesTokenBalance(user, msg.sender);
 105 | *   |          uint256 supply = curves.curvesTokenSupply(user);
 106 | *   |                      uint256 priceBefore = curves.getPrice(supply, 1);
 107 | *   |     _amount = clampBetween(_amount,0,balancBefore);
 108 | *   |     _amount = clampBetween(_amount,0,supply-1);
 109 | *   |     uint256 _userBalanceBefore = msg.sender.balance;
 110 | *   |     if(balancBefore ==0) return;
 111 | *   |     hevm.prank(msg.sender);
 112 | *   |     try curves.sellCurvesToken(user,_amount){
 113 | *   |         uint256 _userBalanceAfter = msg.sender.balance;
 114 | *   |          uint256 supplyAfter = curves.curvesTokenSupply(user);
 115 | *   |          uint256 priceAfter = curves.getPrice(supplyAfter, 1);
 116 | *   |           assertEq(supplyAfter, supply-_amount, "Supply didn't decrease");
 117 | *   |           if(supplyAfter<supply){
 118 | *   |             assertLt(priceAfter, priceBefore, "price should decrease");
 119 |     |             } else {
 120 | *   |             assertEq(priceAfter, priceBefore, "price should be egal");
 121 |     |             }
 122 | *   |             assertEq(curves.curvesTokenBalance(user, USER1)+curves.curvesTokenBalance(user, USER2)+curves.curvesTokenBalance(user, USER3)+curves.curvesTokenBalance(user, address(curves)), supplyAfter, "The amount should be right");
 123 | *   |             assertGte(_userBalanceAfter,_userBalanceBefore, "the user didn't get ETH");
 124 | *   |             amountDeposited[user][msg.sender]-=_amount; 
 125 |     | 
 126 |     |     }catch {
 127 | *   |         assertWithMsg(false, "sellCurvesToken should not revert.");
 128 |     | 
 129 |     |     }
 130 |     | 
 131 |     |  }
 132 | *r  |  function test_mint() external {
 133 | *   | if( !hasAReference[msg.sender])return; 
 134 | *   | if(isExternal[msg.sender]) return;
 135 | *   | hevm.prank(msg.sender); 
 136 | *   | try curves.mint(msg.sender) {
 137 | *   |     isExternal[msg.sender] = true; 
 138 |     | } catch {
 139 |     | assertWithMsg(false, "Should not revert.");
 140 |     | 
 141 |     | }
 142 |     | 
 143 |     |  }
 144 | *r  | function test_withdraw(uint256 _amount, uint256 _whichUser) external {
 145 | *   | _whichUser = clampBetween(_whichUser, 1,3); 
 146 | *   | address user = _chooseUser(_whichUser); 
 147 | *   | uint256 ERC20BalanceBefore;
 148 | *   | bool wasExternal = isExternal[user];
 149 | *   |  (,,address tokenAddressBefore) = curves.externalCurvesTokens(user);
 150 | *   | if(wasExternal) {
 151 | *   |     ERC20BalanceBefore =CurvesERC20(tokenAddressBefore).balanceOf(msg.sender);
 152 |     | }
 153 | *   |  if(!hasAReference[user])return; 
 154 | *   |          uint256 balancBefore = curves.curvesTokenBalance(user, msg.sender);
 155 | *   |          uint256 supply = curves.curvesTokenSupply(user);
 156 | *   |  _amount = clampBetween(_amount,0,balancBefore);
 157 | *   | hevm.prank(msg.sender);
 158 | *   |  try curves.withdraw(user, _amount) {
 159 | *   |         isExternal[user] = true; 
 160 | *   |         (,,address tokenAddress) = curves.externalCurvesTokens(user);
 161 | *   |         assertWithMsg(tokenAddress!= address(0), "Token wasn't deployed");
 162 | *   |         if(wasExternal) {
 163 | *   |         assertEq(CurvesERC20(tokenAddress).balanceOf(msg.sender),ERC20BalanceBefore + _amount*1 ether, "The user didn't receive the tokens."); 
 164 |     |         }
 165 | *   |         amountExternal+= _amount*1 ether; 
 166 | *   |         assertEq(amountExternal/1 ether, curves.curvesTokenBalance(USER2, address(curves))+ curves.curvesTokenBalance(USER3, address(curves))+curves.curvesTokenBalance(USER1, address(curves)), "Some amount was gained");
 167 |     | 
 168 |     |  } catch {
 169 |     |     assertWithMsg(false, "Should not revert.");
 170 |     | 
 171 |     |  }
 172 |     | 
 173 |     | 
 174 |     | }
 175 | *r  |         function test_deposit(uint256 _whichUser, uint256 _amount) external {
 176 | *   |             _whichUser = clampBetween(_whichUser, 1,3); 
 177 | *   |             address user = _chooseUser(_whichUser); 
 178 | *   |             uint256 ERC20BalanceBefore;
 179 | *   |             bool wasExternal = isExternal[user];
 180 | *   |             (,,address tokenAddressBefore) = curves.externalCurvesTokens(user);
 181 | *   |             if(wasExternal) {
 182 | *   |              ERC20BalanceBefore =CurvesERC20(tokenAddressBefore).balanceOf(msg.sender);
 183 |     |             }
 184 | *   |         if(!hasAReference[user])return; 
 185 | *   |         if(!wasExternal)return;
 186 | *   |         _amount= clampBetween(_amount,0,amountDeposited[user][msg.sender]);
 187 | *   |         hevm.prank(msg.sender); 
 188 | *   |         try curves.deposit(user, _amount*1 ether) {
 189 | *   |         (,,address tokenAddress) = curves.externalCurvesTokens(user);
 190 | *   |         amountExternal-= _amount*1 ether; 
 191 |     | 
 192 | *   |         assertEq(CurvesERC20(tokenAddress).balanceOf(msg.sender),ERC20BalanceBefore + _amount*1 ether, "The user didn't receive the tokens."); 
 193 |     | 
 194 |     |         } catch {    
 195 | *   |             assertWithMsg(false, "Should not revert.");
 196 |     | }
 197 |     |         }
 198 |     | 
 199 |     | 
 200 | *r  |         function test_claimFees(uint256 _whichUser) external {
 201 | *   |             _whichUser = clampBetween(_whichUser, 1,3); 
 202 | *   |             address user = _chooseUser(_whichUser); 
 203 | *   |            uint256 feesClaimable = feeSplitter.getClaimableFees(user, msg.sender); 
 204 | *   |            if(feesClaimable ==0)return; 
 205 | *   |             hevm.prank(msg.sender); 
 206 | *   |             try feeSplitter.claimFees(user) {} catch {
 207 |     |             assertWithMsg(false, "Should not revert.");
 208 |     | 
 209 |     |             }
 210 |     |         }
 211 | *   |         function _chooseUser(uint256 _whichUser) internal pure returns(address user){
 212 | *   |          if(_whichUser==1) user= USER1;
 213 | *   |          if(_whichUser==2)user= USER2;
 214 | *   |          if(_whichUser==3)user= USER3;
 215 |     |         }
 216 |     |         receive() payable external {}
 217 |     | }

/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/contracts/FeeSplitter.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.7;
   3 |     | 
   4 |     | import "./Curves.sol";
   5 |     | import "./Security.sol";
   6 |     | 
   7 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   8 |     | 
   9 | *   | contract FeeSplitter is Security {
  10 |     |     Curves public curves;
  11 | *   |     uint256 constant PRECISION = 1e18;
  12 |     | 
  13 |     |     // Custom errors
  14 |     |     error NoFeesToClaim();
  15 |     |     error NoTokenHolders();
  16 |     | 
  17 |     |     struct TokenData {
  18 |     |         uint256 cumulativeFeePerToken;
  19 |     |         mapping(address => uint256) userFeeOffset;
  20 |     |         mapping(address => uint256) unclaimedFees;
  21 |     |     }
  22 |     | 
  23 |     |     struct UserClaimData {
  24 |     |         uint256 claimableFees;
  25 |     |         address token;
  26 |     |     }
  27 |     | 
  28 |     |     mapping(address => TokenData) internal tokensData;
  29 |     |     mapping(address => address[]) internal userTokens;
  30 |     | 
  31 |     |     event FeesClaimed(address indexed token, address indexed user, uint256 amount);
  32 |     | 
  33 |     |     constructor() Security() {}
  34 |     | 
  35 |     |     function setCurves(Curves curves_) public {
  36 |     |         curves = curves_;
  37 |     |     }
  38 |     | 
  39 | *   |     function balanceOf(address token, address account) public view returns (uint256) {
  40 | *   |         return curves.curvesTokenBalance(token, account) * PRECISION;
  41 |     |     }
  42 |     | 
  43 | *   |     function totalSupply(address token) public view returns (uint256) {
  44 |     |         //@dev: this is the amount of tokens that are not locked in the contract. The locked tokens are in the ERC20 contract
  45 | *   |         return (curves.curvesTokenSupply(token) - curves.curvesTokenBalance(token, address(curves))) * PRECISION;
  46 |     |     }
  47 |     | 
  48 |     |     function getUserTokens(address user) public view returns (address[] memory) {
  49 |     |         return userTokens[user];
  50 |     |     }
  51 |     | 
  52 |     |     function getUserTokensAndClaimable(address user) public view returns (UserClaimData[] memory) {
  53 |     |         address[] memory tokens = getUserTokens(user);
  54 |     |         UserClaimData[] memory result = new UserClaimData[](tokens.length);
  55 |     |         for (uint256 i = 0; i < tokens.length; i++) {
  56 |     |             address token = tokens[i];
  57 |     |             uint256 claimable = getClaimableFees(token, user);
  58 |     |             result[i] = UserClaimData(claimable, token);
  59 |     |         }
  60 |     |         return result;
  61 |     |     }
  62 |     | 
  63 | *   |     function updateFeeCredit(address token, address account) internal {
  64 | *   |         TokenData storage data = tokensData[token];
  65 | *   |         uint256 balance = balanceOf(token, account);
  66 | *   |         if (balance > 0) {
  67 |     |             //@audit problem here.
  68 | *   |             uint256 owed = (data.cumulativeFeePerToken - data.userFeeOffset[account]) * balance;
  69 | *   |             data.unclaimedFees[account] += owed / PRECISION;
  70 | *   |             data.userFeeOffset[account] = data.cumulativeFeePerToken;
  71 |     |         }
  72 |     |     }
  73 |     | 
  74 | *   |     function getClaimableFees(address token, address account) public view returns (uint256) {
  75 | *   |         TokenData storage data = tokensData[token];
  76 | *   |         uint256 balance = balanceOf(token, account);
  77 | *   |         uint256 owed = (data.cumulativeFeePerToken - data.userFeeOffset[account]) * balance;
  78 | *   |         return (owed / PRECISION) + data.unclaimedFees[account];
  79 |     |     }
  80 |     | 
  81 | *   |     function claimFees(address token) external {
  82 | *   |         updateFeeCredit(token, msg.sender);
  83 | *   |         uint256 claimable = getClaimableFees(token, msg.sender);
  84 | *   |         if (claimable == 0) revert NoFeesToClaim();
  85 | *   |         tokensData[token].unclaimedFees[msg.sender] = 0;
  86 | *   |         payable(msg.sender).transfer(claimable);
  87 | *   |         emit FeesClaimed(token, msg.sender, claimable);
  88 |     |     }
  89 |     | 
  90 | *   |     function addFees(address token) public payable onlyManager {
  91 | *   |         uint256 totalSupply_ = totalSupply(token);
  92 | *   |         if (totalSupply_ == 0) revert NoTokenHolders();
  93 | *   |         TokenData storage data = tokensData[token];
  94 | *   |         data.cumulativeFeePerToken += (msg.value * PRECISION) / totalSupply_;
  95 |     |     }
  96 |     | 
  97 | *   |     function onBalanceChange(address token, address account) public onlyManager {
  98 | *   |         TokenData storage data = tokensData[token];
  99 | *   |         data.userFeeOffset[account] = data.cumulativeFeePerToken;
 100 | *   |         if (balanceOf(token, account) > 0) userTokens[account].push(token);
 101 |     |     }
 102 |     | 
 103 |     |     //@dev: this may fail if the the list is long. Get first the list with getUserTokens to estimate and prepare the batch
 104 |     |     function batchClaiming(address[] calldata tokenList) external {
 105 |     |         uint256 totalClaimable = 0;
 106 |     |         for (uint256 i = 0; i < tokenList.length; i++) {
 107 |     |             address token = tokenList[i];
 108 |     |             updateFeeCredit(token, msg.sender);
 109 |     |             uint256 claimable = getClaimableFees(token, msg.sender);
 110 |     |             if (claimable > 0) {
 111 |     |                 tokensData[token].unclaimedFees[msg.sender] = 0;
 112 |     |                 totalClaimable += claimable;
 113 |     |                 emit FeesClaimed(token, msg.sender, claimable);
 114 |     |             }
 115 |     |         }
 116 |     |         if (totalClaimable == 0) revert NoFeesToClaim();
 117 |     |         payable(msg.sender).transfer(totalClaimable);
 118 |     |     }
 119 |     | 
 120 |     |     receive() external payable {}
 121 |     | }
 122 |     | 

/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/contracts/Security.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.7;
  3 |     | 
  4 |     | contract Security {
  5 |     |     address public owner;
  6 |     |     mapping(address => bool) public managers;
  7 |     | 
  8 |     |     modifier onlyOwner() {
  9 |     |         msg.sender == owner;
 10 |     |         _;
 11 |     |     }
 12 |     | 
 13 |     |     modifier onlyManager() {
 14 | *   |         managers[msg.sender] == true;
 15 |     |         _;
 16 |     |     }
 17 |     | 
 18 |     |     constructor() {
 19 |     |         owner = msg.sender;
 20 |     |         managers[msg.sender] = true;
 21 |     |     }
 22 |     | 
 23 |     |     function setManager(address manager_, bool value) public onlyOwner {
 24 |     |         managers[manager_] = value;
 25 |     |     }
 26 |     | 
 27 |     |     function transferOwnership(address owner_) public onlyOwner {
 28 |     |         owner = owner_;
 29 |     |     }
 30 |     | }
 31 |     | 

/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/contracts/Test/MockCurvesForFee.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.7;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  5 |     | 
  6 |     | import "hardhat/console.sol";
  7 |     | 
  8 |     | contract MockCurvesForFee {
  9 |     |     function curvesTokenBalance(address token, address account) public view returns (uint256) {
 10 |     |         return IERC20(token).balanceOf(account);
 11 |     |     }
 12 |     | 
 13 |     |     function curvesTokenSupply(address token) public view returns (uint256) {
 14 |     |         return IERC20(token).totalSupply();
 15 |     |     }
 16 |     | }
 17 |     | 

/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/contracts/Test/MockERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.7;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  5 |     | 
  6 |     | contract MockERC20 is ERC20 {
  7 |     |     uint8 private _decimals;
  8 |     | 
  9 |     |     constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_) {
 10 |     |         _decimals = decimals_;
 11 |     |     }
 12 |     | 
 13 |     |     function mint(address account, uint256 amount) public {
 14 |     |         _mint(account, amount);
 15 |     |     }
 16 |     | 
 17 |     |     function burn(address account, uint256 amount) public {
 18 |     |         _burn(account, amount);
 19 |     |     }
 20 |     | 
 21 |     |     function decimals() public view virtual override returns (uint8) {
 22 |     |         return _decimals;
 23 |     |     }
 24 |     | }
 25 |     | 

/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/hardhat/console.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | pragma solidity >=0.4.22 <0.9.0;
    3 |     | 
    4 |     | library console {
    5 |     |     address constant CONSOLE_ADDRESS =
    6 |     |         0x000000000000000000636F6e736F6c652e6c6f67;
    7 |     | 
    8 |     |     function _sendLogPayloadImplementation(bytes memory payload) internal view {
    9 |     |         address consoleAddress = CONSOLE_ADDRESS;
   10 |     |         /// @solidity memory-safe-assembly
   11 |     |         assembly {
   12 |     |             pop(
   13 |     |                 staticcall(
   14 |     |                     gas(),
   15 |     |                     consoleAddress,
   16 |     |                     add(payload, 32),
   17 |     |                     mload(payload),
   18 |     |                     0,
   19 |     |                     0
   20 |     |                 )
   21 |     |             )
   22 |     |         }
   23 |     |     }
   24 |     | 
   25 |     |     function _castToPure(
   26 |     |       function(bytes memory) internal view fnIn
   27 |     |     ) internal pure returns (function(bytes memory) pure fnOut) {
   28 |     |         assembly {
   29 |     |             fnOut := fnIn
   30 |     |         }
   31 |     |     }
   32 |     | 
   33 |     |     function _sendLogPayload(bytes memory payload) internal pure {
   34 |     |         _castToPure(_sendLogPayloadImplementation)(payload);
   35 |     |     }
   36 |     | 
   37 |     |     function log() internal pure {
   38 |     |         _sendLogPayload(abi.encodeWithSignature("log()"));
   39 |     |     }
   40 |     |     function logInt(int256 p0) internal pure {
   41 |     |         _sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
   42 |     |     }
   43 |     | 
   44 |     |     function logUint(uint256 p0) internal pure {
   45 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
   46 |     |     }
   47 |     | 
   48 |     |     function logString(string memory p0) internal pure {
   49 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
   50 |     |     }
   51 |     | 
   52 |     |     function logBool(bool p0) internal pure {
   53 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
   54 |     |     }
   55 |     | 
   56 |     |     function logAddress(address p0) internal pure {
   57 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
   58 |     |     }
   59 |     | 
   60 |     |     function logBytes(bytes memory p0) internal pure {
   61 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
   62 |     |     }
   63 |     | 
   64 |     |     function logBytes1(bytes1 p0) internal pure {
   65 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
   66 |     |     }
   67 |     | 
   68 |     |     function logBytes2(bytes2 p0) internal pure {
   69 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
   70 |     |     }
   71 |     | 
   72 |     |     function logBytes3(bytes3 p0) internal pure {
   73 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
   74 |     |     }
   75 |     | 
   76 |     |     function logBytes4(bytes4 p0) internal pure {
   77 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
   78 |     |     }
   79 |     | 
   80 |     |     function logBytes5(bytes5 p0) internal pure {
   81 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
   82 |     |     }
   83 |     | 
   84 |     |     function logBytes6(bytes6 p0) internal pure {
   85 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
   86 |     |     }
   87 |     | 
   88 |     |     function logBytes7(bytes7 p0) internal pure {
   89 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
   90 |     |     }
   91 |     | 
   92 |     |     function logBytes8(bytes8 p0) internal pure {
   93 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
   94 |     |     }
   95 |     | 
   96 |     |     function logBytes9(bytes9 p0) internal pure {
   97 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
   98 |     |     }
   99 |     | 
  100 |     |     function logBytes10(bytes10 p0) internal pure {
  101 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
  102 |     |     }
  103 |     | 
  104 |     |     function logBytes11(bytes11 p0) internal pure {
  105 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
  106 |     |     }
  107 |     | 
  108 |     |     function logBytes12(bytes12 p0) internal pure {
  109 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
  110 |     |     }
  111 |     | 
  112 |     |     function logBytes13(bytes13 p0) internal pure {
  113 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
  114 |     |     }
  115 |     | 
  116 |     |     function logBytes14(bytes14 p0) internal pure {
  117 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
  118 |     |     }
  119 |     | 
  120 |     |     function logBytes15(bytes15 p0) internal pure {
  121 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
  122 |     |     }
  123 |     | 
  124 |     |     function logBytes16(bytes16 p0) internal pure {
  125 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
  126 |     |     }
  127 |     | 
  128 |     |     function logBytes17(bytes17 p0) internal pure {
  129 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
  130 |     |     }
  131 |     | 
  132 |     |     function logBytes18(bytes18 p0) internal pure {
  133 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
  134 |     |     }
  135 |     | 
  136 |     |     function logBytes19(bytes19 p0) internal pure {
  137 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
  138 |     |     }
  139 |     | 
  140 |     |     function logBytes20(bytes20 p0) internal pure {
  141 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
  142 |     |     }
  143 |     | 
  144 |     |     function logBytes21(bytes21 p0) internal pure {
  145 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
  146 |     |     }
  147 |     | 
  148 |     |     function logBytes22(bytes22 p0) internal pure {
  149 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
  150 |     |     }
  151 |     | 
  152 |     |     function logBytes23(bytes23 p0) internal pure {
  153 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
  154 |     |     }
  155 |     | 
  156 |     |     function logBytes24(bytes24 p0) internal pure {
  157 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
  158 |     |     }
  159 |     | 
  160 |     |     function logBytes25(bytes25 p0) internal pure {
  161 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
  162 |     |     }
  163 |     | 
  164 |     |     function logBytes26(bytes26 p0) internal pure {
  165 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
  166 |     |     }
  167 |     | 
  168 |     |     function logBytes27(bytes27 p0) internal pure {
  169 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
  170 |     |     }
  171 |     | 
  172 |     |     function logBytes28(bytes28 p0) internal pure {
  173 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
  174 |     |     }
  175 |     | 
  176 |     |     function logBytes29(bytes29 p0) internal pure {
  177 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
  178 |     |     }
  179 |     | 
  180 |     |     function logBytes30(bytes30 p0) internal pure {
  181 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
  182 |     |     }
  183 |     | 
  184 |     |     function logBytes31(bytes31 p0) internal pure {
  185 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
  186 |     |     }
  187 |     | 
  188 |     |     function logBytes32(bytes32 p0) internal pure {
  189 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
  190 |     |     }
  191 |     | 
  192 |     |     function log(uint256 p0) internal pure {
  193 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
  194 |     |     }
  195 |     | 
  196 |     |     function log(string memory p0) internal pure {
  197 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
  198 |     |     }
  199 |     | 
  200 |     |     function log(bool p0) internal pure {
  201 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
  202 |     |     }
  203 |     | 
  204 |     |     function log(address p0) internal pure {
  205 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
  206 |     |     }
  207 |     | 
  208 |     |     function log(uint256 p0, uint256 p1) internal pure {
  209 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256)", p0, p1));
  210 |     |     }
  211 |     | 
  212 |     |     function log(uint256 p0, string memory p1) internal pure {
  213 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string)", p0, p1));
  214 |     |     }
  215 |     | 
  216 |     |     function log(uint256 p0, bool p1) internal pure {
  217 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool)", p0, p1));
  218 |     |     }
  219 |     | 
  220 |     |     function log(uint256 p0, address p1) internal pure {
  221 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address)", p0, p1));
  222 |     |     }
  223 |     | 
  224 |     |     function log(string memory p0, uint256 p1) internal pure {
  225 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256)", p0, p1));
  226 |     |     }
  227 |     | 
  228 |     |     function log(string memory p0, string memory p1) internal pure {
  229 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
  230 |     |     }
  231 |     | 
  232 |     |     function log(string memory p0, bool p1) internal pure {
  233 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
  234 |     |     }
  235 |     | 
  236 |     |     function log(string memory p0, address p1) internal pure {
  237 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
  238 |     |     }
  239 |     | 
  240 |     |     function log(bool p0, uint256 p1) internal pure {
  241 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256)", p0, p1));
  242 |     |     }
  243 |     | 
  244 |     |     function log(bool p0, string memory p1) internal pure {
  245 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
  246 |     |     }
  247 |     | 
  248 |     |     function log(bool p0, bool p1) internal pure {
  249 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
  250 |     |     }
  251 |     | 
  252 |     |     function log(bool p0, address p1) internal pure {
  253 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
  254 |     |     }
  255 |     | 
  256 |     |     function log(address p0, uint256 p1) internal pure {
  257 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256)", p0, p1));
  258 |     |     }
  259 |     | 
  260 |     |     function log(address p0, string memory p1) internal pure {
  261 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
  262 |     |     }
  263 |     | 
  264 |     |     function log(address p0, bool p1) internal pure {
  265 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
  266 |     |     }
  267 |     | 
  268 |     |     function log(address p0, address p1) internal pure {
  269 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
  270 |     |     }
  271 |     | 
  272 |     |     function log(uint256 p0, uint256 p1, uint256 p2) internal pure {
  273 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256)", p0, p1, p2));
  274 |     |     }
  275 |     | 
  276 |     |     function log(uint256 p0, uint256 p1, string memory p2) internal pure {
  277 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string)", p0, p1, p2));
  278 |     |     }
  279 |     | 
  280 |     |     function log(uint256 p0, uint256 p1, bool p2) internal pure {
  281 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool)", p0, p1, p2));
  282 |     |     }
  283 |     | 
  284 |     |     function log(uint256 p0, uint256 p1, address p2) internal pure {
  285 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address)", p0, p1, p2));
  286 |     |     }
  287 |     | 
  288 |     |     function log(uint256 p0, string memory p1, uint256 p2) internal pure {
  289 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256)", p0, p1, p2));
  290 |     |     }
  291 |     | 
  292 |     |     function log(uint256 p0, string memory p1, string memory p2) internal pure {
  293 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string)", p0, p1, p2));
  294 |     |     }
  295 |     | 
  296 |     |     function log(uint256 p0, string memory p1, bool p2) internal pure {
  297 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool)", p0, p1, p2));
  298 |     |     }
  299 |     | 
  300 |     |     function log(uint256 p0, string memory p1, address p2) internal pure {
  301 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address)", p0, p1, p2));
  302 |     |     }
  303 |     | 
  304 |     |     function log(uint256 p0, bool p1, uint256 p2) internal pure {
  305 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256)", p0, p1, p2));
  306 |     |     }
  307 |     | 
  308 |     |     function log(uint256 p0, bool p1, string memory p2) internal pure {
  309 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string)", p0, p1, p2));
  310 |     |     }
  311 |     | 
  312 |     |     function log(uint256 p0, bool p1, bool p2) internal pure {
  313 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool)", p0, p1, p2));
  314 |     |     }
  315 |     | 
  316 |     |     function log(uint256 p0, bool p1, address p2) internal pure {
  317 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address)", p0, p1, p2));
  318 |     |     }
  319 |     | 
  320 |     |     function log(uint256 p0, address p1, uint256 p2) internal pure {
  321 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256)", p0, p1, p2));
  322 |     |     }
  323 |     | 
  324 |     |     function log(uint256 p0, address p1, string memory p2) internal pure {
  325 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string)", p0, p1, p2));
  326 |     |     }
  327 |     | 
  328 |     |     function log(uint256 p0, address p1, bool p2) internal pure {
  329 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool)", p0, p1, p2));
  330 |     |     }
  331 |     | 
  332 |     |     function log(uint256 p0, address p1, address p2) internal pure {
  333 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address)", p0, p1, p2));
  334 |     |     }
  335 |     | 
  336 |     |     function log(string memory p0, uint256 p1, uint256 p2) internal pure {
  337 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256)", p0, p1, p2));
  338 |     |     }
  339 |     | 
  340 |     |     function log(string memory p0, uint256 p1, string memory p2) internal pure {
  341 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string)", p0, p1, p2));
  342 |     |     }
  343 |     | 
  344 |     |     function log(string memory p0, uint256 p1, bool p2) internal pure {
  345 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool)", p0, p1, p2));
  346 |     |     }
  347 |     | 
  348 |     |     function log(string memory p0, uint256 p1, address p2) internal pure {
  349 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address)", p0, p1, p2));
  350 |     |     }
  351 |     | 
  352 |     |     function log(string memory p0, string memory p1, uint256 p2) internal pure {
  353 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256)", p0, p1, p2));
  354 |     |     }
  355 |     | 
  356 |     |     function log(string memory p0, string memory p1, string memory p2) internal pure {
  357 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
  358 |     |     }
  359 |     | 
  360 |     |     function log(string memory p0, string memory p1, bool p2) internal pure {
  361 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
  362 |     |     }
  363 |     | 
  364 |     |     function log(string memory p0, string memory p1, address p2) internal pure {
  365 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
  366 |     |     }
  367 |     | 
  368 |     |     function log(string memory p0, bool p1, uint256 p2) internal pure {
  369 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256)", p0, p1, p2));
  370 |     |     }
  371 |     | 
  372 |     |     function log(string memory p0, bool p1, string memory p2) internal pure {
  373 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
  374 |     |     }
  375 |     | 
  376 |     |     function log(string memory p0, bool p1, bool p2) internal pure {
  377 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
  378 |     |     }
  379 |     | 
  380 |     |     function log(string memory p0, bool p1, address p2) internal pure {
  381 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
  382 |     |     }
  383 |     | 
  384 |     |     function log(string memory p0, address p1, uint256 p2) internal pure {
  385 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256)", p0, p1, p2));
  386 |     |     }
  387 |     | 
  388 |     |     function log(string memory p0, address p1, string memory p2) internal pure {
  389 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
  390 |     |     }
  391 |     | 
  392 |     |     function log(string memory p0, address p1, bool p2) internal pure {
  393 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
  394 |     |     }
  395 |     | 
  396 |     |     function log(string memory p0, address p1, address p2) internal pure {
  397 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
  398 |     |     }
  399 |     | 
  400 |     |     function log(bool p0, uint256 p1, uint256 p2) internal pure {
  401 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256)", p0, p1, p2));
  402 |     |     }
  403 |     | 
  404 |     |     function log(bool p0, uint256 p1, string memory p2) internal pure {
  405 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string)", p0, p1, p2));
  406 |     |     }
  407 |     | 
  408 |     |     function log(bool p0, uint256 p1, bool p2) internal pure {
  409 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool)", p0, p1, p2));
  410 |     |     }
  411 |     | 
  412 |     |     function log(bool p0, uint256 p1, address p2) internal pure {
  413 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address)", p0, p1, p2));
  414 |     |     }
  415 |     | 
  416 |     |     function log(bool p0, string memory p1, uint256 p2) internal pure {
  417 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256)", p0, p1, p2));
  418 |     |     }
  419 |     | 
  420 |     |     function log(bool p0, string memory p1, string memory p2) internal pure {
  421 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
  422 |     |     }
  423 |     | 
  424 |     |     function log(bool p0, string memory p1, bool p2) internal pure {
  425 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
  426 |     |     }
  427 |     | 
  428 |     |     function log(bool p0, string memory p1, address p2) internal pure {
  429 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
  430 |     |     }
  431 |     | 
  432 |     |     function log(bool p0, bool p1, uint256 p2) internal pure {
  433 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256)", p0, p1, p2));
  434 |     |     }
  435 |     | 
  436 |     |     function log(bool p0, bool p1, string memory p2) internal pure {
  437 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
  438 |     |     }
  439 |     | 
  440 |     |     function log(bool p0, bool p1, bool p2) internal pure {
  441 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
  442 |     |     }
  443 |     | 
  444 |     |     function log(bool p0, bool p1, address p2) internal pure {
  445 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
  446 |     |     }
  447 |     | 
  448 |     |     function log(bool p0, address p1, uint256 p2) internal pure {
  449 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256)", p0, p1, p2));
  450 |     |     }
  451 |     | 
  452 |     |     function log(bool p0, address p1, string memory p2) internal pure {
  453 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
  454 |     |     }
  455 |     | 
  456 |     |     function log(bool p0, address p1, bool p2) internal pure {
  457 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
  458 |     |     }
  459 |     | 
  460 |     |     function log(bool p0, address p1, address p2) internal pure {
  461 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
  462 |     |     }
  463 |     | 
  464 |     |     function log(address p0, uint256 p1, uint256 p2) internal pure {
  465 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256)", p0, p1, p2));
  466 |     |     }
  467 |     | 
  468 |     |     function log(address p0, uint256 p1, string memory p2) internal pure {
  469 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string)", p0, p1, p2));
  470 |     |     }
  471 |     | 
  472 |     |     function log(address p0, uint256 p1, bool p2) internal pure {
  473 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool)", p0, p1, p2));
  474 |     |     }
  475 |     | 
  476 |     |     function log(address p0, uint256 p1, address p2) internal pure {
  477 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address)", p0, p1, p2));
  478 |     |     }
  479 |     | 
  480 |     |     function log(address p0, string memory p1, uint256 p2) internal pure {
  481 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256)", p0, p1, p2));
  482 |     |     }
  483 |     | 
  484 |     |     function log(address p0, string memory p1, string memory p2) internal pure {
  485 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
  486 |     |     }
  487 |     | 
  488 |     |     function log(address p0, string memory p1, bool p2) internal pure {
  489 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
  490 |     |     }
  491 |     | 
  492 |     |     function log(address p0, string memory p1, address p2) internal pure {
  493 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
  494 |     |     }
  495 |     | 
  496 |     |     function log(address p0, bool p1, uint256 p2) internal pure {
  497 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256)", p0, p1, p2));
  498 |     |     }
  499 |     | 
  500 |     |     function log(address p0, bool p1, string memory p2) internal pure {
  501 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
  502 |     |     }
  503 |     | 
  504 |     |     function log(address p0, bool p1, bool p2) internal pure {
  505 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
  506 |     |     }
  507 |     | 
  508 |     |     function log(address p0, bool p1, address p2) internal pure {
  509 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
  510 |     |     }
  511 |     | 
  512 |     |     function log(address p0, address p1, uint256 p2) internal pure {
  513 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256)", p0, p1, p2));
  514 |     |     }
  515 |     | 
  516 |     |     function log(address p0, address p1, string memory p2) internal pure {
  517 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
  518 |     |     }
  519 |     | 
  520 |     |     function log(address p0, address p1, bool p2) internal pure {
  521 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
  522 |     |     }
  523 |     | 
  524 |     |     function log(address p0, address p1, address p2) internal pure {
  525 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
  526 |     |     }
  527 |     | 
  528 |     |     function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  529 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,uint256)", p0, p1, p2, p3));
  530 |     |     }
  531 |     | 
  532 |     |     function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {
  533 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,string)", p0, p1, p2, p3));
  534 |     |     }
  535 |     | 
  536 |     |     function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {
  537 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,bool)", p0, p1, p2, p3));
  538 |     |     }
  539 |     | 
  540 |     |     function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {
  541 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,address)", p0, p1, p2, p3));
  542 |     |     }
  543 |     | 
  544 |     |     function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {
  545 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,uint256)", p0, p1, p2, p3));
  546 |     |     }
  547 |     | 
  548 |     |     function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {
  549 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,string)", p0, p1, p2, p3));
  550 |     |     }
  551 |     | 
  552 |     |     function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {
  553 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,bool)", p0, p1, p2, p3));
  554 |     |     }
  555 |     | 
  556 |     |     function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {
  557 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,address)", p0, p1, p2, p3));
  558 |     |     }
  559 |     | 
  560 |     |     function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {
  561 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,uint256)", p0, p1, p2, p3));
  562 |     |     }
  563 |     | 
  564 |     |     function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {
  565 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,string)", p0, p1, p2, p3));
  566 |     |     }
  567 |     | 
  568 |     |     function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {
  569 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,bool)", p0, p1, p2, p3));
  570 |     |     }
  571 |     | 
  572 |     |     function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {
  573 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,address)", p0, p1, p2, p3));
  574 |     |     }
  575 |     | 
  576 |     |     function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {
  577 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,uint256)", p0, p1, p2, p3));
  578 |     |     }
  579 |     | 
  580 |     |     function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {
  581 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,string)", p0, p1, p2, p3));
  582 |     |     }
  583 |     | 
  584 |     |     function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {
  585 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,bool)", p0, p1, p2, p3));
  586 |     |     }
  587 |     | 
  588 |     |     function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {
  589 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,address)", p0, p1, p2, p3));
  590 |     |     }
  591 |     | 
  592 |     |     function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {
  593 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,uint256)", p0, p1, p2, p3));
  594 |     |     }
  595 |     | 
  596 |     |     function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {
  597 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,string)", p0, p1, p2, p3));
  598 |     |     }
  599 |     | 
  600 |     |     function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {
  601 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,bool)", p0, p1, p2, p3));
  602 |     |     }
  603 |     | 
  604 |     |     function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {
  605 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,address)", p0, p1, p2, p3));
  606 |     |     }
  607 |     | 
  608 |     |     function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {
  609 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,uint256)", p0, p1, p2, p3));
  610 |     |     }
  611 |     | 
  612 |     |     function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {
  613 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,string)", p0, p1, p2, p3));
  614 |     |     }
  615 |     | 
  616 |     |     function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {
  617 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,bool)", p0, p1, p2, p3));
  618 |     |     }
  619 |     | 
  620 |     |     function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {
  621 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,address)", p0, p1, p2, p3));
  622 |     |     }
  623 |     | 
  624 |     |     function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {
  625 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,uint256)", p0, p1, p2, p3));
  626 |     |     }
  627 |     | 
  628 |     |     function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {
  629 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,string)", p0, p1, p2, p3));
  630 |     |     }
  631 |     | 
  632 |     |     function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {
  633 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,bool)", p0, p1, p2, p3));
  634 |     |     }
  635 |     | 
  636 |     |     function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {
  637 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,address)", p0, p1, p2, p3));
  638 |     |     }
  639 |     | 
  640 |     |     function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {
  641 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,uint256)", p0, p1, p2, p3));
  642 |     |     }
  643 |     | 
  644 |     |     function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {
  645 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,string)", p0, p1, p2, p3));
  646 |     |     }
  647 |     | 
  648 |     |     function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {
  649 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,bool)", p0, p1, p2, p3));
  650 |     |     }
  651 |     | 
  652 |     |     function log(uint256 p0, string memory p1, address p2, address p3) internal pure {
  653 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,address)", p0, p1, p2, p3));
  654 |     |     }
  655 |     | 
  656 |     |     function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {
  657 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,uint256)", p0, p1, p2, p3));
  658 |     |     }
  659 |     | 
  660 |     |     function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {
  661 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,string)", p0, p1, p2, p3));
  662 |     |     }
  663 |     | 
  664 |     |     function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {
  665 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,bool)", p0, p1, p2, p3));
  666 |     |     }
  667 |     | 
  668 |     |     function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {
  669 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,address)", p0, p1, p2, p3));
  670 |     |     }
  671 |     | 
  672 |     |     function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {
  673 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,uint256)", p0, p1, p2, p3));
  674 |     |     }
  675 |     | 
  676 |     |     function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {
  677 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,string)", p0, p1, p2, p3));
  678 |     |     }
  679 |     | 
  680 |     |     function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {
  681 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,bool)", p0, p1, p2, p3));
  682 |     |     }
  683 |     | 
  684 |     |     function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {
  685 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,address)", p0, p1, p2, p3));
  686 |     |     }
  687 |     | 
  688 |     |     function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {
  689 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,uint256)", p0, p1, p2, p3));
  690 |     |     }
  691 |     | 
  692 |     |     function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {
  693 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,string)", p0, p1, p2, p3));
  694 |     |     }
  695 |     | 
  696 |     |     function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {
  697 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,bool)", p0, p1, p2, p3));
  698 |     |     }
  699 |     | 
  700 |     |     function log(uint256 p0, bool p1, bool p2, address p3) internal pure {
  701 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,address)", p0, p1, p2, p3));
  702 |     |     }
  703 |     | 
  704 |     |     function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {
  705 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,uint256)", p0, p1, p2, p3));
  706 |     |     }
  707 |     | 
  708 |     |     function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {
  709 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,string)", p0, p1, p2, p3));
  710 |     |     }
  711 |     | 
  712 |     |     function log(uint256 p0, bool p1, address p2, bool p3) internal pure {
  713 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,bool)", p0, p1, p2, p3));
  714 |     |     }
  715 |     | 
  716 |     |     function log(uint256 p0, bool p1, address p2, address p3) internal pure {
  717 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,address)", p0, p1, p2, p3));
  718 |     |     }
  719 |     | 
  720 |     |     function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {
  721 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,uint256)", p0, p1, p2, p3));
  722 |     |     }
  723 |     | 
  724 |     |     function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {
  725 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,string)", p0, p1, p2, p3));
  726 |     |     }
  727 |     | 
  728 |     |     function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {
  729 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,bool)", p0, p1, p2, p3));
  730 |     |     }
  731 |     | 
  732 |     |     function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {
  733 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,address)", p0, p1, p2, p3));
  734 |     |     }
  735 |     | 
  736 |     |     function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {
  737 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,uint256)", p0, p1, p2, p3));
  738 |     |     }
  739 |     | 
  740 |     |     function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {
  741 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,string)", p0, p1, p2, p3));
  742 |     |     }
  743 |     | 
  744 |     |     function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {
  745 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,bool)", p0, p1, p2, p3));
  746 |     |     }
  747 |     | 
  748 |     |     function log(uint256 p0, address p1, string memory p2, address p3) internal pure {
  749 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,address)", p0, p1, p2, p3));
  750 |     |     }
  751 |     | 
  752 |     |     function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {
  753 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,uint256)", p0, p1, p2, p3));
  754 |     |     }
  755 |     | 
  756 |     |     function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {
  757 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,string)", p0, p1, p2, p3));
  758 |     |     }
  759 |     | 
  760 |     |     function log(uint256 p0, address p1, bool p2, bool p3) internal pure {
  761 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,bool)", p0, p1, p2, p3));
  762 |     |     }
  763 |     | 
  764 |     |     function log(uint256 p0, address p1, bool p2, address p3) internal pure {
  765 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,address)", p0, p1, p2, p3));
  766 |     |     }
  767 |     | 
  768 |     |     function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {
  769 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,uint256)", p0, p1, p2, p3));
  770 |     |     }
  771 |     | 
  772 |     |     function log(uint256 p0, address p1, address p2, string memory p3) internal pure {
  773 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,string)", p0, p1, p2, p3));
  774 |     |     }
  775 |     | 
  776 |     |     function log(uint256 p0, address p1, address p2, bool p3) internal pure {
  777 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,bool)", p0, p1, p2, p3));
  778 |     |     }
  779 |     | 
  780 |     |     function log(uint256 p0, address p1, address p2, address p3) internal pure {
  781 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,address)", p0, p1, p2, p3));
  782 |     |     }
  783 |     | 
  784 |     |     function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  785 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,uint256)", p0, p1, p2, p3));
  786 |     |     }
  787 |     | 
  788 |     |     function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {
  789 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,string)", p0, p1, p2, p3));
  790 |     |     }
  791 |     | 
  792 |     |     function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {
  793 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,bool)", p0, p1, p2, p3));
  794 |     |     }
  795 |     | 
  796 |     |     function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {
  797 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,address)", p0, p1, p2, p3));
  798 |     |     }
  799 |     | 
  800 |     |     function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {
  801 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,uint256)", p0, p1, p2, p3));
  802 |     |     }
  803 |     | 
  804 |     |     function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {
  805 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,string)", p0, p1, p2, p3));
  806 |     |     }
  807 |     | 
  808 |     |     function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {
  809 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,bool)", p0, p1, p2, p3));
  810 |     |     }
  811 |     | 
  812 |     |     function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {
  813 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,address)", p0, p1, p2, p3));
  814 |     |     }
  815 |     | 
  816 |     |     function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {
  817 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,uint256)", p0, p1, p2, p3));
  818 |     |     }
  819 |     | 
  820 |     |     function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {
  821 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,string)", p0, p1, p2, p3));
  822 |     |     }
  823 |     | 
  824 |     |     function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {
  825 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,bool)", p0, p1, p2, p3));
  826 |     |     }
  827 |     | 
  828 |     |     function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {
  829 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,address)", p0, p1, p2, p3));
  830 |     |     }
  831 |     | 
  832 |     |     function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {
  833 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,uint256)", p0, p1, p2, p3));
  834 |     |     }
  835 |     | 
  836 |     |     function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {
  837 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,string)", p0, p1, p2, p3));
  838 |     |     }
  839 |     | 
  840 |     |     function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {
  841 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,bool)", p0, p1, p2, p3));
  842 |     |     }
  843 |     | 
  844 |     |     function log(string memory p0, uint256 p1, address p2, address p3) internal pure {
  845 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,address)", p0, p1, p2, p3));
  846 |     |     }
  847 |     | 
  848 |     |     function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {
  849 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,uint256)", p0, p1, p2, p3));
  850 |     |     }
  851 |     | 
  852 |     |     function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {
  853 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,string)", p0, p1, p2, p3));
  854 |     |     }
  855 |     | 
  856 |     |     function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {
  857 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,bool)", p0, p1, p2, p3));
  858 |     |     }
  859 |     | 
  860 |     |     function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {
  861 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,address)", p0, p1, p2, p3));
  862 |     |     }
  863 |     | 
  864 |     |     function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {
  865 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint256)", p0, p1, p2, p3));
  866 |     |     }
  867 |     | 
  868 |     |     function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {
  869 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
  870 |     |     }
  871 |     | 
  872 |     |     function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {
  873 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
  874 |     |     }
  875 |     | 
  876 |     |     function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {
  877 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
  878 |     |     }
  879 |     | 
  880 |     |     function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {
  881 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint256)", p0, p1, p2, p3));
  882 |     |     }
  883 |     | 
  884 |     |     function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {
  885 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
  886 |     |     }
  887 |     | 
  888 |     |     function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {
  889 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
  890 |     |     }
  891 |     | 
  892 |     |     function log(string memory p0, string memory p1, bool p2, address p3) internal pure {
  893 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
  894 |     |     }
  895 |     | 
  896 |     |     function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {
  897 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint256)", p0, p1, p2, p3));
  898 |     |     }
  899 |     | 
  900 |     |     function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {
  901 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
  902 |     |     }
  903 |     | 
  904 |     |     function log(string memory p0, string memory p1, address p2, bool p3) internal pure {
  905 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
  906 |     |     }
  907 |     | 
  908 |     |     function log(string memory p0, string memory p1, address p2, address p3) internal pure {
  909 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
  910 |     |     }
  911 |     | 
  912 |     |     function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {
  913 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,uint256)", p0, p1, p2, p3));
  914 |     |     }
  915 |     | 
  916 |     |     function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {
  917 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,string)", p0, p1, p2, p3));
  918 |     |     }
  919 |     | 
  920 |     |     function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {
  921 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,bool)", p0, p1, p2, p3));
  922 |     |     }
  923 |     | 
  924 |     |     function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {
  925 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,address)", p0, p1, p2, p3));
  926 |     |     }
  927 |     | 
  928 |     |     function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {
  929 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint256)", p0, p1, p2, p3));
  930 |     |     }
  931 |     | 
  932 |     |     function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {
  933 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
  934 |     |     }
  935 |     | 
  936 |     |     function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {
  937 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
  938 |     |     }
  939 |     | 
  940 |     |     function log(string memory p0, bool p1, string memory p2, address p3) internal pure {
  941 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
  942 |     |     }
  943 |     | 
  944 |     |     function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {
  945 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint256)", p0, p1, p2, p3));
  946 |     |     }
  947 |     | 
  948 |     |     function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {
  949 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
  950 |     |     }
  951 |     | 
  952 |     |     function log(string memory p0, bool p1, bool p2, bool p3) internal pure {
  953 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
  954 |     |     }
  955 |     | 
  956 |     |     function log(string memory p0, bool p1, bool p2, address p3) internal pure {
  957 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
  958 |     |     }
  959 |     | 
  960 |     |     function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {
  961 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint256)", p0, p1, p2, p3));
  962 |     |     }
  963 |     | 
  964 |     |     function log(string memory p0, bool p1, address p2, string memory p3) internal pure {
  965 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
  966 |     |     }
  967 |     | 
  968 |     |     function log(string memory p0, bool p1, address p2, bool p3) internal pure {
  969 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
  970 |     |     }
  971 |     | 
  972 |     |     function log(string memory p0, bool p1, address p2, address p3) internal pure {
  973 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
  974 |     |     }
  975 |     | 
  976 |     |     function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {
  977 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,uint256)", p0, p1, p2, p3));
  978 |     |     }
  979 |     | 
  980 |     |     function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {
  981 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,string)", p0, p1, p2, p3));
  982 |     |     }
  983 |     | 
  984 |     |     function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {
  985 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,bool)", p0, p1, p2, p3));
  986 |     |     }
  987 |     | 
  988 |     |     function log(string memory p0, address p1, uint256 p2, address p3) internal pure {
  989 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,address)", p0, p1, p2, p3));
  990 |     |     }
  991 |     | 
  992 |     |     function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {
  993 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint256)", p0, p1, p2, p3));
  994 |     |     }
  995 |     | 
  996 |     |     function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {
  997 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
  998 |     |     }
  999 |     | 
 1000 |     |     function log(string memory p0, address p1, string memory p2, bool p3) internal pure {
 1001 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
 1002 |     |     }
 1003 |     | 
 1004 |     |     function log(string memory p0, address p1, string memory p2, address p3) internal pure {
 1005 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
 1006 |     |     }
 1007 |     | 
 1008 |     |     function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {
 1009 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint256)", p0, p1, p2, p3));
 1010 |     |     }
 1011 |     | 
 1012 |     |     function log(string memory p0, address p1, bool p2, string memory p3) internal pure {
 1013 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
 1014 |     |     }
 1015 |     | 
 1016 |     |     function log(string memory p0, address p1, bool p2, bool p3) internal pure {
 1017 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
 1018 |     |     }
 1019 |     | 
 1020 |     |     function log(string memory p0, address p1, bool p2, address p3) internal pure {
 1021 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
 1022 |     |     }
 1023 |     | 
 1024 |     |     function log(string memory p0, address p1, address p2, uint256 p3) internal pure {
 1025 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint256)", p0, p1, p2, p3));
 1026 |     |     }
 1027 |     | 
 1028 |     |     function log(string memory p0, address p1, address p2, string memory p3) internal pure {
 1029 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
 1030 |     |     }
 1031 |     | 
 1032 |     |     function log(string memory p0, address p1, address p2, bool p3) internal pure {
 1033 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
 1034 |     |     }
 1035 |     | 
 1036 |     |     function log(string memory p0, address p1, address p2, address p3) internal pure {
 1037 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
 1038 |     |     }
 1039 |     | 
 1040 |     |     function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
 1041 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,uint256)", p0, p1, p2, p3));
 1042 |     |     }
 1043 |     | 
 1044 |     |     function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {
 1045 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,string)", p0, p1, p2, p3));
 1046 |     |     }
 1047 |     | 
 1048 |     |     function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {
 1049 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,bool)", p0, p1, p2, p3));
 1050 |     |     }
 1051 |     | 
 1052 |     |     function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {
 1053 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,address)", p0, p1, p2, p3));
 1054 |     |     }
 1055 |     | 
 1056 |     |     function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {
 1057 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,uint256)", p0, p1, p2, p3));
 1058 |     |     }
 1059 |     | 
 1060 |     |     function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {
 1061 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,string)", p0, p1, p2, p3));
 1062 |     |     }
 1063 |     | 
 1064 |     |     function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {
 1065 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,bool)", p0, p1, p2, p3));
 1066 |     |     }
 1067 |     | 
 1068 |     |     function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {
 1069 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,address)", p0, p1, p2, p3));
 1070 |     |     }
 1071 |     | 
 1072 |     |     function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {
 1073 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,uint256)", p0, p1, p2, p3));
 1074 |     |     }
 1075 |     | 
 1076 |     |     function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {
 1077 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,string)", p0, p1, p2, p3));
 1078 |     |     }
 1079 |     | 
 1080 |     |     function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {
 1081 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,bool)", p0, p1, p2, p3));
 1082 |     |     }
 1083 |     | 
 1084 |     |     function log(bool p0, uint256 p1, bool p2, address p3) internal pure {
 1085 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,address)", p0, p1, p2, p3));
 1086 |     |     }
 1087 |     | 
 1088 |     |     function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {
 1089 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,uint256)", p0, p1, p2, p3));
 1090 |     |     }
 1091 |     | 
 1092 |     |     function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {
 1093 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,string)", p0, p1, p2, p3));
 1094 |     |     }
 1095 |     | 
 1096 |     |     function log(bool p0, uint256 p1, address p2, bool p3) internal pure {
 1097 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,bool)", p0, p1, p2, p3));
 1098 |     |     }
 1099 |     | 
 1100 |     |     function log(bool p0, uint256 p1, address p2, address p3) internal pure {
 1101 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,address)", p0, p1, p2, p3));
 1102 |     |     }
 1103 |     | 
 1104 |     |     function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {
 1105 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,uint256)", p0, p1, p2, p3));
 1106 |     |     }
 1107 |     | 
 1108 |     |     function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {
 1109 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,string)", p0, p1, p2, p3));
 1110 |     |     }
 1111 |     | 
 1112 |     |     function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {
 1113 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,bool)", p0, p1, p2, p3));
 1114 |     |     }
 1115 |     | 
 1116 |     |     function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {
 1117 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,address)", p0, p1, p2, p3));
 1118 |     |     }
 1119 |     | 
 1120 |     |     function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {
 1121 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint256)", p0, p1, p2, p3));
 1122 |     |     }
 1123 |     | 
 1124 |     |     function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {
 1125 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
 1126 |     |     }
 1127 |     | 
 1128 |     |     function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {
 1129 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
 1130 |     |     }
 1131 |     | 
 1132 |     |     function log(bool p0, string memory p1, string memory p2, address p3) internal pure {
 1133 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
 1134 |     |     }
 1135 |     | 
 1136 |     |     function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {
 1137 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint256)", p0, p1, p2, p3));
 1138 |     |     }
 1139 |     | 
 1140 |     |     function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {
 1141 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
 1142 |     |     }
 1143 |     | 
 1144 |     |     function log(bool p0, string memory p1, bool p2, bool p3) internal pure {
 1145 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
 1146 |     |     }
 1147 |     | 
 1148 |     |     function log(bool p0, string memory p1, bool p2, address p3) internal pure {
 1149 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
 1150 |     |     }
 1151 |     | 
 1152 |     |     function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {
 1153 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint256)", p0, p1, p2, p3));
 1154 |     |     }
 1155 |     | 
 1156 |     |     function log(bool p0, string memory p1, address p2, string memory p3) internal pure {
 1157 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
 1158 |     |     }
 1159 |     | 
 1160 |     |     function log(bool p0, string memory p1, address p2, bool p3) internal pure {
 1161 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
 1162 |     |     }
 1163 |     | 
 1164 |     |     function log(bool p0, string memory p1, address p2, address p3) internal pure {
 1165 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
 1166 |     |     }
 1167 |     | 
 1168 |     |     function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {
 1169 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,uint256)", p0, p1, p2, p3));
 1170 |     |     }
 1171 |     | 
 1172 |     |     function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {
 1173 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,string)", p0, p1, p2, p3));
 1174 |     |     }
 1175 |     | 
 1176 |     |     function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {
 1177 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,bool)", p0, p1, p2, p3));
 1178 |     |     }
 1179 |     | 
 1180 |     |     function log(bool p0, bool p1, uint256 p2, address p3) internal pure {
 1181 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,address)", p0, p1, p2, p3));
 1182 |     |     }
 1183 |     | 
 1184 |     |     function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {
 1185 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint256)", p0, p1, p2, p3));
 1186 |     |     }
 1187 |     | 
 1188 |     |     function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {
 1189 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
 1190 |     |     }
 1191 |     | 
 1192 |     |     function log(bool p0, bool p1, string memory p2, bool p3) internal pure {
 1193 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
 1194 |     |     }
 1195 |     | 
 1196 |     |     function log(bool p0, bool p1, string memory p2, address p3) internal pure {
 1197 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
 1198 |     |     }
 1199 |     | 
 1200 |     |     function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {
 1201 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint256)", p0, p1, p2, p3));
 1202 |     |     }
 1203 |     | 
 1204 |     |     function log(bool p0, bool p1, bool p2, string memory p3) internal pure {
 1205 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
 1206 |     |     }
 1207 |     | 
 1208 |     |     function log(bool p0, bool p1, bool p2, bool p3) internal pure {
 1209 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
 1210 |     |     }
 1211 |     | 
 1212 |     |     function log(bool p0, bool p1, bool p2, address p3) internal pure {
 1213 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
 1214 |     |     }
 1215 |     | 
 1216 |     |     function log(bool p0, bool p1, address p2, uint256 p3) internal pure {
 1217 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint256)", p0, p1, p2, p3));
 1218 |     |     }
 1219 |     | 
 1220 |     |     function log(bool p0, bool p1, address p2, string memory p3) internal pure {
 1221 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
 1222 |     |     }
 1223 |     | 
 1224 |     |     function log(bool p0, bool p1, address p2, bool p3) internal pure {
 1225 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
 1226 |     |     }
 1227 |     | 
 1228 |     |     function log(bool p0, bool p1, address p2, address p3) internal pure {
 1229 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
 1230 |     |     }
 1231 |     | 
 1232 |     |     function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {
 1233 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,uint256)", p0, p1, p2, p3));
 1234 |     |     }
 1235 |     | 
 1236 |     |     function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {
 1237 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,string)", p0, p1, p2, p3));
 1238 |     |     }
 1239 |     | 
 1240 |     |     function log(bool p0, address p1, uint256 p2, bool p3) internal pure {
 1241 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,bool)", p0, p1, p2, p3));
 1242 |     |     }
 1243 |     | 
 1244 |     |     function log(bool p0, address p1, uint256 p2, address p3) internal pure {
 1245 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,address)", p0, p1, p2, p3));
 1246 |     |     }
 1247 |     | 
 1248 |     |     function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {
 1249 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint256)", p0, p1, p2, p3));
 1250 |     |     }
 1251 |     | 
 1252 |     |     function log(bool p0, address p1, string memory p2, string memory p3) internal pure {
 1253 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
 1254 |     |     }
 1255 |     | 
 1256 |     |     function log(bool p0, address p1, string memory p2, bool p3) internal pure {
 1257 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
 1258 |     |     }
 1259 |     | 
 1260 |     |     function log(bool p0, address p1, string memory p2, address p3) internal pure {
 1261 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
 1262 |     |     }
 1263 |     | 
 1264 |     |     function log(bool p0, address p1, bool p2, uint256 p3) internal pure {
 1265 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint256)", p0, p1, p2, p3));
 1266 |     |     }
 1267 |     | 
 1268 |     |     function log(bool p0, address p1, bool p2, string memory p3) internal pure {
 1269 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
 1270 |     |     }
 1271 |     | 
 1272 |     |     function log(bool p0, address p1, bool p2, bool p3) internal pure {
 1273 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
 1274 |     |     }
 1275 |     | 
 1276 |     |     function log(bool p0, address p1, bool p2, address p3) internal pure {
 1277 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
 1278 |     |     }
 1279 |     | 
 1280 |     |     function log(bool p0, address p1, address p2, uint256 p3) internal pure {
 1281 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint256)", p0, p1, p2, p3));
 1282 |     |     }
 1283 |     | 
 1284 |     |     function log(bool p0, address p1, address p2, string memory p3) internal pure {
 1285 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
 1286 |     |     }
 1287 |     | 
 1288 |     |     function log(bool p0, address p1, address p2, bool p3) internal pure {
 1289 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
 1290 |     |     }
 1291 |     | 
 1292 |     |     function log(bool p0, address p1, address p2, address p3) internal pure {
 1293 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
 1294 |     |     }
 1295 |     | 
 1296 |     |     function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
 1297 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,uint256)", p0, p1, p2, p3));
 1298 |     |     }
 1299 |     | 
 1300 |     |     function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {
 1301 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,string)", p0, p1, p2, p3));
 1302 |     |     }
 1303 |     | 
 1304 |     |     function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {
 1305 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,bool)", p0, p1, p2, p3));
 1306 |     |     }
 1307 |     | 
 1308 |     |     function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {
 1309 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,address)", p0, p1, p2, p3));
 1310 |     |     }
 1311 |     | 
 1312 |     |     function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {
 1313 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,uint256)", p0, p1, p2, p3));
 1314 |     |     }
 1315 |     | 
 1316 |     |     function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {
 1317 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,string)", p0, p1, p2, p3));
 1318 |     |     }
 1319 |     | 
 1320 |     |     function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {
 1321 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,bool)", p0, p1, p2, p3));
 1322 |     |     }
 1323 |     | 
 1324 |     |     function log(address p0, uint256 p1, string memory p2, address p3) internal pure {
 1325 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,address)", p0, p1, p2, p3));
 1326 |     |     }
 1327 |     | 
 1328 |     |     function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {
 1329 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,uint256)", p0, p1, p2, p3));
 1330 |     |     }
 1331 |     | 
 1332 |     |     function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {
 1333 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,string)", p0, p1, p2, p3));
 1334 |     |     }
 1335 |     | 
 1336 |     |     function log(address p0, uint256 p1, bool p2, bool p3) internal pure {
 1337 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,bool)", p0, p1, p2, p3));
 1338 |     |     }
 1339 |     | 
 1340 |     |     function log(address p0, uint256 p1, bool p2, address p3) internal pure {
 1341 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,address)", p0, p1, p2, p3));
 1342 |     |     }
 1343 |     | 
 1344 |     |     function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {
 1345 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,uint256)", p0, p1, p2, p3));
 1346 |     |     }
 1347 |     | 
 1348 |     |     function log(address p0, uint256 p1, address p2, string memory p3) internal pure {
 1349 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,string)", p0, p1, p2, p3));
 1350 |     |     }
 1351 |     | 
 1352 |     |     function log(address p0, uint256 p1, address p2, bool p3) internal pure {
 1353 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,bool)", p0, p1, p2, p3));
 1354 |     |     }
 1355 |     | 
 1356 |     |     function log(address p0, uint256 p1, address p2, address p3) internal pure {
 1357 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,address)", p0, p1, p2, p3));
 1358 |     |     }
 1359 |     | 
 1360 |     |     function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {
 1361 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,uint256)", p0, p1, p2, p3));
 1362 |     |     }
 1363 |     | 
 1364 |     |     function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {
 1365 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,string)", p0, p1, p2, p3));
 1366 |     |     }
 1367 |     | 
 1368 |     |     function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {
 1369 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,bool)", p0, p1, p2, p3));
 1370 |     |     }
 1371 |     | 
 1372 |     |     function log(address p0, string memory p1, uint256 p2, address p3) internal pure {
 1373 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,address)", p0, p1, p2, p3));
 1374 |     |     }
 1375 |     | 
 1376 |     |     function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {
 1377 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint256)", p0, p1, p2, p3));
 1378 |     |     }
 1379 |     | 
 1380 |     |     function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {
 1381 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
 1382 |     |     }
 1383 |     | 
 1384 |     |     function log(address p0, string memory p1, string memory p2, bool p3) internal pure {
 1385 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
 1386 |     |     }
 1387 |     | 
 1388 |     |     function log(address p0, string memory p1, string memory p2, address p3) internal pure {
 1389 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
 1390 |     |     }
 1391 |     | 
 1392 |     |     function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {
 1393 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint256)", p0, p1, p2, p3));
 1394 |     |     }
 1395 |     | 
 1396 |     |     function log(address p0, string memory p1, bool p2, string memory p3) internal pure {
 1397 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
 1398 |     |     }
 1399 |     | 
 1400 |     |     function log(address p0, string memory p1, bool p2, bool p3) internal pure {
 1401 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
 1402 |     |     }
 1403 |     | 
 1404 |     |     function log(address p0, string memory p1, bool p2, address p3) internal pure {
 1405 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
 1406 |     |     }
 1407 |     | 
 1408 |     |     function log(address p0, string memory p1, address p2, uint256 p3) internal pure {
 1409 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint256)", p0, p1, p2, p3));
 1410 |     |     }
 1411 |     | 
 1412 |     |     function log(address p0, string memory p1, address p2, string memory p3) internal pure {
 1413 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
 1414 |     |     }
 1415 |     | 
 1416 |     |     function log(address p0, string memory p1, address p2, bool p3) internal pure {
 1417 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
 1418 |     |     }
 1419 |     | 
 1420 |     |     function log(address p0, string memory p1, address p2, address p3) internal pure {
 1421 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
 1422 |     |     }
 1423 |     | 
 1424 |     |     function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {
 1425 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,uint256)", p0, p1, p2, p3));
 1426 |     |     }
 1427 |     | 
 1428 |     |     function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {
 1429 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,string)", p0, p1, p2, p3));
 1430 |     |     }
 1431 |     | 
 1432 |     |     function log(address p0, bool p1, uint256 p2, bool p3) internal pure {
 1433 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,bool)", p0, p1, p2, p3));
 1434 |     |     }
 1435 |     | 
 1436 |     |     function log(address p0, bool p1, uint256 p2, address p3) internal pure {
 1437 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,address)", p0, p1, p2, p3));
 1438 |     |     }
 1439 |     | 
 1440 |     |     function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {
 1441 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint256)", p0, p1, p2, p3));
 1442 |     |     }
 1443 |     | 
 1444 |     |     function log(address p0, bool p1, string memory p2, string memory p3) internal pure {
 1445 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
 1446 |     |     }
 1447 |     | 
 1448 |     |     function log(address p0, bool p1, string memory p2, bool p3) internal pure {
 1449 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
 1450 |     |     }
 1451 |     | 
 1452 |     |     function log(address p0, bool p1, string memory p2, address p3) internal pure {
 1453 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
 1454 |     |     }
 1455 |     | 
 1456 |     |     function log(address p0, bool p1, bool p2, uint256 p3) internal pure {
 1457 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint256)", p0, p1, p2, p3));
 1458 |     |     }
 1459 |     | 
 1460 |     |     function log(address p0, bool p1, bool p2, string memory p3) internal pure {
 1461 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
 1462 |     |     }
 1463 |     | 
 1464 |     |     function log(address p0, bool p1, bool p2, bool p3) internal pure {
 1465 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
 1466 |     |     }
 1467 |     | 
 1468 |     |     function log(address p0, bool p1, bool p2, address p3) internal pure {
 1469 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
 1470 |     |     }
 1471 |     | 
 1472 |     |     function log(address p0, bool p1, address p2, uint256 p3) internal pure {
 1473 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint256)", p0, p1, p2, p3));
 1474 |     |     }
 1475 |     | 
 1476 |     |     function log(address p0, bool p1, address p2, string memory p3) internal pure {
 1477 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
 1478 |     |     }
 1479 |     | 
 1480 |     |     function log(address p0, bool p1, address p2, bool p3) internal pure {
 1481 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
 1482 |     |     }
 1483 |     | 
 1484 |     |     function log(address p0, bool p1, address p2, address p3) internal pure {
 1485 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
 1486 |     |     }
 1487 |     | 
 1488 |     |     function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {
 1489 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,uint256)", p0, p1, p2, p3));
 1490 |     |     }
 1491 |     | 
 1492 |     |     function log(address p0, address p1, uint256 p2, string memory p3) internal pure {
 1493 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,string)", p0, p1, p2, p3));
 1494 |     |     }
 1495 |     | 
 1496 |     |     function log(address p0, address p1, uint256 p2, bool p3) internal pure {
 1497 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,bool)", p0, p1, p2, p3));
 1498 |     |     }
 1499 |     | 
 1500 |     |     function log(address p0, address p1, uint256 p2, address p3) internal pure {
 1501 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,address)", p0, p1, p2, p3));
 1502 |     |     }
 1503 |     | 
 1504 |     |     function log(address p0, address p1, string memory p2, uint256 p3) internal pure {
 1505 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint256)", p0, p1, p2, p3));
 1506 |     |     }
 1507 |     | 
 1508 |     |     function log(address p0, address p1, string memory p2, string memory p3) internal pure {
 1509 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
 1510 |     |     }
 1511 |     | 
 1512 |     |     function log(address p0, address p1, string memory p2, bool p3) internal pure {
 1513 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
 1514 |     |     }
 1515 |     | 
 1516 |     |     function log(address p0, address p1, string memory p2, address p3) internal pure {
 1517 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
 1518 |     |     }
 1519 |     | 
 1520 |     |     function log(address p0, address p1, bool p2, uint256 p3) internal pure {
 1521 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint256)", p0, p1, p2, p3));
 1522 |     |     }
 1523 |     | 
 1524 |     |     function log(address p0, address p1, bool p2, string memory p3) internal pure {
 1525 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
 1526 |     |     }
 1527 |     | 
 1528 |     |     function log(address p0, address p1, bool p2, bool p3) internal pure {
 1529 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
 1530 |     |     }
 1531 |     | 
 1532 |     |     function log(address p0, address p1, bool p2, address p3) internal pure {
 1533 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
 1534 |     |     }
 1535 |     | 
 1536 |     |     function log(address p0, address p1, address p2, uint256 p3) internal pure {
 1537 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint256)", p0, p1, p2, p3));
 1538 |     |     }
 1539 |     | 
 1540 |     |     function log(address p0, address p1, address p2, string memory p3) internal pure {
 1541 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
 1542 |     |     }
 1543 |     | 
 1544 |     |     function log(address p0, address p1, address p2, bool p3) internal pure {
 1545 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
 1546 |     |     }
 1547 |     | 
 1548 |     |     function log(address p0, address p1, address p2, address p3) internal pure {
 1549 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
 1550 |     |     }
 1551 |     | 
 1552 |     | }
 1553 |     | 

