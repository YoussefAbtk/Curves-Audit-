<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/@crytic/properties/contracts/util/Hevm.sol</b>
<code>
  1 |     | <span class='unexecuted'>// SPDX-License-Identifier: Unlicense</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IHevm {</span>
  5 |     | <span class='neutral'>    // Set block.timestamp to newTimestamp</span>
  6 |     | <span class='neutral'>    function warp(uint256 newTimestamp) external;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    // Set block.number to newNumber</span>
  9 |     | <span class='neutral'>    function roll(uint256 newNumber) external;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    // Loads a storage slot from an address</span>
 12 |     | <span class='neutral'>    function load(address where, bytes32 slot) external returns (bytes32);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    // Stores a value to an address&#39; storage slot</span>
 15 |     | <span class='neutral'>    function store(address where, bytes32 slot, bytes32 value) external;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    // Signs data (privateKey, digest) =&gt; (r, v, s)</span>
 18 |     | <span class='neutral'>    function sign(</span>
 19 |     | <span class='neutral'>        uint256 privateKey,</span>
 20 |     | <span class='neutral'>        bytes32 digest</span>
 21 |     | <span class='neutral'>    ) external returns (uint8 r, bytes32 v, bytes32 s);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    // Gets address for a given private key</span>
 24 |     | <span class='neutral'>    function addr(uint256 privateKey) external returns (address addr);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    // Performs a foreign function call via terminal</span>
 27 |     | <span class='neutral'>    function ffi(</span>
 28 |     | <span class='neutral'>        string[] calldata inputs</span>
 29 |     | <span class='neutral'>    ) external returns (bytes memory result);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    // Performs the next smart contract call with specified `msg.sender`</span>
 32 |     | <span class='neutral'>    function prank(address newSender) external;</span>
 33 |     | <span class='neutral'>}</span>
 34 |     | <span class='neutral'></span>
 35 | *   | <span class='executed'>IHevm constant hevm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);</span>
 36 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/@crytic/properties/contracts/util/PropertiesConstants.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>abstract contract PropertiesConstants {</span>
  4 |     | <span class='neutral'>    // Constant echidna addresses</span>
  5 | *   | <span class='executed'>    address constant USER1 = address(0x10000);</span>
  6 | *   | <span class='executed'>    address constant USER2 = address(0x20000);</span>
  7 | *   | <span class='executed'>    address constant USER3 = address(0x30000);</span>
  8 |     | <span class='neutral'>    uint256 constant INITIAL_BALANCE = 1000e18;</span>
  9 |     | <span class='neutral'>}</span>
 10 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/@crytic/properties/contracts/util/PropertiesHelper.sol</b>
<code>
   1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>abstract contract PropertiesAsserts {</span>
   4 |     | <span class='neutral'>    event LogUint256(string, uint256);</span>
   5 |     | <span class='neutral'>    event LogAddress(string, address);</span>
   6 |     | <span class='neutral'>    event LogString(string);</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>    event AssertFail(string);</span>
   9 |     | <span class='neutral'>    event AssertEqFail(string);</span>
  10 |     | <span class='neutral'>    event AssertNeqFail(string);</span>
  11 |     | <span class='neutral'>    event AssertGteFail(string);</span>
  12 |     | <span class='neutral'>    event AssertGtFail(string);</span>
  13 |     | <span class='neutral'>    event AssertLteFail(string);</span>
  14 |     | <span class='neutral'>    event AssertLtFail(string);</span>
  15 |     | <span class='neutral'></span>
  16 | *   | <span class='executed'>    function assertWithMsg(bool b, string memory reason) internal {</span>
  17 | *   | <span class='executed'>        if (!b) {</span>
  18 | *   | <span class='executed'>            emit AssertFail(reason);</span>
  19 | *   | <span class='executed'>            assert(false);</span>
  20 |     | <span class='neutral'>        }</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /// @notice asserts that a is equal to b. Violations are logged using reason.</span>
  24 | *   | <span class='executed'>    function assertEq(uint256 a, uint256 b, string memory reason) internal {</span>
  25 | *   | <span class='executed'>        if (a != b) {</span>
  26 | *   | <span class='executed'>            string memory aStr = PropertiesLibString.toString(a);</span>
  27 | *   | <span class='executed'>            string memory bStr = PropertiesLibString.toString(b);</span>
  28 | *   | <span class='executed'>            bytes memory assertMsg = abi.encodePacked(</span>
  29 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
  30 | *   | <span class='executed'>                aStr,</span>
  31 |     | <span class='neutral'>                &quot;!=&quot;,</span>
  32 | *   | <span class='executed'>                bStr,</span>
  33 |     | <span class='neutral'>                &quot;, reason: &quot;,</span>
  34 | *   | <span class='executed'>                reason</span>
  35 |     | <span class='neutral'>            );</span>
  36 | *   | <span class='executed'>            emit AssertEqFail(string(assertMsg));</span>
  37 | *   | <span class='executed'>            assert(false);</span>
  38 |     | <span class='neutral'>        }</span>
  39 |     | <span class='neutral'>    }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /// @notice int256 version of assertEq</span>
  42 |     | <span class='neutral'>    function assertEq(int256 a, int256 b, string memory reason) internal {</span>
  43 |     | <span class='neutral'>        if (a != b) {</span>
  44 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
  45 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
  46 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
  47 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
  48 |     | <span class='neutral'>                aStr,</span>
  49 |     | <span class='neutral'>                &quot;!=&quot;,</span>
  50 |     | <span class='neutral'>                bStr,</span>
  51 |     | <span class='neutral'>                &quot;, reason: &quot;,</span>
  52 |     | <span class='neutral'>                reason</span>
  53 |     | <span class='neutral'>            );</span>
  54 |     | <span class='neutral'>            emit AssertEqFail(string(assertMsg));</span>
  55 |     | <span class='neutral'>            assert(false);</span>
  56 |     | <span class='neutral'>        }</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /// @notice asserts that a is not equal to b. Violations are logged using reason.</span>
  60 |     | <span class='neutral'>    function assertNeq(uint256 a, uint256 b, string memory reason) internal {</span>
  61 |     | <span class='neutral'>        if (a == b) {</span>
  62 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
  63 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
  64 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
  65 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
  66 |     | <span class='neutral'>                aStr,</span>
  67 |     | <span class='neutral'>                &quot;==&quot;,</span>
  68 |     | <span class='neutral'>                bStr,</span>
  69 |     | <span class='neutral'>                &quot;, reason: &quot;,</span>
  70 |     | <span class='neutral'>                reason</span>
  71 |     | <span class='neutral'>            );</span>
  72 |     | <span class='neutral'>            emit AssertNeqFail(string(assertMsg));</span>
  73 |     | <span class='neutral'>            assert(false);</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /// @notice int256 version of assertNeq</span>
  78 |     | <span class='neutral'>    function assertNeq(int256 a, int256 b, string memory reason) internal {</span>
  79 |     | <span class='neutral'>        if (a == b) {</span>
  80 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
  81 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
  82 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
  83 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
  84 |     | <span class='neutral'>                aStr,</span>
  85 |     | <span class='neutral'>                &quot;==&quot;,</span>
  86 |     | <span class='neutral'>                bStr,</span>
  87 |     | <span class='neutral'>                &quot;, reason: &quot;,</span>
  88 |     | <span class='neutral'>                reason</span>
  89 |     | <span class='neutral'>            );</span>
  90 |     | <span class='neutral'>            emit AssertNeqFail(string(assertMsg));</span>
  91 |     | <span class='neutral'>            assert(false);</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    /// @notice asserts that a is greater than or equal to b. Violations are logged using reason.</span>
  96 | *   | <span class='executed'>    function assertGte(uint256 a, uint256 b, string memory reason) internal {</span>
  97 | *   | <span class='executed'>        if (!(a &gt;= b)) {</span>
  98 |     | <span class='unexecuted'>            string memory aStr = PropertiesLibString.toString(a);</span>
  99 |     | <span class='unexecuted'>            string memory bStr = PropertiesLibString.toString(b);</span>
 100 |     | <span class='unexecuted'>            bytes memory assertMsg = abi.encodePacked(</span>
 101 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 102 |     | <span class='unexecuted'>                aStr,</span>
 103 |     | <span class='neutral'>                &quot;&lt;&quot;,</span>
 104 |     | <span class='unexecuted'>                bStr,</span>
 105 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 106 |     | <span class='unexecuted'>                reason</span>
 107 |     | <span class='neutral'>            );</span>
 108 |     | <span class='unexecuted'>            emit AssertGteFail(string(assertMsg));</span>
 109 |     | <span class='unexecuted'>            assert(false);</span>
 110 |     | <span class='neutral'>        }</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    /// @notice int256 version of assertGte</span>
 114 |     | <span class='neutral'>    function assertGte(int256 a, int256 b, string memory reason) internal {</span>
 115 |     | <span class='neutral'>        if (!(a &gt;= b)) {</span>
 116 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 117 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 118 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 119 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 120 |     | <span class='neutral'>                aStr,</span>
 121 |     | <span class='neutral'>                &quot;&lt;&quot;,</span>
 122 |     | <span class='neutral'>                bStr,</span>
 123 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 124 |     | <span class='neutral'>                reason</span>
 125 |     | <span class='neutral'>            );</span>
 126 |     | <span class='neutral'>            emit AssertGteFail(string(assertMsg));</span>
 127 |     | <span class='neutral'>            assert(false);</span>
 128 |     | <span class='neutral'>        }</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /// @notice asserts that a is greater than b. Violations are logged using reason.</span>
 132 | *   | <span class='executed'>    function assertGt(uint256 a, uint256 b, string memory reason) internal {</span>
 133 | *   | <span class='executed'>        if (!(a &gt; b)) {</span>
 134 |     | <span class='unexecuted'>            string memory aStr = PropertiesLibString.toString(a);</span>
 135 |     | <span class='unexecuted'>            string memory bStr = PropertiesLibString.toString(b);</span>
 136 |     | <span class='unexecuted'>            bytes memory assertMsg = abi.encodePacked(</span>
 137 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 138 |     | <span class='unexecuted'>                aStr,</span>
 139 |     | <span class='neutral'>                &quot;&lt;=&quot;,</span>
 140 |     | <span class='unexecuted'>                bStr,</span>
 141 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 142 |     | <span class='unexecuted'>                reason</span>
 143 |     | <span class='neutral'>            );</span>
 144 |     | <span class='unexecuted'>            emit AssertGtFail(string(assertMsg));</span>
 145 |     | <span class='unexecuted'>            assert(false);</span>
 146 |     | <span class='neutral'>        }</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /// @notice int256 version of assertGt</span>
 150 |     | <span class='neutral'>    function assertGt(int256 a, int256 b, string memory reason) internal {</span>
 151 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 152 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 153 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 154 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 155 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 156 |     | <span class='neutral'>                aStr,</span>
 157 |     | <span class='neutral'>                &quot;&lt;=&quot;,</span>
 158 |     | <span class='neutral'>                bStr,</span>
 159 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 160 |     | <span class='neutral'>                reason</span>
 161 |     | <span class='neutral'>            );</span>
 162 |     | <span class='neutral'>            emit AssertGtFail(string(assertMsg));</span>
 163 |     | <span class='neutral'>            assert(false);</span>
 164 |     | <span class='neutral'>        }</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    /// @notice asserts that a is less than or equal to b. Violations are logged using reason.</span>
 168 |     | <span class='neutral'>    function assertLte(uint256 a, uint256 b, string memory reason) internal {</span>
 169 |     | <span class='neutral'>        if (!(a &lt;= b)) {</span>
 170 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 171 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 172 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 173 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 174 |     | <span class='neutral'>                aStr,</span>
 175 |     | <span class='neutral'>                &quot;&gt;&quot;,</span>
 176 |     | <span class='neutral'>                bStr,</span>
 177 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 178 |     | <span class='neutral'>                reason</span>
 179 |     | <span class='neutral'>            );</span>
 180 |     | <span class='neutral'>            emit AssertLteFail(string(assertMsg));</span>
 181 |     | <span class='neutral'>            assert(false);</span>
 182 |     | <span class='neutral'>        }</span>
 183 |     | <span class='neutral'>    }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>    /// @notice int256 version of assertLte</span>
 186 |     | <span class='neutral'>    function assertLte(int256 a, int256 b, string memory reason) internal {</span>
 187 |     | <span class='neutral'>        if (!(a &lt;= b)) {</span>
 188 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 189 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 190 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 191 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 192 |     | <span class='neutral'>                aStr,</span>
 193 |     | <span class='neutral'>                &quot;&gt;&quot;,</span>
 194 |     | <span class='neutral'>                bStr,</span>
 195 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 196 |     | <span class='neutral'>                reason</span>
 197 |     | <span class='neutral'>            );</span>
 198 |     | <span class='neutral'>            emit AssertLteFail(string(assertMsg));</span>
 199 |     | <span class='neutral'>            assert(false);</span>
 200 |     | <span class='neutral'>        }</span>
 201 |     | <span class='neutral'>    }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>    /// @notice asserts that a is less than b. Violations are logged using reason.</span>
 204 | *   | <span class='executed'>    function assertLt(uint256 a, uint256 b, string memory reason) internal {</span>
 205 | *   | <span class='executed'>        if (!(a &lt; b)) {</span>
 206 |     | <span class='unexecuted'>            string memory aStr = PropertiesLibString.toString(a);</span>
 207 |     | <span class='unexecuted'>            string memory bStr = PropertiesLibString.toString(b);</span>
 208 |     | <span class='unexecuted'>            bytes memory assertMsg = abi.encodePacked(</span>
 209 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 210 |     | <span class='unexecuted'>                aStr,</span>
 211 |     | <span class='neutral'>                &quot;&gt;=&quot;,</span>
 212 |     | <span class='unexecuted'>                bStr,</span>
 213 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 214 |     | <span class='unexecuted'>                reason</span>
 215 |     | <span class='neutral'>            );</span>
 216 |     | <span class='unexecuted'>            emit AssertLtFail(string(assertMsg));</span>
 217 |     | <span class='unexecuted'>            assert(false);</span>
 218 |     | <span class='neutral'>        }</span>
 219 |     | <span class='neutral'>    }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>    /// @notice int256 version of assertLt</span>
 222 |     | <span class='neutral'>    function assertLt(int256 a, int256 b, string memory reason) internal {</span>
 223 |     | <span class='neutral'>        if (!(a &lt; b)) {</span>
 224 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 225 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 226 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 227 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 228 |     | <span class='neutral'>                aStr,</span>
 229 |     | <span class='neutral'>                &quot;&gt;=&quot;,</span>
 230 |     | <span class='neutral'>                bStr,</span>
 231 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 232 |     | <span class='neutral'>                reason</span>
 233 |     | <span class='neutral'>            );</span>
 234 |     | <span class='neutral'>            emit AssertLtFail(string(assertMsg));</span>
 235 |     | <span class='neutral'>            assert(false);</span>
 236 |     | <span class='neutral'>        }</span>
 237 |     | <span class='neutral'>    }</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='neutral'>    /// @notice Clamps value to be between low and high, both inclusive</span>
 240 | *   | <span class='executed'>    function clampBetween(</span>
 241 |     | <span class='neutral'>        uint256 value,</span>
 242 |     | <span class='neutral'>        uint256 low,</span>
 243 |     | <span class='neutral'>        uint256 high</span>
 244 | *   | <span class='executed'>    ) internal returns (uint256) {</span>
 245 | *   | <span class='executed'>        if (value &lt; low || value &gt; high) {</span>
 246 | *   | <span class='executed'>            uint ans = low + (value % (high - low + 1));</span>
 247 | *   | <span class='executed'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 248 | *   | <span class='executed'>            string memory ansStr = PropertiesLibString.toString(ans);</span>
 249 | *   | <span class='executed'>            bytes memory message = abi.encodePacked(</span>
 250 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 251 | *   | <span class='executed'>                valueStr,</span>
 252 |     | <span class='neutral'>                &quot; to &quot;,</span>
 253 | *   | <span class='executed'>                ansStr</span>
 254 |     | <span class='neutral'>            );</span>
 255 | *   | <span class='executed'>            emit LogString(string(message));</span>
 256 | *   | <span class='executed'>            return ans;</span>
 257 |     | <span class='neutral'>        }</span>
 258 | *   | <span class='executed'>        return value;</span>
 259 |     | <span class='neutral'>    }</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='neutral'>    /// @notice int256 version of clampBetween</span>
 262 |     | <span class='neutral'>    function clampBetween(</span>
 263 |     | <span class='neutral'>        int256 value,</span>
 264 |     | <span class='neutral'>        int256 low,</span>
 265 |     | <span class='neutral'>        int256 high</span>
 266 |     | <span class='neutral'>    ) internal returns (int256) {</span>
 267 |     | <span class='neutral'>        if (value &lt; low || value &gt; high) {</span>
 268 |     | <span class='neutral'>            int range = high - low + 1;</span>
 269 |     | <span class='neutral'>            int clamped = (value - low) % (range);</span>
 270 |     | <span class='neutral'>            if (clamped &lt; 0) clamped += range;</span>
 271 |     | <span class='neutral'>            int ans = low + clamped;</span>
 272 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 273 |     | <span class='neutral'>            string memory ansStr = PropertiesLibString.toString(ans);</span>
 274 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 275 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 276 |     | <span class='neutral'>                valueStr,</span>
 277 |     | <span class='neutral'>                &quot; to &quot;,</span>
 278 |     | <span class='neutral'>                ansStr</span>
 279 |     | <span class='neutral'>            );</span>
 280 |     | <span class='neutral'>            emit LogString(string(message));</span>
 281 |     | <span class='neutral'>            return ans;</span>
 282 |     | <span class='neutral'>        }</span>
 283 |     | <span class='neutral'>        return value;</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='neutral'>    /// @notice clamps a to be less than b</span>
 287 |     | <span class='neutral'>    function clampLt(uint256 a, uint256 b) internal returns (uint256) {</span>
 288 |     | <span class='neutral'>        if (!(a &lt; b)) {</span>
 289 |     | <span class='neutral'>            assertNeq(</span>
 290 |     | <span class='neutral'>                b,</span>
 291 |     | <span class='neutral'>                0,</span>
 292 |     | <span class='neutral'>                &quot;clampLt cannot clamp value a to be less than zero. Check your inputs/assumptions.&quot;</span>
 293 |     | <span class='neutral'>            );</span>
 294 |     | <span class='neutral'>            uint256 value = a % b;</span>
 295 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 296 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 297 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 298 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 299 |     | <span class='neutral'>                aStr,</span>
 300 |     | <span class='neutral'>                &quot; to &quot;,</span>
 301 |     | <span class='neutral'>                valueStr</span>
 302 |     | <span class='neutral'>            );</span>
 303 |     | <span class='neutral'>            emit LogString(string(message));</span>
 304 |     | <span class='neutral'>            return value;</span>
 305 |     | <span class='neutral'>        }</span>
 306 |     | <span class='neutral'>        return a;</span>
 307 |     | <span class='neutral'>    }</span>
 308 |     | <span class='neutral'></span>
 309 |     | <span class='neutral'>    /// @notice int256 version of clampLt</span>
 310 |     | <span class='neutral'>    function clampLt(int256 a, int256 b) internal returns (int256) {</span>
 311 |     | <span class='neutral'>        if (!(a &lt; b)) {</span>
 312 |     | <span class='neutral'>            int256 value = b - 1;</span>
 313 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 314 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 315 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 316 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 317 |     | <span class='neutral'>                aStr,</span>
 318 |     | <span class='neutral'>                &quot; to &quot;,</span>
 319 |     | <span class='neutral'>                valueStr</span>
 320 |     | <span class='neutral'>            );</span>
 321 |     | <span class='neutral'>            emit LogString(string(message));</span>
 322 |     | <span class='neutral'>            return value;</span>
 323 |     | <span class='neutral'>        }</span>
 324 |     | <span class='neutral'>        return a;</span>
 325 |     | <span class='neutral'>    }</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='neutral'>    /// @notice clamps a to be less than or equal to b</span>
 328 |     | <span class='neutral'>    function clampLte(uint256 a, uint256 b) internal returns (uint256) {</span>
 329 |     | <span class='neutral'>        if (!(a &lt;= b)) {</span>
 330 |     | <span class='neutral'>            uint256 value = a % (b + 1);</span>
 331 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 332 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 333 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 334 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 335 |     | <span class='neutral'>                aStr,</span>
 336 |     | <span class='neutral'>                &quot; to &quot;,</span>
 337 |     | <span class='neutral'>                valueStr</span>
 338 |     | <span class='neutral'>            );</span>
 339 |     | <span class='neutral'>            emit LogString(string(message));</span>
 340 |     | <span class='neutral'>            return value;</span>
 341 |     | <span class='neutral'>        }</span>
 342 |     | <span class='neutral'>        return a;</span>
 343 |     | <span class='neutral'>    }</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>    /// @notice int256 version of clampLte</span>
 346 |     | <span class='neutral'>    function clampLte(int256 a, int256 b) internal returns (int256) {</span>
 347 |     | <span class='neutral'>        if (!(a &lt;= b)) {</span>
 348 |     | <span class='neutral'>            int256 value = b;</span>
 349 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 350 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 351 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 352 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 353 |     | <span class='neutral'>                aStr,</span>
 354 |     | <span class='neutral'>                &quot; to &quot;,</span>
 355 |     | <span class='neutral'>                valueStr</span>
 356 |     | <span class='neutral'>            );</span>
 357 |     | <span class='neutral'>            emit LogString(string(message));</span>
 358 |     | <span class='neutral'>            return value;</span>
 359 |     | <span class='neutral'>        }</span>
 360 |     | <span class='neutral'>        return a;</span>
 361 |     | <span class='neutral'>    }</span>
 362 |     | <span class='neutral'></span>
 363 |     | <span class='neutral'>    /// @notice clamps a to be greater than b</span>
 364 |     | <span class='neutral'>    function clampGt(uint256 a, uint256 b) internal returns (uint256) {</span>
 365 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 366 |     | <span class='neutral'>            assertNeq(</span>
 367 |     | <span class='neutral'>                b,</span>
 368 |     | <span class='neutral'>                type(uint256).max,</span>
 369 |     | <span class='neutral'>                &quot;clampGt cannot clamp value a to be larger than uint256.max. Check your inputs/assumptions.&quot;</span>
 370 |     | <span class='neutral'>            );</span>
 371 |     | <span class='neutral'>            uint256 value = b + 1;</span>
 372 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 373 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 374 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 375 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 376 |     | <span class='neutral'>                aStr,</span>
 377 |     | <span class='neutral'>                &quot; to &quot;,</span>
 378 |     | <span class='neutral'>                valueStr</span>
 379 |     | <span class='neutral'>            );</span>
 380 |     | <span class='neutral'>            emit LogString(string(message));</span>
 381 |     | <span class='neutral'>            return value;</span>
 382 |     | <span class='neutral'>        } else {</span>
 383 |     | <span class='neutral'>            return a;</span>
 384 |     | <span class='neutral'>        }</span>
 385 |     | <span class='neutral'>    }</span>
 386 |     | <span class='neutral'></span>
 387 |     | <span class='neutral'>    /// @notice int256 version of clampGt</span>
 388 |     | <span class='neutral'>    function clampGt(int256 a, int256 b) internal returns (int256) {</span>
 389 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 390 |     | <span class='neutral'>            int256 value = b + 1;</span>
 391 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 392 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 393 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 394 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 395 |     | <span class='neutral'>                aStr,</span>
 396 |     | <span class='neutral'>                &quot; to &quot;,</span>
 397 |     | <span class='neutral'>                valueStr</span>
 398 |     | <span class='neutral'>            );</span>
 399 |     | <span class='neutral'>            emit LogString(string(message));</span>
 400 |     | <span class='neutral'>            return value;</span>
 401 |     | <span class='neutral'>        } else {</span>
 402 |     | <span class='neutral'>            return a;</span>
 403 |     | <span class='neutral'>        }</span>
 404 |     | <span class='neutral'>    }</span>
 405 |     | <span class='neutral'></span>
 406 |     | <span class='neutral'>    /// @notice clamps a to be greater than or equal to b</span>
 407 |     | <span class='neutral'>    function clampGte(uint256 a, uint256 b) internal returns (uint256) {</span>
 408 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 409 |     | <span class='neutral'>            uint256 value = b;</span>
 410 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 411 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 412 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 413 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 414 |     | <span class='neutral'>                aStr,</span>
 415 |     | <span class='neutral'>                &quot; to &quot;,</span>
 416 |     | <span class='neutral'>                valueStr</span>
 417 |     | <span class='neutral'>            );</span>
 418 |     | <span class='neutral'>            emit LogString(string(message));</span>
 419 |     | <span class='neutral'>            return value;</span>
 420 |     | <span class='neutral'>        }</span>
 421 |     | <span class='neutral'>        return a;</span>
 422 |     | <span class='neutral'>    }</span>
 423 |     | <span class='neutral'></span>
 424 |     | <span class='neutral'>    /// @notice int256 version of clampGte</span>
 425 |     | <span class='neutral'>    function clampGte(int256 a, int256 b) internal returns (int256) {</span>
 426 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 427 |     | <span class='neutral'>            int256 value = b;</span>
 428 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 429 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 430 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 431 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 432 |     | <span class='neutral'>                aStr,</span>
 433 |     | <span class='neutral'>                &quot; to &quot;,</span>
 434 |     | <span class='neutral'>                valueStr</span>
 435 |     | <span class='neutral'>            );</span>
 436 |     | <span class='neutral'>            emit LogString(string(message));</span>
 437 |     | <span class='neutral'>            return value;</span>
 438 |     | <span class='neutral'>        }</span>
 439 |     | <span class='neutral'>        return a;</span>
 440 |     | <span class='neutral'>    }</span>
 441 |     | <span class='neutral'>}</span>
 442 |     | <span class='neutral'></span>
 443 |     | <span class='neutral'>/// @notice Efficient library for creating string representations of integers.</span>
 444 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)</span>
 445 |     | <span class='neutral'>/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)</span>
 446 |     | <span class='neutral'>/// @dev Name of the library is modified to prevent collisions with contract-under-test uses of LibString</span>
 447 |     | <span class='unexecuted'>library PropertiesLibString {</span>
 448 |     | <span class='neutral'>    function toString(int256 value) internal pure returns (string memory str) {</span>
 449 |     | <span class='neutral'>        uint256 absValue = value &gt;= 0 ? uint256(value) : uint256(-value);</span>
 450 |     | <span class='neutral'>        str = toString(absValue);</span>
 451 |     | <span class='neutral'></span>
 452 |     | <span class='neutral'>        if (value &lt; 0) {</span>
 453 |     | <span class='neutral'>            str = string(abi.encodePacked(&quot;-&quot;, str));</span>
 454 |     | <span class='neutral'>        }</span>
 455 |     | <span class='neutral'>    }</span>
 456 |     | <span class='neutral'></span>
 457 | *   | <span class='executed'>    function toString(uint256 value) internal pure returns (string memory str) {</span>
 458 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 459 | *   | <span class='executed'>        assembly {</span>
 460 |     | <span class='neutral'>            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes</span>
 461 |     | <span class='neutral'>            // to keep the free memory pointer word aligned. We&#39;ll need 1 word for the length, 1 word for the</span>
 462 |     | <span class='neutral'>            // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.</span>
 463 | *   | <span class='executed'>            let newFreeMemoryPointer := add(mload(0x40), 160)</span>
 464 |     | <span class='neutral'></span>
 465 |     | <span class='neutral'>            // Update the free memory pointer to avoid overriding our string.</span>
 466 | *   | <span class='executed'>            mstore(0x40, newFreeMemoryPointer)</span>
 467 |     | <span class='neutral'></span>
 468 |     | <span class='neutral'>            // Assign str to the end of the zone of newly allocated memory.</span>
 469 | *   | <span class='executed'>            str := sub(newFreeMemoryPointer, 32)</span>
 470 |     | <span class='neutral'></span>
 471 |     | <span class='neutral'>            // Clean the last word of memory it may not be overwritten.</span>
 472 | *   | <span class='executed'>            mstore(str, 0)</span>
 473 |     | <span class='neutral'></span>
 474 |     | <span class='neutral'>            // Cache the end of the memory to calculate the length later.</span>
 475 | *   | <span class='executed'>            let end := str</span>
 476 |     | <span class='neutral'></span>
 477 |     | <span class='neutral'>            // We write the string from rightmost digit to leftmost digit.</span>
 478 |     | <span class='neutral'>            // The following is essentially a do-while loop that also handles the zero case.</span>
 479 |     | <span class='neutral'>            // prettier-ignore</span>
 480 | *   | <span class='executed'>            for { let temp := value } 1 {} {</span>
 481 |     | <span class='neutral'>                // Move the pointer 1 byte to the left.</span>
 482 | *   | <span class='executed'>                str := sub(str, 1)</span>
 483 |     | <span class='neutral'></span>
 484 |     | <span class='neutral'>                // Write the character to the pointer.</span>
 485 |     | <span class='neutral'>                // The ASCII index of the &#39;0&#39; character is 48.</span>
 486 | *   | <span class='executed'>                mstore8(str, add(48, mod(temp, 10)))</span>
 487 |     | <span class='neutral'></span>
 488 |     | <span class='neutral'>                // Keep dividing temp until zero.</span>
 489 | *   | <span class='executed'>                temp := div(temp, 10)</span>
 490 |     | <span class='neutral'></span>
 491 |     | <span class='neutral'>                 // prettier-ignore</span>
 492 | *   | <span class='executed'>                if iszero(temp) { break }</span>
 493 |     | <span class='neutral'>            }</span>
 494 |     | <span class='neutral'></span>
 495 |     | <span class='neutral'>            // Compute and cache the final total length of the string.</span>
 496 | *   | <span class='executed'>            let length := sub(end, str)</span>
 497 |     | <span class='neutral'></span>
 498 |     | <span class='neutral'>            // Move the pointer 32 bytes leftwards to make room for the length.</span>
 499 | *   | <span class='executed'>            str := sub(str, 32)</span>
 500 |     | <span class='neutral'></span>
 501 |     | <span class='neutral'>            // Store the string&#39;s length at the start of memory allocated for our string.</span>
 502 | *   | <span class='executed'>            mstore(str, length)</span>
 503 |     | <span class='neutral'>        }</span>
 504 |     | <span class='neutral'>    }</span>
 505 |     | <span class='neutral'></span>
 506 |     | <span class='neutral'>    function toString(address value) internal pure returns (string memory str) {</span>
 507 |     | <span class='neutral'>        bytes memory s = new bytes(40);</span>
 508 |     | <span class='neutral'>        for (uint i = 0; i &lt; 20; i++) {</span>
 509 |     | <span class='neutral'>            bytes1 b = bytes1(</span>
 510 |     | <span class='neutral'>                uint8(uint(uint160(value)) / (2 ** (8 * (19 - i))))</span>
 511 |     | <span class='neutral'>            );</span>
 512 |     | <span class='neutral'>            bytes1 hi = bytes1(uint8(b) / 16);</span>
 513 |     | <span class='neutral'>            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));</span>
 514 |     | <span class='neutral'>            s[2 * i] = char(hi);</span>
 515 |     | <span class='neutral'>            s[2 * i + 1] = char(lo);</span>
 516 |     | <span class='neutral'>        }</span>
 517 |     | <span class='neutral'>        return string(s);</span>
 518 |     | <span class='neutral'>    }</span>
 519 |     | <span class='neutral'></span>
 520 |     | <span class='neutral'>    function char(bytes1 b) internal pure returns (bytes1 c) {</span>
 521 |     | <span class='neutral'>        if (uint8(b) &lt; 10) return bytes1(uint8(b) + 0x30);</span>
 522 |     | <span class='neutral'>        else return bytes1(uint8(b) + 0x57);</span>
 523 |     | <span class='neutral'>    }</span>
 524 |     | <span class='neutral'>}</span>
 525 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/@openzeppelin/contracts/access/Ownable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../utils/Context.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Contract module which provides a basic access control mechanism, where</span>
 10 |     | <span class='neutral'> * there is an account (an owner) that can be granted exclusive access to</span>
 11 |     | <span class='neutral'> * specific functions.</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * By default, the owner account will be the one that deploys the contract. This</span>
 14 |     | <span class='neutral'> * can later be changed with {transferOwnership}.</span>
 15 |     | <span class='neutral'> *</span>
 16 |     | <span class='neutral'> * This module is used through inheritance. It will make available the modifier</span>
 17 |     | <span class='neutral'> * `onlyOwner`, which can be applied to your functions to restrict their use to</span>
 18 |     | <span class='neutral'> * the owner.</span>
 19 |     | <span class='neutral'> */</span>
 20 |     | <span class='neutral'>abstract contract Ownable is Context {</span>
 21 |     | <span class='neutral'>    address private _owner;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    /**</span>
 26 |     | <span class='neutral'>     * @dev Initializes the contract setting the deployer as the initial owner.</span>
 27 |     | <span class='neutral'>     */</span>
 28 |     | <span class='neutral'>    constructor() {</span>
 29 |     | <span class='unexecuted'>        _transferOwnership(_msgSender());</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    /**</span>
 33 |     | <span class='neutral'>     * @dev Throws if called by any account other than the owner.</span>
 34 |     | <span class='neutral'>     */</span>
 35 |     | <span class='neutral'>    modifier onlyOwner() {</span>
 36 | *   | <span class='executed'>        _checkOwner();</span>
 37 |     | <span class='neutral'>        _;</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    /**</span>
 41 |     | <span class='neutral'>     * @dev Returns the address of the current owner.</span>
 42 |     | <span class='neutral'>     */</span>
 43 | *   | <span class='executed'>    function owner() public view virtual returns (address) {</span>
 44 | *   | <span class='executed'>        return _owner;</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    /**</span>
 48 |     | <span class='neutral'>     * @dev Throws if the sender is not the owner.</span>
 49 |     | <span class='neutral'>     */</span>
 50 | *   | <span class='executed'>    function _checkOwner() internal view virtual {</span>
 51 | *   | <span class='executed'>        require(owner() == _msgSender(), &quot;Ownable: caller is not the owner&quot;);</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    /**</span>
 55 |     | <span class='neutral'>     * @dev Leaves the contract without owner. It will not be possible to call</span>
 56 |     | <span class='neutral'>     * `onlyOwner` functions. Can only be called by the current owner.</span>
 57 |     | <span class='neutral'>     *</span>
 58 |     | <span class='neutral'>     * NOTE: Renouncing ownership will leave the contract without an owner,</span>
 59 |     | <span class='neutral'>     * thereby disabling any functionality that is only available to the owner.</span>
 60 |     | <span class='neutral'>     */</span>
 61 |     | <span class='unexecuted'>    function renounceOwnership() public virtual onlyOwner {</span>
 62 |     | <span class='unexecuted'>        _transferOwnership(address(0));</span>
 63 |     | <span class='neutral'>    }</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='neutral'>    /**</span>
 66 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
 67 |     | <span class='neutral'>     * Can only be called by the current owner.</span>
 68 |     | <span class='neutral'>     */</span>
 69 |     | <span class='unexecuted'>    function transferOwnership(address newOwner) public virtual onlyOwner {</span>
 70 |     | <span class='unexecuted'>        require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);</span>
 71 |     | <span class='unexecuted'>        _transferOwnership(newOwner);</span>
 72 |     | <span class='neutral'>    }</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='neutral'>    /**</span>
 75 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
 76 |     | <span class='neutral'>     * Internal function without access restriction.</span>
 77 |     | <span class='neutral'>     */</span>
 78 |     | <span class='unexecuted'>    function _transferOwnership(address newOwner) internal virtual {</span>
 79 |     | <span class='unexecuted'>        address oldOwner = _owner;</span>
 80 |     | <span class='unexecuted'>        _owner = newOwner;</span>
 81 |     | <span class='unexecuted'>        emit OwnershipTransferred(oldOwner, newOwner);</span>
 82 |     | <span class='neutral'>    }</span>
 83 |     | <span class='neutral'>}</span>
 84 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./extensions/IERC20Metadata.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../utils/Context.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev Implementation of the {IERC20} interface.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * This implementation is agnostic to the way tokens are created. This means</span>
  14 |     | <span class='neutral'> * that a supply mechanism has to be added in a derived contract using {_mint}.</span>
  15 |     | <span class='neutral'> * For a generic mechanism see {ERC20PresetMinterPauser}.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * TIP: For a detailed writeup see our guide</span>
  18 |     | <span class='neutral'> * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How</span>
  19 |     | <span class='neutral'> * to implement supply mechanisms].</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * The default value of {decimals} is 18. To change this, you should override</span>
  22 |     | <span class='neutral'> * this function so it returns a different value.</span>
  23 |     | <span class='neutral'> *</span>
  24 |     | <span class='neutral'> * We have followed general OpenZeppelin Contracts guidelines: functions revert</span>
  25 |     | <span class='neutral'> * instead returning `false` on failure. This behavior is nonetheless</span>
  26 |     | <span class='neutral'> * conventional and does not conflict with the expectations of ERC20</span>
  27 |     | <span class='neutral'> * applications.</span>
  28 |     | <span class='neutral'> *</span>
  29 |     | <span class='neutral'> * Additionally, an {Approval} event is emitted on calls to {transferFrom}.</span>
  30 |     | <span class='neutral'> * This allows applications to reconstruct the allowance for all accounts just</span>
  31 |     | <span class='neutral'> * by listening to said events. Other implementations of the EIP may not emit</span>
  32 |     | <span class='neutral'> * these events, as it isn&#39;t required by the specification.</span>
  33 |     | <span class='neutral'> *</span>
  34 |     | <span class='neutral'> * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}</span>
  35 |     | <span class='neutral'> * functions have been added to mitigate the well-known issues around setting</span>
  36 |     | <span class='neutral'> * allowances. See {IERC20-approve}.</span>
  37 |     | <span class='neutral'> */</span>
  38 |     | <span class='unexecuted'>contract ERC20 is Context, IERC20, IERC20Metadata {</span>
  39 |     | <span class='neutral'>    mapping(address =&gt; uint256) private _balances;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    uint256 private _totalSupply;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    string private _name;</span>
  46 |     | <span class='neutral'>    string private _symbol;</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @dev Sets the values for {name} and {symbol}.</span>
  50 |     | <span class='neutral'>     *</span>
  51 |     | <span class='neutral'>     * All two of these values are immutable: they can only be set once during</span>
  52 |     | <span class='neutral'>     * construction.</span>
  53 |     | <span class='neutral'>     */</span>
  54 |     | <span class='unexecuted'>    constructor(string memory name_, string memory symbol_) {</span>
  55 |     | <span class='unexecuted'>        _name = name_;</span>
  56 |     | <span class='unexecuted'>        _symbol = symbol_;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
  61 |     | <span class='neutral'>     */</span>
  62 |     | <span class='unexecuted'>    function name() public view virtual override returns (string memory) {</span>
  63 |     | <span class='unexecuted'>        return _name;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /**</span>
  67 |     | <span class='neutral'>     * @dev Returns the symbol of the token, usually a shorter version of the</span>
  68 |     | <span class='neutral'>     * name.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='unexecuted'>    function symbol() public view virtual override returns (string memory) {</span>
  71 |     | <span class='unexecuted'>        return _symbol;</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @dev Returns the number of decimals used to get its user representation.</span>
  76 |     | <span class='neutral'>     * For example, if `decimals` equals `2`, a balance of `505` tokens should</span>
  77 |     | <span class='neutral'>     * be displayed to a user as `5.05` (`505 / 10 ** 2`).</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Tokens usually opt for a value of 18, imitating the relationship between</span>
  80 |     | <span class='neutral'>     * Ether and Wei. This is the default value returned by this function, unless</span>
  81 |     | <span class='neutral'>     * it&#39;s overridden.</span>
  82 |     | <span class='neutral'>     *</span>
  83 |     | <span class='neutral'>     * NOTE: This information is only used for _display_ purposes: it in</span>
  84 |     | <span class='neutral'>     * no way affects any of the arithmetic of the contract, including</span>
  85 |     | <span class='neutral'>     * {IERC20-balanceOf} and {IERC20-transfer}.</span>
  86 |     | <span class='neutral'>     */</span>
  87 |     | <span class='unexecuted'>    function decimals() public view virtual override returns (uint8) {</span>
  88 |     | <span class='unexecuted'>        return 18;</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev See {IERC20-totalSupply}.</span>
  93 |     | <span class='neutral'>     */</span>
  94 |     | <span class='unexecuted'>    function totalSupply() public view virtual override returns (uint256) {</span>
  95 |     | <span class='unexecuted'>        return _totalSupply;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /**</span>
  99 |     | <span class='neutral'>     * @dev See {IERC20-balanceOf}.</span>
 100 |     | <span class='neutral'>     */</span>
 101 | *   | <span class='executed'>    function balanceOf(address account) public view virtual override returns (uint256) {</span>
 102 | *   | <span class='executed'>        return _balances[account];</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    /**</span>
 106 |     | <span class='neutral'>     * @dev See {IERC20-transfer}.</span>
 107 |     | <span class='neutral'>     *</span>
 108 |     | <span class='neutral'>     * Requirements:</span>
 109 |     | <span class='neutral'>     *</span>
 110 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 111 |     | <span class='neutral'>     * - the caller must have a balance of at least `amount`.</span>
 112 |     | <span class='neutral'>     */</span>
 113 |     | <span class='unexecuted'>    function transfer(address to, uint256 amount) public virtual override returns (bool) {</span>
 114 |     | <span class='unexecuted'>        address owner = _msgSender();</span>
 115 |     | <span class='unexecuted'>        _transfer(owner, to, amount);</span>
 116 |     | <span class='unexecuted'>        return true;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /**</span>
 120 |     | <span class='neutral'>     * @dev See {IERC20-allowance}.</span>
 121 |     | <span class='neutral'>     */</span>
 122 |     | <span class='unexecuted'>    function allowance(address owner, address spender) public view virtual override returns (uint256) {</span>
 123 |     | <span class='unexecuted'>        return _allowances[owner][spender];</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev See {IERC20-approve}.</span>
 128 |     | <span class='neutral'>     *</span>
 129 |     | <span class='neutral'>     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on</span>
 130 |     | <span class='neutral'>     * `transferFrom`. This is semantically equivalent to an infinite approval.</span>
 131 |     | <span class='neutral'>     *</span>
 132 |     | <span class='neutral'>     * Requirements:</span>
 133 |     | <span class='neutral'>     *</span>
 134 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 135 |     | <span class='neutral'>     */</span>
 136 |     | <span class='unexecuted'>    function approve(address spender, uint256 amount) public virtual override returns (bool) {</span>
 137 |     | <span class='unexecuted'>        address owner = _msgSender();</span>
 138 |     | <span class='unexecuted'>        _approve(owner, spender, amount);</span>
 139 |     | <span class='unexecuted'>        return true;</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /**</span>
 143 |     | <span class='neutral'>     * @dev See {IERC20-transferFrom}.</span>
 144 |     | <span class='neutral'>     *</span>
 145 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance. This is not</span>
 146 |     | <span class='neutral'>     * required by the EIP. See the note at the beginning of {ERC20}.</span>
 147 |     | <span class='neutral'>     *</span>
 148 |     | <span class='neutral'>     * NOTE: Does not update the allowance if the current allowance</span>
 149 |     | <span class='neutral'>     * is the maximum `uint256`.</span>
 150 |     | <span class='neutral'>     *</span>
 151 |     | <span class='neutral'>     * Requirements:</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * - `from` and `to` cannot be the zero address.</span>
 154 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 155 |     | <span class='neutral'>     * - the caller must have allowance for ``from``&#39;s tokens of at least</span>
 156 |     | <span class='neutral'>     * `amount`.</span>
 157 |     | <span class='neutral'>     */</span>
 158 |     | <span class='unexecuted'>    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {</span>
 159 |     | <span class='unexecuted'>        address spender = _msgSender();</span>
 160 |     | <span class='unexecuted'>        _spendAllowance(from, spender, amount);</span>
 161 |     | <span class='unexecuted'>        _transfer(from, to, amount);</span>
 162 |     | <span class='unexecuted'>        return true;</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    /**</span>
 166 |     | <span class='neutral'>     * @dev Atomically increases the allowance granted to `spender` by the caller.</span>
 167 |     | <span class='neutral'>     *</span>
 168 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 169 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 170 |     | <span class='neutral'>     *</span>
 171 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 172 |     | <span class='neutral'>     *</span>
 173 |     | <span class='neutral'>     * Requirements:</span>
 174 |     | <span class='neutral'>     *</span>
 175 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 176 |     | <span class='neutral'>     */</span>
 177 |     | <span class='unexecuted'>    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {</span>
 178 |     | <span class='unexecuted'>        address owner = _msgSender();</span>
 179 |     | <span class='unexecuted'>        _approve(owner, spender, allowance(owner, spender) + addedValue);</span>
 180 |     | <span class='unexecuted'>        return true;</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    /**</span>
 184 |     | <span class='neutral'>     * @dev Atomically decreases the allowance granted to `spender` by the caller.</span>
 185 |     | <span class='neutral'>     *</span>
 186 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 187 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 188 |     | <span class='neutral'>     *</span>
 189 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 190 |     | <span class='neutral'>     *</span>
 191 |     | <span class='neutral'>     * Requirements:</span>
 192 |     | <span class='neutral'>     *</span>
 193 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 194 |     | <span class='neutral'>     * - `spender` must have allowance for the caller of at least</span>
 195 |     | <span class='neutral'>     * `subtractedValue`.</span>
 196 |     | <span class='neutral'>     */</span>
 197 |     | <span class='unexecuted'>    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {</span>
 198 |     | <span class='unexecuted'>        address owner = _msgSender();</span>
 199 |     | <span class='unexecuted'>        uint256 currentAllowance = allowance(owner, spender);</span>
 200 |     | <span class='unexecuted'>        require(currentAllowance &gt;= subtractedValue, &quot;ERC20: decreased allowance below zero&quot;);</span>
 201 |     | <span class='neutral'>        unchecked {</span>
 202 |     | <span class='unexecuted'>            _approve(owner, spender, currentAllowance - subtractedValue);</span>
 203 |     | <span class='neutral'>        }</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='unexecuted'>        return true;</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    /**</span>
 209 |     | <span class='neutral'>     * @dev Moves `amount` of tokens from `from` to `to`.</span>
 210 |     | <span class='neutral'>     *</span>
 211 |     | <span class='neutral'>     * This internal function is equivalent to {transfer}, and can be used to</span>
 212 |     | <span class='neutral'>     * e.g. implement automatic token fees, slashing mechanisms, etc.</span>
 213 |     | <span class='neutral'>     *</span>
 214 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 215 |     | <span class='neutral'>     *</span>
 216 |     | <span class='neutral'>     * Requirements:</span>
 217 |     | <span class='neutral'>     *</span>
 218 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
 219 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 220 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 221 |     | <span class='neutral'>     */</span>
 222 |     | <span class='unexecuted'>    function _transfer(address from, address to, uint256 amount) internal virtual {</span>
 223 |     | <span class='unexecuted'>        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);</span>
 224 |     | <span class='unexecuted'>        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='unexecuted'>        _beforeTokenTransfer(from, to, amount);</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='unexecuted'>        uint256 fromBalance = _balances[from];</span>
 229 |     | <span class='unexecuted'>        require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span>
 230 |     | <span class='neutral'>        unchecked {</span>
 231 |     | <span class='unexecuted'>            _balances[from] = fromBalance - amount;</span>
 232 |     | <span class='neutral'>            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by</span>
 233 |     | <span class='neutral'>            // decrementing then incrementing.</span>
 234 |     | <span class='unexecuted'>            _balances[to] += amount;</span>
 235 |     | <span class='neutral'>        }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='unexecuted'>        emit Transfer(from, to, amount);</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='unexecuted'>        _afterTokenTransfer(from, to, amount);</span>
 240 |     | <span class='neutral'>    }</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    /** @dev Creates `amount` tokens and assigns them to `account`, increasing</span>
 243 |     | <span class='neutral'>     * the total supply.</span>
 244 |     | <span class='neutral'>     *</span>
 245 |     | <span class='neutral'>     * Emits a {Transfer} event with `from` set to the zero address.</span>
 246 |     | <span class='neutral'>     *</span>
 247 |     | <span class='neutral'>     * Requirements:</span>
 248 |     | <span class='neutral'>     *</span>
 249 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 250 |     | <span class='neutral'>     */</span>
 251 | *   | <span class='executed'>    function _mint(address account, uint256 amount) internal virtual {</span>
 252 | *   | <span class='executed'>        require(account != address(0), &quot;ERC20: mint to the zero address&quot;);</span>
 253 |     | <span class='neutral'></span>
 254 | *   | <span class='executed'>        _beforeTokenTransfer(address(0), account, amount);</span>
 255 |     | <span class='neutral'></span>
 256 | *   | <span class='executed'>        _totalSupply += amount;</span>
 257 |     | <span class='neutral'>        unchecked {</span>
 258 |     | <span class='neutral'>            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.</span>
 259 | *   | <span class='executed'>            _balances[account] += amount;</span>
 260 |     | <span class='neutral'>        }</span>
 261 | *   | <span class='executed'>        emit Transfer(address(0), account, amount);</span>
 262 |     | <span class='neutral'></span>
 263 | *   | <span class='executed'>        _afterTokenTransfer(address(0), account, amount);</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>    /**</span>
 267 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from `account`, reducing the</span>
 268 |     | <span class='neutral'>     * total supply.</span>
 269 |     | <span class='neutral'>     *</span>
 270 |     | <span class='neutral'>     * Emits a {Transfer} event with `to` set to the zero address.</span>
 271 |     | <span class='neutral'>     *</span>
 272 |     | <span class='neutral'>     * Requirements:</span>
 273 |     | <span class='neutral'>     *</span>
 274 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 275 |     | <span class='neutral'>     * - `account` must have at least `amount` tokens.</span>
 276 |     | <span class='neutral'>     */</span>
 277 | *   | <span class='executed'>    function _burn(address account, uint256 amount) internal virtual {</span>
 278 | *   | <span class='executed'>        require(account != address(0), &quot;ERC20: burn from the zero address&quot;);</span>
 279 |     | <span class='neutral'></span>
 280 | *   | <span class='executed'>        _beforeTokenTransfer(account, address(0), amount);</span>
 281 |     | <span class='neutral'></span>
 282 | *   | <span class='executed'>        uint256 accountBalance = _balances[account];</span>
 283 | *   | <span class='executed'>        require(accountBalance &gt;= amount, &quot;ERC20: burn amount exceeds balance&quot;);</span>
 284 |     | <span class='neutral'>        unchecked {</span>
 285 | *   | <span class='executed'>            _balances[account] = accountBalance - amount;</span>
 286 |     | <span class='neutral'>            // Overflow not possible: amount &lt;= accountBalance &lt;= totalSupply.</span>
 287 | *   | <span class='executed'>            _totalSupply -= amount;</span>
 288 |     | <span class='neutral'>        }</span>
 289 |     | <span class='neutral'></span>
 290 | *   | <span class='executed'>        emit Transfer(account, address(0), amount);</span>
 291 |     | <span class='neutral'></span>
 292 | *   | <span class='executed'>        _afterTokenTransfer(account, address(0), amount);</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>    /**</span>
 296 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.</span>
 297 |     | <span class='neutral'>     *</span>
 298 |     | <span class='neutral'>     * This internal function is equivalent to `approve`, and can be used to</span>
 299 |     | <span class='neutral'>     * e.g. set automatic allowances for certain subsystems, etc.</span>
 300 |     | <span class='neutral'>     *</span>
 301 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 302 |     | <span class='neutral'>     *</span>
 303 |     | <span class='neutral'>     * Requirements:</span>
 304 |     | <span class='neutral'>     *</span>
 305 |     | <span class='neutral'>     * - `owner` cannot be the zero address.</span>
 306 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 307 |     | <span class='neutral'>     */</span>
 308 |     | <span class='unexecuted'>    function _approve(address owner, address spender, uint256 amount) internal virtual {</span>
 309 |     | <span class='unexecuted'>        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span>
 310 |     | <span class='unexecuted'>        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span>
 311 |     | <span class='neutral'></span>
 312 |     | <span class='unexecuted'>        _allowances[owner][spender] = amount;</span>
 313 |     | <span class='unexecuted'>        emit Approval(owner, spender, amount);</span>
 314 |     | <span class='neutral'>    }</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>    /**</span>
 317 |     | <span class='neutral'>     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.</span>
 318 |     | <span class='neutral'>     *</span>
 319 |     | <span class='neutral'>     * Does not update the allowance amount in case of infinite allowance.</span>
 320 |     | <span class='neutral'>     * Revert if not enough allowance is available.</span>
 321 |     | <span class='neutral'>     *</span>
 322 |     | <span class='neutral'>     * Might emit an {Approval} event.</span>
 323 |     | <span class='neutral'>     */</span>
 324 |     | <span class='unexecuted'>    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {</span>
 325 |     | <span class='unexecuted'>        uint256 currentAllowance = allowance(owner, spender);</span>
 326 |     | <span class='unexecuted'>        if (currentAllowance != type(uint256).max) {</span>
 327 |     | <span class='unexecuted'>            require(currentAllowance &gt;= amount, &quot;ERC20: insufficient allowance&quot;);</span>
 328 |     | <span class='neutral'>            unchecked {</span>
 329 |     | <span class='unexecuted'>                _approve(owner, spender, currentAllowance - amount);</span>
 330 |     | <span class='neutral'>            }</span>
 331 |     | <span class='neutral'>        }</span>
 332 |     | <span class='neutral'>    }</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='neutral'>    /**</span>
 335 |     | <span class='neutral'>     * @dev Hook that is called before any transfer of tokens. This includes</span>
 336 |     | <span class='neutral'>     * minting and burning.</span>
 337 |     | <span class='neutral'>     *</span>
 338 |     | <span class='neutral'>     * Calling conditions:</span>
 339 |     | <span class='neutral'>     *</span>
 340 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 341 |     | <span class='neutral'>     * will be transferred to `to`.</span>
 342 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens will be minted for `to`.</span>
 343 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens will be burned.</span>
 344 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 345 |     | <span class='neutral'>     *</span>
 346 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 347 |     | <span class='neutral'>     */</span>
 348 | *   | <span class='executed'>    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}</span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='neutral'>    /**</span>
 351 |     | <span class='neutral'>     * @dev Hook that is called after any transfer of tokens. This includes</span>
 352 |     | <span class='neutral'>     * minting and burning.</span>
 353 |     | <span class='neutral'>     *</span>
 354 |     | <span class='neutral'>     * Calling conditions:</span>
 355 |     | <span class='neutral'>     *</span>
 356 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 357 |     | <span class='neutral'>     * has been transferred to `to`.</span>
 358 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens have been minted for `to`.</span>
 359 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens have been burned.</span>
 360 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 361 |     | <span class='neutral'>     *</span>
 362 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 363 |     | <span class='neutral'>     */</span>
 364 | *   | <span class='executed'>    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}</span>
 365 |     | <span class='neutral'>}</span>
 366 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 standard as defined in the EIP.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IERC20 {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
 12 |     | <span class='neutral'>     * another (`to`).</span>
 13 |     | <span class='neutral'>     *</span>
 14 |     | <span class='neutral'>     * Note that `value` may be zero.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 20 |     | <span class='neutral'>     * a call to {approve}. `value` is the new allowance.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the amount of tokens in existence.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /**</span>
 30 |     | <span class='neutral'>     * @dev Returns the amount of tokens owned by `account`.</span>
 31 |     | <span class='neutral'>     */</span>
 32 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Moves `amount` tokens from the caller&#39;s account to `to`.</span>
 36 |     | <span class='neutral'>     *</span>
 37 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 38 |     | <span class='neutral'>     *</span>
 39 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 40 |     | <span class='neutral'>     */</span>
 41 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 45 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 46 |     | <span class='neutral'>     * zero by default.</span>
 47 |     | <span class='neutral'>     *</span>
 48 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /**</span>
 53 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 54 |     | <span class='neutral'>     *</span>
 55 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 56 |     | <span class='neutral'>     *</span>
 57 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 58 |     | <span class='neutral'>     * that someone may use both the old and the new allowance by unfortunate</span>
 59 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 60 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 61 |     | <span class='neutral'>     * desired value afterwards:</span>
 62 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 63 |     | <span class='neutral'>     *</span>
 64 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 65 |     | <span class='neutral'>     */</span>
 66 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>    /**</span>
 69 |     | <span class='neutral'>     * @dev Moves `amount` tokens from `from` to `to` using the</span>
 70 |     | <span class='neutral'>     * allowance mechanism. `amount` is then deducted from the caller&#39;s</span>
 71 |     | <span class='neutral'>     * allowance.</span>
 72 |     | <span class='neutral'>     *</span>
 73 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 74 |     | <span class='neutral'>     *</span>
 75 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 76 |     | <span class='neutral'>     */</span>
 77 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 amount) external returns (bool);</span>
 78 |     | <span class='neutral'>}</span>
 79 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../IERC20.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Interface for the optional metadata functions from the ERC20 standard.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * _Available since v4.1._</span>
 12 |     | <span class='neutral'> */</span>
 13 |     | <span class='neutral'>interface IERC20Metadata is IERC20 {</span>
 14 |     | <span class='neutral'>    /**</span>
 15 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
 16 |     | <span class='neutral'>     */</span>
 17 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /**</span>
 20 |     | <span class='neutral'>     * @dev Returns the symbol of the token.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the decimals places of the token.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/@openzeppelin/contracts/utils/Context.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Provides information about the current execution context, including the</span>
  8 |     | <span class='neutral'> * sender of the transaction and its data. While these are generally available</span>
  9 |     | <span class='neutral'> * via msg.sender and msg.data, they should not be accessed in such a direct</span>
 10 |     | <span class='neutral'> * manner, since when dealing with meta-transactions the account sending and</span>
 11 |     | <span class='neutral'> * paying for execution may not be the actual sender (as far as an application</span>
 12 |     | <span class='neutral'> * is concerned).</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * This contract is only required for intermediate, library-like contracts.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract Context {</span>
 17 | *   | <span class='executed'>    function _msgSender() internal view virtual returns (address) {</span>
 18 | *   | <span class='executed'>        return msg.sender;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function _msgData() internal view virtual returns (bytes calldata) {</span>
 22 |     | <span class='neutral'>        return msg.data;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/@openzeppelin/contracts/utils/Strings.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./math/Math.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;./math/SignedMath.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @dev String operations.</span>
 11 |     | <span class='neutral'> */</span>
 12 |     | <span class='unexecuted'>library Strings {</span>
 13 |     | <span class='neutral'>    bytes16 private constant _SYMBOLS = &quot;0123456789abcdef&quot;;</span>
 14 |     | <span class='neutral'>    uint8 private constant _ADDRESS_LENGTH = 20;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @dev Converts a `uint256` to its ASCII `string` decimal representation.</span>
 18 |     | <span class='neutral'>     */</span>
 19 | *   | <span class='executed'>    function toString(uint256 value) internal pure returns (string memory) {</span>
 20 |     | <span class='neutral'>        unchecked {</span>
 21 | *   | <span class='executed'>            uint256 length = Math.log10(value) + 1;</span>
 22 | *   | <span class='executed'>            string memory buffer = new string(length);</span>
 23 | *   | <span class='executed'>            uint256 ptr;</span>
 24 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 25 |     | <span class='neutral'>            assembly {</span>
 26 | *   | <span class='executed'>                ptr := add(buffer, add(32, length))</span>
 27 |     | <span class='neutral'>            }</span>
 28 | *   | <span class='executed'>            while (true) {</span>
 29 | *   | <span class='executed'>                ptr--;</span>
 30 |     | <span class='neutral'>                /// @solidity memory-safe-assembly</span>
 31 |     | <span class='neutral'>                assembly {</span>
 32 | *   | <span class='executed'>                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))</span>
 33 |     | <span class='neutral'>                }</span>
 34 | *   | <span class='executed'>                value /= 10;</span>
 35 | *   | <span class='executed'>                if (value == 0) break;</span>
 36 |     | <span class='neutral'>            }</span>
 37 | *   | <span class='executed'>            return buffer;</span>
 38 |     | <span class='neutral'>        }</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /**</span>
 42 |     | <span class='neutral'>     * @dev Converts a `int256` to its ASCII `string` decimal representation.</span>
 43 |     | <span class='neutral'>     */</span>
 44 |     | <span class='neutral'>    function toString(int256 value) internal pure returns (string memory) {</span>
 45 |     | <span class='neutral'>        return string(abi.encodePacked(value &lt; 0 ? &quot;-&quot; : &quot;&quot;, toString(SignedMath.abs(value))));</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    /**</span>
 49 |     | <span class='neutral'>     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.</span>
 50 |     | <span class='neutral'>     */</span>
 51 |     | <span class='neutral'>    function toHexString(uint256 value) internal pure returns (string memory) {</span>
 52 |     | <span class='neutral'>        unchecked {</span>
 53 |     | <span class='neutral'>            return toHexString(value, Math.log256(value) + 1);</span>
 54 |     | <span class='neutral'>        }</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>    /**</span>
 58 |     | <span class='neutral'>     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.</span>
 59 |     | <span class='neutral'>     */</span>
 60 |     | <span class='neutral'>    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {</span>
 61 |     | <span class='neutral'>        bytes memory buffer = new bytes(2 * length + 2);</span>
 62 |     | <span class='neutral'>        buffer[0] = &quot;0&quot;;</span>
 63 |     | <span class='neutral'>        buffer[1] = &quot;x&quot;;</span>
 64 |     | <span class='neutral'>        for (uint256 i = 2 * length + 1; i &gt; 1; --i) {</span>
 65 |     | <span class='neutral'>            buffer[i] = _SYMBOLS[value &amp; 0xf];</span>
 66 |     | <span class='neutral'>            value &gt;&gt;= 4;</span>
 67 |     | <span class='neutral'>        }</span>
 68 |     | <span class='neutral'>        require(value == 0, &quot;Strings: hex length insufficient&quot;);</span>
 69 |     | <span class='neutral'>        return string(buffer);</span>
 70 |     | <span class='neutral'>    }</span>
 71 |     | <span class='neutral'></span>
 72 |     | <span class='neutral'>    /**</span>
 73 |     | <span class='neutral'>     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.</span>
 74 |     | <span class='neutral'>     */</span>
 75 |     | <span class='neutral'>    function toHexString(address addr) internal pure returns (string memory) {</span>
 76 |     | <span class='neutral'>        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);</span>
 77 |     | <span class='neutral'>    }</span>
 78 |     | <span class='neutral'></span>
 79 |     | <span class='neutral'>    /**</span>
 80 |     | <span class='neutral'>     * @dev Returns true if the two strings are equal.</span>
 81 |     | <span class='neutral'>     */</span>
 82 |     | <span class='neutral'>    function equal(string memory a, string memory b) internal pure returns (bool) {</span>
 83 |     | <span class='neutral'>        return keccak256(bytes(a)) == keccak256(bytes(b));</span>
 84 |     | <span class='neutral'>    }</span>
 85 |     | <span class='neutral'>}</span>
 86 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/@openzeppelin/contracts/utils/cryptography/MerkleProof.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @dev These functions deal with verification of Merkle Tree proofs.</span>
   8 |     | <span class='neutral'> *</span>
   9 |     | <span class='neutral'> * The tree and the proofs can be generated using our</span>
  10 |     | <span class='neutral'> * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].</span>
  11 |     | <span class='neutral'> * You will find a quickstart guide in the readme.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * WARNING: You should avoid using leaf values that are 64 bytes long prior to</span>
  14 |     | <span class='neutral'> * hashing, or use a hash function other than keccak256 for hashing leaves.</span>
  15 |     | <span class='neutral'> * This is because the concatenation of a sorted pair of internal nodes in</span>
  16 |     | <span class='neutral'> * the merkle tree could be reinterpreted as a leaf value.</span>
  17 |     | <span class='neutral'> * OpenZeppelin&#39;s JavaScript library generates merkle trees that are safe</span>
  18 |     | <span class='neutral'> * against this attack out of the box.</span>
  19 |     | <span class='neutral'> */</span>
  20 |     | <span class='unexecuted'>library MerkleProof {</span>
  21 |     | <span class='neutral'>    /**</span>
  22 |     | <span class='neutral'>     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree</span>
  23 |     | <span class='neutral'>     * defined by `root`. For this, a `proof` must be provided, containing</span>
  24 |     | <span class='neutral'>     * sibling hashes on the branch from the leaf to the root of the tree. Each</span>
  25 |     | <span class='neutral'>     * pair of leaves and each pair of pre-images are assumed to be sorted.</span>
  26 |     | <span class='neutral'>     */</span>
  27 |     | <span class='unexecuted'>    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {</span>
  28 |     | <span class='unexecuted'>        return processProof(proof, leaf) == root;</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /**</span>
  32 |     | <span class='neutral'>     * @dev Calldata version of {verify}</span>
  33 |     | <span class='neutral'>     *</span>
  34 |     | <span class='neutral'>     * _Available since v4.7._</span>
  35 |     | <span class='neutral'>     */</span>
  36 |     | <span class='neutral'>    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {</span>
  37 |     | <span class='neutral'>        return processProofCalldata(proof, leaf) == root;</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /**</span>
  41 |     | <span class='neutral'>     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up</span>
  42 |     | <span class='neutral'>     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt</span>
  43 |     | <span class='neutral'>     * hash matches the root of the tree. When processing the proof, the pairs</span>
  44 |     | <span class='neutral'>     * of leafs &amp; pre-images are assumed to be sorted.</span>
  45 |     | <span class='neutral'>     *</span>
  46 |     | <span class='neutral'>     * _Available since v4.4._</span>
  47 |     | <span class='neutral'>     */</span>
  48 |     | <span class='unexecuted'>    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {</span>
  49 |     | <span class='unexecuted'>        bytes32 computedHash = leaf;</span>
  50 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; proof.length; i++) {</span>
  51 |     | <span class='unexecuted'>            computedHash = _hashPair(computedHash, proof[i]);</span>
  52 |     | <span class='neutral'>        }</span>
  53 |     | <span class='unexecuted'>        return computedHash;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @dev Calldata version of {processProof}</span>
  58 |     | <span class='neutral'>     *</span>
  59 |     | <span class='neutral'>     * _Available since v4.7._</span>
  60 |     | <span class='neutral'>     */</span>
  61 |     | <span class='neutral'>    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {</span>
  62 |     | <span class='neutral'>        bytes32 computedHash = leaf;</span>
  63 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; proof.length; i++) {</span>
  64 |     | <span class='neutral'>            computedHash = _hashPair(computedHash, proof[i]);</span>
  65 |     | <span class='neutral'>        }</span>
  66 |     | <span class='neutral'>        return computedHash;</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /**</span>
  70 |     | <span class='neutral'>     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by</span>
  71 |     | <span class='neutral'>     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.</span>
  72 |     | <span class='neutral'>     *</span>
  73 |     | <span class='neutral'>     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.</span>
  74 |     | <span class='neutral'>     *</span>
  75 |     | <span class='neutral'>     * _Available since v4.7._</span>
  76 |     | <span class='neutral'>     */</span>
  77 |     | <span class='neutral'>    function multiProofVerify(</span>
  78 |     | <span class='neutral'>        bytes32[] memory proof,</span>
  79 |     | <span class='neutral'>        bool[] memory proofFlags,</span>
  80 |     | <span class='neutral'>        bytes32 root,</span>
  81 |     | <span class='neutral'>        bytes32[] memory leaves</span>
  82 |     | <span class='neutral'>    ) internal pure returns (bool) {</span>
  83 |     | <span class='neutral'>        return processMultiProof(proof, proofFlags, leaves) == root;</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /**</span>
  87 |     | <span class='neutral'>     * @dev Calldata version of {multiProofVerify}</span>
  88 |     | <span class='neutral'>     *</span>
  89 |     | <span class='neutral'>     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.</span>
  90 |     | <span class='neutral'>     *</span>
  91 |     | <span class='neutral'>     * _Available since v4.7._</span>
  92 |     | <span class='neutral'>     */</span>
  93 |     | <span class='neutral'>    function multiProofVerifyCalldata(</span>
  94 |     | <span class='neutral'>        bytes32[] calldata proof,</span>
  95 |     | <span class='neutral'>        bool[] calldata proofFlags,</span>
  96 |     | <span class='neutral'>        bytes32 root,</span>
  97 |     | <span class='neutral'>        bytes32[] memory leaves</span>
  98 |     | <span class='neutral'>    ) internal pure returns (bool) {</span>
  99 |     | <span class='neutral'>        return processMultiProofCalldata(proof, proofFlags, leaves) == root;</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    /**</span>
 103 |     | <span class='neutral'>     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction</span>
 104 |     | <span class='neutral'>     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another</span>
 105 |     | <span class='neutral'>     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false</span>
 106 |     | <span class='neutral'>     * respectively.</span>
 107 |     | <span class='neutral'>     *</span>
 108 |     | <span class='neutral'>     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree</span>
 109 |     | <span class='neutral'>     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the</span>
 110 |     | <span class='neutral'>     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).</span>
 111 |     | <span class='neutral'>     *</span>
 112 |     | <span class='neutral'>     * _Available since v4.7._</span>
 113 |     | <span class='neutral'>     */</span>
 114 |     | <span class='neutral'>    function processMultiProof(</span>
 115 |     | <span class='neutral'>        bytes32[] memory proof,</span>
 116 |     | <span class='neutral'>        bool[] memory proofFlags,</span>
 117 |     | <span class='neutral'>        bytes32[] memory leaves</span>
 118 |     | <span class='neutral'>    ) internal pure returns (bytes32 merkleRoot) {</span>
 119 |     | <span class='neutral'>        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by</span>
 120 |     | <span class='neutral'>        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the</span>
 121 |     | <span class='neutral'>        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of</span>
 122 |     | <span class='neutral'>        // the merkle tree.</span>
 123 |     | <span class='neutral'>        uint256 leavesLen = leaves.length;</span>
 124 |     | <span class='neutral'>        uint256 proofLen = proof.length;</span>
 125 |     | <span class='neutral'>        uint256 totalHashes = proofFlags.length;</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>        // Check proof validity.</span>
 128 |     | <span class='neutral'>        require(leavesLen + proofLen - 1 == totalHashes, &quot;MerkleProof: invalid multiproof&quot;);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>        // The xxxPos values are &quot;pointers&quot; to the next value to consume in each array. All accesses are done using</span>
 131 |     | <span class='neutral'>        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue&#39;s &quot;pop&quot;.</span>
 132 |     | <span class='neutral'>        bytes32[] memory hashes = new bytes32[](totalHashes);</span>
 133 |     | <span class='neutral'>        uint256 leafPos = 0;</span>
 134 |     | <span class='neutral'>        uint256 hashPos = 0;</span>
 135 |     | <span class='neutral'>        uint256 proofPos = 0;</span>
 136 |     | <span class='neutral'>        // At each step, we compute the next hash using two values:</span>
 137 |     | <span class='neutral'>        // - a value from the &quot;main queue&quot;. If not all leaves have been consumed, we get the next leaf, otherwise we</span>
 138 |     | <span class='neutral'>        //   get the next hash.</span>
 139 |     | <span class='neutral'>        // - depending on the flag, either another value from the &quot;main queue&quot; (merging branches) or an element from the</span>
 140 |     | <span class='neutral'>        //   `proof` array.</span>
 141 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; totalHashes; i++) {</span>
 142 |     | <span class='neutral'>            bytes32 a = leafPos &lt; leavesLen ? leaves[leafPos++] : hashes[hashPos++];</span>
 143 |     | <span class='neutral'>            bytes32 b = proofFlags[i]</span>
 144 |     | <span class='neutral'>                ? (leafPos &lt; leavesLen ? leaves[leafPos++] : hashes[hashPos++])</span>
 145 |     | <span class='neutral'>                : proof[proofPos++];</span>
 146 |     | <span class='neutral'>            hashes[i] = _hashPair(a, b);</span>
 147 |     | <span class='neutral'>        }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>        if (totalHashes &gt; 0) {</span>
 150 |     | <span class='neutral'>            require(proofPos == proofLen, &quot;MerkleProof: invalid multiproof&quot;);</span>
 151 |     | <span class='neutral'>            unchecked {</span>
 152 |     | <span class='neutral'>                return hashes[totalHashes - 1];</span>
 153 |     | <span class='neutral'>            }</span>
 154 |     | <span class='neutral'>        } else if (leavesLen &gt; 0) {</span>
 155 |     | <span class='neutral'>            return leaves[0];</span>
 156 |     | <span class='neutral'>        } else {</span>
 157 |     | <span class='neutral'>            return proof[0];</span>
 158 |     | <span class='neutral'>        }</span>
 159 |     | <span class='neutral'>    }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>    /**</span>
 162 |     | <span class='neutral'>     * @dev Calldata version of {processMultiProof}.</span>
 163 |     | <span class='neutral'>     *</span>
 164 |     | <span class='neutral'>     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.</span>
 165 |     | <span class='neutral'>     *</span>
 166 |     | <span class='neutral'>     * _Available since v4.7._</span>
 167 |     | <span class='neutral'>     */</span>
 168 |     | <span class='neutral'>    function processMultiProofCalldata(</span>
 169 |     | <span class='neutral'>        bytes32[] calldata proof,</span>
 170 |     | <span class='neutral'>        bool[] calldata proofFlags,</span>
 171 |     | <span class='neutral'>        bytes32[] memory leaves</span>
 172 |     | <span class='neutral'>    ) internal pure returns (bytes32 merkleRoot) {</span>
 173 |     | <span class='neutral'>        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by</span>
 174 |     | <span class='neutral'>        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the</span>
 175 |     | <span class='neutral'>        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of</span>
 176 |     | <span class='neutral'>        // the merkle tree.</span>
 177 |     | <span class='neutral'>        uint256 leavesLen = leaves.length;</span>
 178 |     | <span class='neutral'>        uint256 proofLen = proof.length;</span>
 179 |     | <span class='neutral'>        uint256 totalHashes = proofFlags.length;</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>        // Check proof validity.</span>
 182 |     | <span class='neutral'>        require(leavesLen + proofLen - 1 == totalHashes, &quot;MerkleProof: invalid multiproof&quot;);</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>        // The xxxPos values are &quot;pointers&quot; to the next value to consume in each array. All accesses are done using</span>
 185 |     | <span class='neutral'>        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue&#39;s &quot;pop&quot;.</span>
 186 |     | <span class='neutral'>        bytes32[] memory hashes = new bytes32[](totalHashes);</span>
 187 |     | <span class='neutral'>        uint256 leafPos = 0;</span>
 188 |     | <span class='neutral'>        uint256 hashPos = 0;</span>
 189 |     | <span class='neutral'>        uint256 proofPos = 0;</span>
 190 |     | <span class='neutral'>        // At each step, we compute the next hash using two values:</span>
 191 |     | <span class='neutral'>        // - a value from the &quot;main queue&quot;. If not all leaves have been consumed, we get the next leaf, otherwise we</span>
 192 |     | <span class='neutral'>        //   get the next hash.</span>
 193 |     | <span class='neutral'>        // - depending on the flag, either another value from the &quot;main queue&quot; (merging branches) or an element from the</span>
 194 |     | <span class='neutral'>        //   `proof` array.</span>
 195 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; totalHashes; i++) {</span>
 196 |     | <span class='neutral'>            bytes32 a = leafPos &lt; leavesLen ? leaves[leafPos++] : hashes[hashPos++];</span>
 197 |     | <span class='neutral'>            bytes32 b = proofFlags[i]</span>
 198 |     | <span class='neutral'>                ? (leafPos &lt; leavesLen ? leaves[leafPos++] : hashes[hashPos++])</span>
 199 |     | <span class='neutral'>                : proof[proofPos++];</span>
 200 |     | <span class='neutral'>            hashes[i] = _hashPair(a, b);</span>
 201 |     | <span class='neutral'>        }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>        if (totalHashes &gt; 0) {</span>
 204 |     | <span class='neutral'>            require(proofPos == proofLen, &quot;MerkleProof: invalid multiproof&quot;);</span>
 205 |     | <span class='neutral'>            unchecked {</span>
 206 |     | <span class='neutral'>                return hashes[totalHashes - 1];</span>
 207 |     | <span class='neutral'>            }</span>
 208 |     | <span class='neutral'>        } else if (leavesLen &gt; 0) {</span>
 209 |     | <span class='neutral'>            return leaves[0];</span>
 210 |     | <span class='neutral'>        } else {</span>
 211 |     | <span class='neutral'>            return proof[0];</span>
 212 |     | <span class='neutral'>        }</span>
 213 |     | <span class='neutral'>    }</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='unexecuted'>    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {</span>
 216 |     | <span class='unexecuted'>        return a &lt; b ? _efficientHash(a, b) : _efficientHash(b, a);</span>
 217 |     | <span class='neutral'>    }</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='unexecuted'>    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {</span>
 220 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 221 |     | <span class='neutral'>        assembly {</span>
 222 |     | <span class='unexecuted'>            mstore(0x00, a)</span>
 223 |     | <span class='unexecuted'>            mstore(0x20, b)</span>
 224 |     | <span class='unexecuted'>            value := keccak256(0x00, 0x40)</span>
 225 |     | <span class='neutral'>        }</span>
 226 |     | <span class='neutral'>    }</span>
 227 |     | <span class='neutral'>}</span>
 228 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/@openzeppelin/contracts/utils/math/Math.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @dev Standard math utilities missing in the Solidity language.</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='unexecuted'>library Math {</span>
  10 |     | <span class='neutral'>    enum Rounding {</span>
  11 |     | <span class='neutral'>        Down, // Toward negative infinity</span>
  12 |     | <span class='neutral'>        Up, // Toward infinity</span>
  13 |     | <span class='neutral'>        Zero // Toward zero</span>
  14 |     | <span class='neutral'>    }</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    /**</span>
  17 |     | <span class='neutral'>     * @dev Returns the largest of two numbers.</span>
  18 |     | <span class='neutral'>     */</span>
  19 |     | <span class='neutral'>    function max(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  20 |     | <span class='neutral'>        return a &gt; b ? a : b;</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /**</span>
  24 |     | <span class='neutral'>     * @dev Returns the smallest of two numbers.</span>
  25 |     | <span class='neutral'>     */</span>
  26 |     | <span class='neutral'>    function min(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  27 |     | <span class='neutral'>        return a &lt; b ? a : b;</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @dev Returns the average of two numbers. The result is rounded towards</span>
  32 |     | <span class='neutral'>     * zero.</span>
  33 |     | <span class='neutral'>     */</span>
  34 |     | <span class='neutral'>    function average(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  35 |     | <span class='neutral'>        // (a + b) / 2 can overflow.</span>
  36 |     | <span class='neutral'>        return (a &amp; b) + (a ^ b) / 2;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    /**</span>
  40 |     | <span class='neutral'>     * @dev Returns the ceiling of the division of two numbers.</span>
  41 |     | <span class='neutral'>     *</span>
  42 |     | <span class='neutral'>     * This differs from standard division with `/` in that it rounds up instead</span>
  43 |     | <span class='neutral'>     * of rounding down.</span>
  44 |     | <span class='neutral'>     */</span>
  45 |     | <span class='neutral'>    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  46 |     | <span class='neutral'>        // (a + b - 1) / b can overflow on addition, so we distribute.</span>
  47 |     | <span class='neutral'>        return a == 0 ? 0 : (a - 1) / b + 1;</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /**</span>
  51 |     | <span class='neutral'>     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0</span>
  52 |     | <span class='neutral'>     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)</span>
  53 |     | <span class='neutral'>     * with further edits by Uniswap Labs also under MIT license.</span>
  54 |     | <span class='neutral'>     */</span>
  55 |     | <span class='neutral'>    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {</span>
  56 |     | <span class='neutral'>        unchecked {</span>
  57 |     | <span class='neutral'>            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use</span>
  58 |     | <span class='neutral'>            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256</span>
  59 |     | <span class='neutral'>            // variables such that product = prod1 * 2^256 + prod0.</span>
  60 |     | <span class='neutral'>            uint256 prod0; // Least significant 256 bits of the product</span>
  61 |     | <span class='neutral'>            uint256 prod1; // Most significant 256 bits of the product</span>
  62 |     | <span class='neutral'>            assembly {</span>
  63 |     | <span class='neutral'>                let mm := mulmod(x, y, not(0))</span>
  64 |     | <span class='neutral'>                prod0 := mul(x, y)</span>
  65 |     | <span class='neutral'>                prod1 := sub(sub(mm, prod0), lt(mm, prod0))</span>
  66 |     | <span class='neutral'>            }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>            // Handle non-overflow cases, 256 by 256 division.</span>
  69 |     | <span class='neutral'>            if (prod1 == 0) {</span>
  70 |     | <span class='neutral'>                // Solidity will revert if denominator == 0, unlike the div opcode on its own.</span>
  71 |     | <span class='neutral'>                // The surrounding unchecked block does not change this fact.</span>
  72 |     | <span class='neutral'>                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.</span>
  73 |     | <span class='neutral'>                return prod0 / denominator;</span>
  74 |     | <span class='neutral'>            }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>            // Make sure the result is less than 2^256. Also prevents denominator == 0.</span>
  77 |     | <span class='neutral'>            require(denominator &gt; prod1, &quot;Math: mulDiv overflow&quot;);</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
  80 |     | <span class='neutral'>            // 512 by 256 division.</span>
  81 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>            // Make division exact by subtracting the remainder from [prod1 prod0].</span>
  84 |     | <span class='neutral'>            uint256 remainder;</span>
  85 |     | <span class='neutral'>            assembly {</span>
  86 |     | <span class='neutral'>                // Compute remainder using mulmod.</span>
  87 |     | <span class='neutral'>                remainder := mulmod(x, y, denominator)</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>                // Subtract 256 bit number from 512 bit number.</span>
  90 |     | <span class='neutral'>                prod1 := sub(prod1, gt(remainder, prod0))</span>
  91 |     | <span class='neutral'>                prod0 := sub(prod0, remainder)</span>
  92 |     | <span class='neutral'>            }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always &gt;= 1.</span>
  95 |     | <span class='neutral'>            // See https://cs.stackexchange.com/q/138556/92363.</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>            // Does not overflow because the denominator cannot be zero at this stage in the function.</span>
  98 |     | <span class='neutral'>            uint256 twos = denominator &amp; (~denominator + 1);</span>
  99 |     | <span class='neutral'>            assembly {</span>
 100 |     | <span class='neutral'>                // Divide denominator by twos.</span>
 101 |     | <span class='neutral'>                denominator := div(denominator, twos)</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>                // Divide [prod1 prod0] by twos.</span>
 104 |     | <span class='neutral'>                prod0 := div(prod0, twos)</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.</span>
 107 |     | <span class='neutral'>                twos := add(div(sub(0, twos), twos), 1)</span>
 108 |     | <span class='neutral'>            }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>            // Shift in bits from prod1 into prod0.</span>
 111 |     | <span class='neutral'>            prod0 |= prod1 * twos;</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such</span>
 114 |     | <span class='neutral'>            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for</span>
 115 |     | <span class='neutral'>            // four bits. That is, denominator * inv = 1 mod 2^4.</span>
 116 |     | <span class='neutral'>            uint256 inverse = (3 * denominator) ^ 2;</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel&#39;s lifting lemma, this also works</span>
 119 |     | <span class='neutral'>            // in modular arithmetic, doubling the correct bits in each step.</span>
 120 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^8</span>
 121 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^16</span>
 122 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^32</span>
 123 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^64</span>
 124 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^128</span>
 125 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^256</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.</span>
 128 |     | <span class='neutral'>            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is</span>
 129 |     | <span class='neutral'>            // less than 2^256, this is the final result. We don&#39;t need to compute the high bits of the result and prod1</span>
 130 |     | <span class='neutral'>            // is no longer required.</span>
 131 |     | <span class='neutral'>            result = prod0 * inverse;</span>
 132 |     | <span class='neutral'>            return result;</span>
 133 |     | <span class='neutral'>        }</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    /**</span>
 137 |     | <span class='neutral'>     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.</span>
 138 |     | <span class='neutral'>     */</span>
 139 |     | <span class='neutral'>    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {</span>
 140 |     | <span class='neutral'>        uint256 result = mulDiv(x, y, denominator);</span>
 141 |     | <span class='neutral'>        if (rounding == Rounding.Up &amp;&amp; mulmod(x, y, denominator) &gt; 0) {</span>
 142 |     | <span class='neutral'>            result += 1;</span>
 143 |     | <span class='neutral'>        }</span>
 144 |     | <span class='neutral'>        return result;</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    /**</span>
 148 |     | <span class='neutral'>     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.</span>
 149 |     | <span class='neutral'>     *</span>
 150 |     | <span class='neutral'>     * Inspired by Henry S. Warren, Jr.&#39;s &quot;Hacker&#39;s Delight&quot; (Chapter 11).</span>
 151 |     | <span class='neutral'>     */</span>
 152 |     | <span class='neutral'>    function sqrt(uint256 a) internal pure returns (uint256) {</span>
 153 |     | <span class='neutral'>        if (a == 0) {</span>
 154 |     | <span class='neutral'>            return 0;</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.</span>
 158 |     | <span class='neutral'>        //</span>
 159 |     | <span class='neutral'>        // We know that the &quot;msb&quot; (most significant bit) of our target number `a` is a power of 2 such that we have</span>
 160 |     | <span class='neutral'>        // `msb(a) &lt;= a &lt; 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.</span>
 161 |     | <span class='neutral'>        //</span>
 162 |     | <span class='neutral'>        // This can be rewritten `2**log2(a) &lt;= a &lt; 2**(log2(a) + 1)`</span>
 163 |     | <span class='neutral'>        //  `sqrt(2**k) &lt;= sqrt(a) &lt; sqrt(2**(k+1))`</span>
 164 |     | <span class='neutral'>        //  `2**(k/2) &lt;= sqrt(a) &lt; 2**((k+1)/2) &lt;= 2**(k/2 + 1)`</span>
 165 |     | <span class='neutral'>        //</span>
 166 |     | <span class='neutral'>        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.</span>
 167 |     | <span class='neutral'>        uint256 result = 1 &lt;&lt; (log2(a) &gt;&gt; 1);</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,</span>
 170 |     | <span class='neutral'>        // since it is the square root of a uint256. Newton&#39;s method converges quadratically (precision doubles at</span>
 171 |     | <span class='neutral'>        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision</span>
 172 |     | <span class='neutral'>        // into the expected uint128 result.</span>
 173 |     | <span class='neutral'>        unchecked {</span>
 174 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 175 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 176 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 177 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 178 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 179 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 180 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 181 |     | <span class='neutral'>            return min(result, a / result);</span>
 182 |     | <span class='neutral'>        }</span>
 183 |     | <span class='neutral'>    }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>    /**</span>
 186 |     | <span class='neutral'>     * @notice Calculates sqrt(a), following the selected rounding direction.</span>
 187 |     | <span class='neutral'>     */</span>
 188 |     | <span class='neutral'>    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {</span>
 189 |     | <span class='neutral'>        unchecked {</span>
 190 |     | <span class='neutral'>            uint256 result = sqrt(a);</span>
 191 |     | <span class='neutral'>            return result + (rounding == Rounding.Up &amp;&amp; result * result &lt; a ? 1 : 0);</span>
 192 |     | <span class='neutral'>        }</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    /**</span>
 196 |     | <span class='neutral'>     * @dev Return the log in base 2, rounded down, of a positive value.</span>
 197 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 198 |     | <span class='neutral'>     */</span>
 199 |     | <span class='neutral'>    function log2(uint256 value) internal pure returns (uint256) {</span>
 200 |     | <span class='neutral'>        uint256 result = 0;</span>
 201 |     | <span class='neutral'>        unchecked {</span>
 202 |     | <span class='neutral'>            if (value &gt;&gt; 128 &gt; 0) {</span>
 203 |     | <span class='neutral'>                value &gt;&gt;= 128;</span>
 204 |     | <span class='neutral'>                result += 128;</span>
 205 |     | <span class='neutral'>            }</span>
 206 |     | <span class='neutral'>            if (value &gt;&gt; 64 &gt; 0) {</span>
 207 |     | <span class='neutral'>                value &gt;&gt;= 64;</span>
 208 |     | <span class='neutral'>                result += 64;</span>
 209 |     | <span class='neutral'>            }</span>
 210 |     | <span class='neutral'>            if (value &gt;&gt; 32 &gt; 0) {</span>
 211 |     | <span class='neutral'>                value &gt;&gt;= 32;</span>
 212 |     | <span class='neutral'>                result += 32;</span>
 213 |     | <span class='neutral'>            }</span>
 214 |     | <span class='neutral'>            if (value &gt;&gt; 16 &gt; 0) {</span>
 215 |     | <span class='neutral'>                value &gt;&gt;= 16;</span>
 216 |     | <span class='neutral'>                result += 16;</span>
 217 |     | <span class='neutral'>            }</span>
 218 |     | <span class='neutral'>            if (value &gt;&gt; 8 &gt; 0) {</span>
 219 |     | <span class='neutral'>                value &gt;&gt;= 8;</span>
 220 |     | <span class='neutral'>                result += 8;</span>
 221 |     | <span class='neutral'>            }</span>
 222 |     | <span class='neutral'>            if (value &gt;&gt; 4 &gt; 0) {</span>
 223 |     | <span class='neutral'>                value &gt;&gt;= 4;</span>
 224 |     | <span class='neutral'>                result += 4;</span>
 225 |     | <span class='neutral'>            }</span>
 226 |     | <span class='neutral'>            if (value &gt;&gt; 2 &gt; 0) {</span>
 227 |     | <span class='neutral'>                value &gt;&gt;= 2;</span>
 228 |     | <span class='neutral'>                result += 2;</span>
 229 |     | <span class='neutral'>            }</span>
 230 |     | <span class='neutral'>            if (value &gt;&gt; 1 &gt; 0) {</span>
 231 |     | <span class='neutral'>                result += 1;</span>
 232 |     | <span class='neutral'>            }</span>
 233 |     | <span class='neutral'>        }</span>
 234 |     | <span class='neutral'>        return result;</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    /**</span>
 238 |     | <span class='neutral'>     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.</span>
 239 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 240 |     | <span class='neutral'>     */</span>
 241 |     | <span class='neutral'>    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {</span>
 242 |     | <span class='neutral'>        unchecked {</span>
 243 |     | <span class='neutral'>            uint256 result = log2(value);</span>
 244 |     | <span class='neutral'>            return result + (rounding == Rounding.Up &amp;&amp; 1 &lt;&lt; result &lt; value ? 1 : 0);</span>
 245 |     | <span class='neutral'>        }</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    /**</span>
 249 |     | <span class='neutral'>     * @dev Return the log in base 10, rounded down, of a positive value.</span>
 250 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 251 |     | <span class='neutral'>     */</span>
 252 | *   | <span class='executed'>    function log10(uint256 value) internal pure returns (uint256) {</span>
 253 | *   | <span class='executed'>        uint256 result = 0;</span>
 254 |     | <span class='neutral'>        unchecked {</span>
 255 | *   | <span class='executed'>            if (value &gt;= 10 ** 64) {</span>
 256 |     | <span class='unexecuted'>                value /= 10 ** 64;</span>
 257 |     | <span class='unexecuted'>                result += 64;</span>
 258 |     | <span class='neutral'>            }</span>
 259 | *   | <span class='executed'>            if (value &gt;= 10 ** 32) {</span>
 260 |     | <span class='unexecuted'>                value /= 10 ** 32;</span>
 261 |     | <span class='unexecuted'>                result += 32;</span>
 262 |     | <span class='neutral'>            }</span>
 263 | *   | <span class='executed'>            if (value &gt;= 10 ** 16) {</span>
 264 |     | <span class='unexecuted'>                value /= 10 ** 16;</span>
 265 |     | <span class='unexecuted'>                result += 16;</span>
 266 |     | <span class='neutral'>            }</span>
 267 | *   | <span class='executed'>            if (value &gt;= 10 ** 8) {</span>
 268 |     | <span class='unexecuted'>                value /= 10 ** 8;</span>
 269 |     | <span class='unexecuted'>                result += 8;</span>
 270 |     | <span class='neutral'>            }</span>
 271 | *   | <span class='executed'>            if (value &gt;= 10 ** 4) {</span>
 272 |     | <span class='unexecuted'>                value /= 10 ** 4;</span>
 273 |     | <span class='unexecuted'>                result += 4;</span>
 274 |     | <span class='neutral'>            }</span>
 275 | *   | <span class='executed'>            if (value &gt;= 10 ** 2) {</span>
 276 |     | <span class='unexecuted'>                value /= 10 ** 2;</span>
 277 |     | <span class='unexecuted'>                result += 2;</span>
 278 |     | <span class='neutral'>            }</span>
 279 | *   | <span class='executed'>            if (value &gt;= 10 ** 1) {</span>
 280 |     | <span class='unexecuted'>                result += 1;</span>
 281 |     | <span class='neutral'>            }</span>
 282 |     | <span class='neutral'>        }</span>
 283 | *   | <span class='executed'>        return result;</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='neutral'>    /**</span>
 287 |     | <span class='neutral'>     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.</span>
 288 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 289 |     | <span class='neutral'>     */</span>
 290 |     | <span class='neutral'>    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {</span>
 291 |     | <span class='neutral'>        unchecked {</span>
 292 |     | <span class='neutral'>            uint256 result = log10(value);</span>
 293 |     | <span class='neutral'>            return result + (rounding == Rounding.Up &amp;&amp; 10 ** result &lt; value ? 1 : 0);</span>
 294 |     | <span class='neutral'>        }</span>
 295 |     | <span class='neutral'>    }</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>    /**</span>
 298 |     | <span class='neutral'>     * @dev Return the log in base 256, rounded down, of a positive value.</span>
 299 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 300 |     | <span class='neutral'>     *</span>
 301 |     | <span class='neutral'>     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.</span>
 302 |     | <span class='neutral'>     */</span>
 303 |     | <span class='neutral'>    function log256(uint256 value) internal pure returns (uint256) {</span>
 304 |     | <span class='neutral'>        uint256 result = 0;</span>
 305 |     | <span class='neutral'>        unchecked {</span>
 306 |     | <span class='neutral'>            if (value &gt;&gt; 128 &gt; 0) {</span>
 307 |     | <span class='neutral'>                value &gt;&gt;= 128;</span>
 308 |     | <span class='neutral'>                result += 16;</span>
 309 |     | <span class='neutral'>            }</span>
 310 |     | <span class='neutral'>            if (value &gt;&gt; 64 &gt; 0) {</span>
 311 |     | <span class='neutral'>                value &gt;&gt;= 64;</span>
 312 |     | <span class='neutral'>                result += 8;</span>
 313 |     | <span class='neutral'>            }</span>
 314 |     | <span class='neutral'>            if (value &gt;&gt; 32 &gt; 0) {</span>
 315 |     | <span class='neutral'>                value &gt;&gt;= 32;</span>
 316 |     | <span class='neutral'>                result += 4;</span>
 317 |     | <span class='neutral'>            }</span>
 318 |     | <span class='neutral'>            if (value &gt;&gt; 16 &gt; 0) {</span>
 319 |     | <span class='neutral'>                value &gt;&gt;= 16;</span>
 320 |     | <span class='neutral'>                result += 2;</span>
 321 |     | <span class='neutral'>            }</span>
 322 |     | <span class='neutral'>            if (value &gt;&gt; 8 &gt; 0) {</span>
 323 |     | <span class='neutral'>                result += 1;</span>
 324 |     | <span class='neutral'>            }</span>
 325 |     | <span class='neutral'>        }</span>
 326 |     | <span class='neutral'>        return result;</span>
 327 |     | <span class='neutral'>    }</span>
 328 |     | <span class='neutral'></span>
 329 |     | <span class='neutral'>    /**</span>
 330 |     | <span class='neutral'>     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.</span>
 331 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 332 |     | <span class='neutral'>     */</span>
 333 |     | <span class='neutral'>    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {</span>
 334 |     | <span class='neutral'>        unchecked {</span>
 335 |     | <span class='neutral'>            uint256 result = log256(value);</span>
 336 |     | <span class='neutral'>            return result + (rounding == Rounding.Up &amp;&amp; 1 &lt;&lt; (result &lt;&lt; 3) &lt; value ? 1 : 0);</span>
 337 |     | <span class='neutral'>        }</span>
 338 |     | <span class='neutral'>    }</span>
 339 |     | <span class='neutral'>}</span>
 340 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Standard signed math utilities missing in the Solidity language.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='unexecuted'>library SignedMath {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Returns the largest of two signed numbers.</span>
 12 |     | <span class='neutral'>     */</span>
 13 |     | <span class='neutral'>    function max(int256 a, int256 b) internal pure returns (int256) {</span>
 14 |     | <span class='neutral'>        return a &gt; b ? a : b;</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /**</span>
 18 |     | <span class='neutral'>     * @dev Returns the smallest of two signed numbers.</span>
 19 |     | <span class='neutral'>     */</span>
 20 |     | <span class='neutral'>    function min(int256 a, int256 b) internal pure returns (int256) {</span>
 21 |     | <span class='neutral'>        return a &lt; b ? a : b;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the average of two signed numbers without overflow.</span>
 26 |     | <span class='neutral'>     * The result is rounded towards zero.</span>
 27 |     | <span class='neutral'>     */</span>
 28 |     | <span class='neutral'>    function average(int256 a, int256 b) internal pure returns (int256) {</span>
 29 |     | <span class='neutral'>        // Formula from the book &quot;Hacker&#39;s Delight&quot;</span>
 30 |     | <span class='neutral'>        int256 x = (a &amp; b) + ((a ^ b) &gt;&gt; 1);</span>
 31 |     | <span class='neutral'>        return x + (int256(uint256(x) &gt;&gt; 255) &amp; (a ^ b));</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Returns the absolute unsigned value of a signed value.</span>
 36 |     | <span class='neutral'>     */</span>
 37 |     | <span class='neutral'>    function abs(int256 n) internal pure returns (uint256) {</span>
 38 |     | <span class='neutral'>        unchecked {</span>
 39 |     | <span class='neutral'>            // must be unchecked in order to support `n = type(int256).min`</span>
 40 |     | <span class='neutral'>            return uint256(n &gt;= 0 ? n : -n);</span>
 41 |     | <span class='neutral'>        }</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/contracts/Curves.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.7;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/utils/Strings.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/utils/cryptography/MerkleProof.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import &quot;./CurvesERC20.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./CurvesERC20Factory.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>import &quot;./FeeSplitter.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;./Security.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>interface CurvesErrors {</span>
  14 |     | <span class='neutral'>    // Access-related</span>
  15 |     | <span class='neutral'>    error UnauthorizedCurvesTokenSubject();</span>
  16 |     | <span class='neutral'>    // Balance-related</span>
  17 |     | <span class='neutral'>    error InsufficientPayment();</span>
  18 |     | <span class='neutral'>    error CannotSendFunds();</span>
  19 |     | <span class='neutral'>    error InsufficientBalance();</span>
  20 |     | <span class='neutral'>    // ERC20-related</span>
  21 |     | <span class='neutral'>    error InvalidERC20Metadata();</span>
  22 |     | <span class='neutral'>    error ERC20TokenAlreadyMinted();</span>
  23 |     | <span class='neutral'>    // State-related</span>
  24 |     | <span class='neutral'>    error TokenAbsentForCurvesTokenSubject();</span>
  25 |     | <span class='neutral'>    error CurveAlreadyExists();</span>
  26 |     | <span class='neutral'>    // Transaction-related</span>
  27 |     | <span class='neutral'>    error LastTokenCannotBeSold();</span>
  28 |     | <span class='neutral'>    error ContractCannotReceiveTransfer();</span>
  29 |     | <span class='neutral'>    error ExceededMaxBuyAmount();</span>
  30 |     | <span class='neutral'>    error NonIntegerDepositAmount();</span>
  31 |     | <span class='neutral'>    // Proof-related</span>
  32 |     | <span class='neutral'>    error UnverifiedProof();</span>
  33 |     | <span class='neutral'>    // Presale-related</span>
  34 |     | <span class='neutral'>    error PresaleUnavailable();</span>
  35 |     | <span class='neutral'>    error InvalidPresaleStartTime();</span>
  36 |     | <span class='neutral'>    error SaleNotOpen();</span>
  37 |     | <span class='neutral'>    // Fee related</span>
  38 |     | <span class='neutral'>    error InvalidFeeDefinition();</span>
  39 |     | <span class='neutral'>}</span>
  40 |     | <span class='neutral'></span>
  41 | *   | <span class='executed'>contract Curves is CurvesErrors, Security {</span>
  42 |     | <span class='unexecuted'>    address public curvesERC20Factory;</span>
  43 |     | <span class='unexecuted'>    FeeSplitter public feeRedistributor;</span>
  44 |     | <span class='unexecuted'>    string public constant DEFAULT_NAME = &quot;Curves&quot;;</span>
  45 |     | <span class='unexecuted'>    string public constant DEFAULT_SYMBOL = &quot;CURVES&quot;;</span>
  46 |     | <span class='neutral'>    // Counter for CURVES tokens minted</span>
  47 |     | <span class='unexecuted'>    uint256 private _curvesTokenCounter = 0;</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    struct ExternalTokenMeta {</span>
  50 |     | <span class='neutral'>        string name;</span>
  51 |     | <span class='neutral'>        string symbol;</span>
  52 |     | <span class='neutral'>        address token;</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    struct PresaleMeta {</span>
  56 |     | <span class='neutral'>        uint256 startTime;</span>
  57 |     | <span class='neutral'>        bytes32 merkleRoot;</span>
  58 |     | <span class='neutral'>        uint256 maxBuy;</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 | *   | <span class='executed'>    mapping(address =&gt; ExternalTokenMeta) public externalCurvesTokens;</span>
  62 |     | <span class='unexecuted'>    mapping(address =&gt; address) public externalCurvesToSubject;</span>
  63 |     | <span class='unexecuted'>    mapping(string =&gt; address) public symbolToSubject;</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>    mapping(address =&gt; PresaleMeta) public presalesMeta;</span>
  66 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; uint256)) public presalesBuys;</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    struct FeesEconomics {</span>
  69 |     | <span class='neutral'>        address protocolFeeDestination;</span>
  70 |     | <span class='neutral'>        uint256 protocolFeePercent;</span>
  71 |     | <span class='neutral'>        uint256 subjectFeePercent;</span>
  72 |     | <span class='neutral'>        uint256 referralFeePercent;</span>
  73 |     | <span class='neutral'>        uint256 holdersFeePercent;</span>
  74 |     | <span class='neutral'>        uint256 maxFeePercent;</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='unexecuted'>    FeesEconomics public feesEconomics;</span>
  78 |     | <span class='unexecuted'>    mapping(address =&gt; address) public referralFeeDestination;</span>
  79 |     | <span class='neutral'>    event LogUint256(string, uint256);</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    event Trade(</span>
  82 |     | <span class='neutral'>        address trader,</span>
  83 |     | <span class='neutral'>        address subject,</span>
  84 |     | <span class='neutral'>        bool isBuy,</span>
  85 |     | <span class='neutral'>        uint256 tokenAmount,</span>
  86 |     | <span class='neutral'>        uint256 ethAmount,</span>
  87 |     | <span class='neutral'>        uint256 protocolEthAmount,</span>
  88 |     | <span class='neutral'>        uint256 subjectEthAmount,</span>
  89 |     | <span class='neutral'>        uint256 supply</span>
  90 |     | <span class='neutral'>    );</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    event Transfer(address indexed curvesTokenSubject, address indexed from, address indexed to, uint256 value);</span>
  93 |     | <span class='neutral'>    event WhitelistUpdated(address indexed presale, bytes32 indexed root);</span>
  94 |     | <span class='neutral'>    event TokenDeployed(address indexed curvesTokenSubject, address indexed erc20token, string name, string symbol);</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    // TokenSubject =&gt; (Holder =&gt; Balance)</span>
  97 | *   | <span class='executed'>    mapping(address =&gt; mapping(address =&gt; uint256)) public curvesTokenBalance;</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    // TokenSubject =&gt; Supply</span>
 100 | *   | <span class='executed'>    mapping(address =&gt; uint256) public curvesTokenSupply;</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    mapping(address =&gt; address[]) private ownedCurvesTokenSubjects;</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    modifier onlyTokenSubject(address curvesTokenSubject) {</span>
 105 | *   | <span class='executed'>        if (curvesTokenSubject != msg.sender) revert UnauthorizedCurvesTokenSubject();</span>
 106 |     | <span class='neutral'>        _;</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>    constructor(address curvesERC20Factory_, address feeRedistributor_) Security() {</span>
 110 |     | <span class='unexecuted'>        curvesERC20Factory = curvesERC20Factory_;</span>
 111 |     | <span class='unexecuted'>        feeRedistributor = FeeSplitter(payable(feeRedistributor_));</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>    function setFeeRedistributor(address feeRedistributor_) external onlyOwner {</span>
 115 |     | <span class='unexecuted'>        feeRedistributor = FeeSplitter(payable(feeRedistributor_));</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>    function setMaxFeePercent(uint256 maxFeePercent_) external onlyManager {</span>
 119 |     | <span class='unexecuted'>        if (</span>
 120 |     | <span class='unexecuted'>            feesEconomics.protocolFeePercent +</span>
 121 |     | <span class='unexecuted'>                feesEconomics.subjectFeePercent +</span>
 122 |     | <span class='unexecuted'>                feesEconomics.referralFeePercent +</span>
 123 |     | <span class='unexecuted'>                feesEconomics.holdersFeePercent &gt;</span>
 124 |     | <span class='unexecuted'>            maxFeePercent_</span>
 125 |     | <span class='unexecuted'>        ) revert InvalidFeeDefinition();</span>
 126 |     | <span class='unexecuted'>        feesEconomics.maxFeePercent = maxFeePercent_;</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>    function setProtocolFeePercent(uint256 protocolFeePercent_, address protocolFeeDestination_) external onlyOwner {</span>
 130 |     | <span class='unexecuted'>        if (</span>
 131 |     | <span class='unexecuted'>            protocolFeePercent_ +</span>
 132 |     | <span class='unexecuted'>                feesEconomics.subjectFeePercent +</span>
 133 |     | <span class='unexecuted'>                feesEconomics.referralFeePercent +</span>
 134 |     | <span class='unexecuted'>                feesEconomics.holdersFeePercent &gt;</span>
 135 |     | <span class='unexecuted'>            feesEconomics.maxFeePercent ||</span>
 136 |     | <span class='unexecuted'>            protocolFeeDestination_ == address(0)</span>
 137 |     | <span class='unexecuted'>        ) revert InvalidFeeDefinition();</span>
 138 |     | <span class='unexecuted'>        feesEconomics.protocolFeePercent = protocolFeePercent_;</span>
 139 |     | <span class='unexecuted'>        feesEconomics.protocolFeeDestination = protocolFeeDestination_;</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='unexecuted'>    function setExternalFeePercent(</span>
 143 |     | <span class='neutral'>        uint256 subjectFeePercent_,</span>
 144 |     | <span class='neutral'>        uint256 referralFeePercent_,</span>
 145 |     | <span class='neutral'>        uint256 holdersFeePercent_</span>
 146 |     | <span class='neutral'>    ) external onlyManager {</span>
 147 |     | <span class='unexecuted'>        if (</span>
 148 |     | <span class='unexecuted'>            feesEconomics.protocolFeePercent + subjectFeePercent_ + referralFeePercent_ + holdersFeePercent_ &gt;</span>
 149 |     | <span class='unexecuted'>            feesEconomics.maxFeePercent</span>
 150 |     | <span class='unexecuted'>        ) revert InvalidFeeDefinition();</span>
 151 |     | <span class='unexecuted'>        feesEconomics.subjectFeePercent = subjectFeePercent_;</span>
 152 |     | <span class='unexecuted'>        feesEconomics.referralFeePercent = referralFeePercent_;</span>
 153 |     | <span class='unexecuted'>        feesEconomics.holdersFeePercent = holdersFeePercent_;</span>
 154 |     | <span class='neutral'>    }</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='unexecuted'>    function setReferralFeeDestination(</span>
 157 |     | <span class='neutral'>        address curvesTokenSubject,</span>
 158 |     | <span class='neutral'>        address referralFeeDestination_</span>
 159 |     | <span class='unexecuted'>    ) public onlyTokenSubject(curvesTokenSubject) {</span>
 160 |     | <span class='unexecuted'>        referralFeeDestination[curvesTokenSubject] = referralFeeDestination_;</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='unexecuted'>    function setERC20Factory(address factory_) external onlyOwner {</span>
 164 |     | <span class='unexecuted'>        curvesERC20Factory = factory_;</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 | *   | <span class='executed'>    function getFees(</span>
 168 |     | <span class='neutral'>        uint256 price</span>
 169 |     | <span class='neutral'>    )</span>
 170 |     | <span class='neutral'>        public</span>
 171 |     | <span class='neutral'>        view</span>
 172 | *   | <span class='executed'>        returns (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holdersFee, uint256 totalFee)</span>
 173 |     | <span class='neutral'>    {</span>
 174 | *   | <span class='executed'>        protocolFee = (price * feesEconomics.protocolFeePercent) / 1 ether;</span>
 175 | *   | <span class='executed'>        subjectFee = (price * feesEconomics.subjectFeePercent) / 1 ether;</span>
 176 | *   | <span class='executed'>        referralFee = (price * feesEconomics.referralFeePercent) / 1 ether;</span>
 177 | *   | <span class='executed'>        holdersFee = (price * feesEconomics.holdersFeePercent) / 1 ether;</span>
 178 | *   | <span class='executed'>        totalFee = protocolFee + subjectFee + referralFee + holdersFee;</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'></span>
 181 | *   | <span class='executed'>    function getPrice(uint256 supply, uint256 amount) public pure returns (uint256) {</span>
 182 | *   | <span class='executed'>        uint256 sum1 = supply == 0 ? 0 : ((supply - 1) * (supply) * (2 * (supply - 1) + 1)) / 6;</span>
 183 | *   | <span class='executed'>        uint256 sum2 = supply == 0 &amp;&amp; amount == 1</span>
 184 | *   | <span class='executed'>            ? 0</span>
 185 | *   | <span class='executed'>            : ((supply - 1 + amount) * (supply + amount) * (2 * (supply - 1 + amount) + 1)) / 6;</span>
 186 | *   | <span class='executed'>        uint256 summation = sum2 - sum1;</span>
 187 | *   | <span class='executed'>        return (summation * 1 ether) / 16000;</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='unexecuted'>    function getBuyPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) {</span>
 191 |     | <span class='unexecuted'>        return getPrice(curvesTokenSupply[curvesTokenSubject], amount);</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='unexecuted'>    function getSellPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) {</span>
 195 |     | <span class='unexecuted'>        return getPrice(curvesTokenSupply[curvesTokenSubject] - amount, amount);</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='unexecuted'>    function getBuyPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {</span>
 199 |     | <span class='unexecuted'>        uint256 price = getBuyPrice(curvesTokenSubject, amount);</span>
 200 |     | <span class='unexecuted'>        (, , , , uint256 totalFee) = getFees(price);</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='unexecuted'>        return price + totalFee;</span>
 203 |     | <span class='neutral'>    }</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='unexecuted'>    function getSellPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {</span>
 206 |     | <span class='unexecuted'>        uint256 price = getSellPrice(curvesTokenSubject, amount);</span>
 207 |     | <span class='unexecuted'>        (, , , , uint256 totalFee) = getFees(price);</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='unexecuted'>        return price - totalFee;</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 | *   | <span class='executed'>    function buyCurvesToken(address curvesTokenSubject, uint256 amount) public payable {</span>
 213 | *   | <span class='executed'>        uint256 startTime = presalesMeta[curvesTokenSubject].startTime;</span>
 214 | *   | <span class='executed'>        if (startTime != 0 &amp;&amp; startTime &gt;= block.timestamp) revert SaleNotOpen();</span>
 215 |     | <span class='neutral'></span>
 216 | *   | <span class='executed'>        _buyCurvesToken(curvesTokenSubject, amount);</span>
 217 |     | <span class='neutral'>    }</span>
 218 |     | <span class='neutral'></span>
 219 | *   | <span class='executed'>    function _transferFees(</span>
 220 |     | <span class='neutral'>        address curvesTokenSubject,</span>
 221 |     | <span class='neutral'>        bool isBuy,</span>
 222 |     | <span class='neutral'>        uint256 price,</span>
 223 |     | <span class='neutral'>        uint256 amount,</span>
 224 |     | <span class='neutral'>        uint256 supply</span>
 225 | *   | <span class='executed'>    ) internal {</span>
 226 | *   | <span class='executed'>        (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holderFee, ) = getFees(price);</span>
 227 | *   | <span class='executed'>        {</span>
 228 | *   | <span class='executed'>            bool referralDefined = referralFeeDestination[curvesTokenSubject] != address(0);</span>
 229 | *   | <span class='executed'>            {</span>
 230 | *   | <span class='executed'>                address firstDestination = isBuy ? feesEconomics.protocolFeeDestination : msg.sender;</span>
 231 | *   | <span class='executed'>                uint256 buyValue = referralDefined ? protocolFee : protocolFee + referralFee;</span>
 232 | *   | <span class='executed'>                uint256 sellValue = price - protocolFee - subjectFee - referralFee - holderFee;</span>
 233 | *   | <span class='executed'>                (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(&quot;&quot;);</span>
 234 | *   | <span class='executed'>                if (!success1) revert CannotSendFunds();</span>
 235 |     | <span class='neutral'>            }</span>
 236 | *   | <span class='executed'>            {</span>
 237 | *   | <span class='executed'>                (bool success2, ) = curvesTokenSubject.call{value: subjectFee}(&quot;&quot;);</span>
 238 | *   | <span class='executed'>                if (!success2) revert CannotSendFunds();</span>
 239 |     | <span class='neutral'>            }</span>
 240 | *   | <span class='executed'>            {</span>
 241 | *   | <span class='executed'>                (bool success3, ) = referralDefined</span>
 242 |     | <span class='unexecuted'>                    ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}(&quot;&quot;)</span>
 243 | *   | <span class='executed'>                    : (true, bytes(&quot;&quot;));</span>
 244 | *   | <span class='executed'>                if (!success3) revert CannotSendFunds();</span>
 245 |     | <span class='neutral'>            }</span>
 246 | *   | <span class='executed'>             emit LogUint256(&quot;Did we arrive here ?&quot;, 1);</span>
 247 | *   | <span class='executed'>            if (feesEconomics.holdersFeePercent &gt; 0 &amp;&amp; address(feeRedistributor) != address(0)) {</span>
 248 | *   | <span class='executed'>                             emit LogUint256(&quot;Did we arrive here ?&quot;, 2);</span>
 249 |     | <span class='neutral'></span>
 250 | *   | <span class='executed'>                feeRedistributor.onBalanceChange(curvesTokenSubject, msg.sender);</span>
 251 | *   | <span class='executed'>                             emit LogUint256(&quot;Did we arrive here ?&quot;, 3);</span>
 252 |     | <span class='neutral'></span>
 253 | *   | <span class='executed'>                feeRedistributor.addFees{value: holderFee}(curvesTokenSubject);</span>
 254 |     | <span class='neutral'>            }</span>
 255 |     | <span class='neutral'>        }</span>
 256 | *   | <span class='executed'>        emit Trade(</span>
 257 | *   | <span class='executed'>            msg.sender,</span>
 258 | *   | <span class='executed'>            curvesTokenSubject,</span>
 259 | *   | <span class='executed'>            isBuy,</span>
 260 | *   | <span class='executed'>            amount,</span>
 261 | *   | <span class='executed'>            price,</span>
 262 | *   | <span class='executed'>            protocolFee,</span>
 263 | *   | <span class='executed'>            subjectFee,</span>
 264 | *   | <span class='executed'>            isBuy ? supply + amount : supply - amount</span>
 265 |     | <span class='neutral'>        );</span>
 266 |     | <span class='neutral'>    }</span>
 267 |     | <span class='neutral'></span>
 268 | *   | <span class='executed'>    function _buyCurvesToken(address curvesTokenSubject, uint256 amount) internal {</span>
 269 | *   | <span class='executed'>        uint256 supply = curvesTokenSupply[curvesTokenSubject];</span>
 270 | *   | <span class='executed'>        if (!(supply &gt; 0 || curvesTokenSubject == msg.sender)) revert UnauthorizedCurvesTokenSubject();</span>
 271 |     | <span class='neutral'></span>
 272 | *   | <span class='executed'>        uint256 price = getPrice(supply, amount);</span>
 273 | *   | <span class='executed'>        (, , , , uint256 totalFee) = getFees(price);</span>
 274 | *   | <span class='executed'>         emit LogUint256(&quot;this is the value&quot;, msg.value);</span>
 275 | *   | <span class='executed'>          emit LogUint256(&quot;that is what we should pay.&quot;, price +totalFee);</span>
 276 | *   | <span class='executed'>        if (msg.value &lt; price + totalFee) revert InsufficientPayment();</span>
 277 |     | <span class='neutral'>        </span>
 278 | *   | <span class='executed'>        curvesTokenBalance[curvesTokenSubject][msg.sender] += amount;</span>
 279 | *   | <span class='executed'>        curvesTokenSupply[curvesTokenSubject] = supply + amount;</span>
 280 | *   | <span class='executed'>        _transferFees(curvesTokenSubject, true, price, amount, supply);</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='neutral'>        // If is the first token bought, add to the list of owned tokens</span>
 283 | *   | <span class='executed'>        if (curvesTokenBalance[curvesTokenSubject][msg.sender] - amount == 0) {</span>
 284 | *   | <span class='executed'>            _addOwnedCurvesTokenSubject(msg.sender, curvesTokenSubject);</span>
 285 |     | <span class='neutral'>        }</span>
 286 |     | <span class='neutral'>    }</span>
 287 |     | <span class='neutral'></span>
 288 | *   | <span class='executed'>    function sellCurvesToken(address curvesTokenSubject, uint256 amount) public {</span>
 289 | *   | <span class='executed'>        uint256 supply = curvesTokenSupply[curvesTokenSubject];</span>
 290 | *   | <span class='executed'>        if (supply &lt;= amount) revert LastTokenCannotBeSold();</span>
 291 | *   | <span class='executed'>        if (curvesTokenBalance[curvesTokenSubject][msg.sender] &lt; amount) revert InsufficientBalance();</span>
 292 |     | <span class='neutral'></span>
 293 | *   | <span class='executed'>        uint256 price = getPrice(supply - amount, amount);</span>
 294 |     | <span class='neutral'></span>
 295 | *   | <span class='executed'>        curvesTokenBalance[curvesTokenSubject][msg.sender] -= amount;</span>
 296 | *   | <span class='executed'>        curvesTokenSupply[curvesTokenSubject] = supply - amount;</span>
 297 |     | <span class='neutral'></span>
 298 | *   | <span class='executed'>        _transferFees(curvesTokenSubject, false, price, amount, supply);</span>
 299 |     | <span class='neutral'>    }</span>
 300 |     | <span class='neutral'></span>
 301 |     | <span class='neutral'>    // Transfers tokens from current owner to receiver. Can be used for gifting or distributing tokens.</span>
 302 |     | <span class='unexecuted'>    function transferCurvesToken(address curvesTokenSubject, address to, uint256 amount) external {</span>
 303 |     | <span class='unexecuted'>        if (to == address(this)) revert ContractCannotReceiveTransfer();</span>
 304 |     | <span class='unexecuted'>        _transfer(curvesTokenSubject, msg.sender, to, amount);</span>
 305 |     | <span class='neutral'>    }</span>
 306 |     | <span class='neutral'></span>
 307 |     | <span class='neutral'>    // Transfer the total balance of all my tokens to another address. Can be used for migrating tokens.</span>
 308 |     | <span class='unexecuted'>    function transferAllCurvesTokens(address to) external {</span>
 309 |     | <span class='unexecuted'>        if (to == address(this)) revert ContractCannotReceiveTransfer();</span>
 310 |     | <span class='unexecuted'>        address[] storage subjects = ownedCurvesTokenSubjects[msg.sender];</span>
 311 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; subjects.length; i++) {</span>
 312 |     | <span class='unexecuted'>            uint256 amount = curvesTokenBalance[subjects[i]][msg.sender];</span>
 313 |     | <span class='unexecuted'>            if (amount &gt; 0) {</span>
 314 |     | <span class='unexecuted'>                _transfer(subjects[i], msg.sender, to, amount);</span>
 315 |     | <span class='neutral'>            }</span>
 316 |     | <span class='neutral'>        }</span>
 317 |     | <span class='neutral'>    }</span>
 318 |     | <span class='neutral'></span>
 319 | *   | <span class='executed'>    function _transfer(address curvesTokenSubject, address from, address to, uint256 amount) internal {</span>
 320 | *   | <span class='executed'>        if (amount &gt; curvesTokenBalance[curvesTokenSubject][from]) revert InsufficientBalance();</span>
 321 |     | <span class='neutral'></span>
 322 |     | <span class='neutral'>        // If transferring from oneself, skip adding to the list</span>
 323 | *   | <span class='executed'>        if (from != to) {</span>
 324 | *   | <span class='executed'>            _addOwnedCurvesTokenSubject(to, curvesTokenSubject);</span>
 325 |     | <span class='neutral'>        }</span>
 326 |     | <span class='neutral'></span>
 327 | *   | <span class='executed'>        curvesTokenBalance[curvesTokenSubject][from] = curvesTokenBalance[curvesTokenSubject][from] - amount;</span>
 328 | *   | <span class='executed'>        curvesTokenBalance[curvesTokenSubject][to] = curvesTokenBalance[curvesTokenSubject][to] + amount;</span>
 329 |     | <span class='neutral'></span>
 330 | *   | <span class='executed'>        emit Transfer(curvesTokenSubject, from, to, amount);</span>
 331 |     | <span class='neutral'>    }</span>
 332 |     | <span class='neutral'></span>
 333 |     | <span class='neutral'>    // Internal function to add a curvesTokenSubject to the list if not already present</span>
 334 | *   | <span class='executed'>    function _addOwnedCurvesTokenSubject(address owner_, address curvesTokenSubject) internal {</span>
 335 | *   | <span class='executed'>        address[] storage subjects = ownedCurvesTokenSubjects[owner_];</span>
 336 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; subjects.length; i++) {</span>
 337 | *   | <span class='executed'>            if (subjects[i] == curvesTokenSubject) {</span>
 338 | *   | <span class='executed'>                return;</span>
 339 |     | <span class='neutral'>            }</span>
 340 |     | <span class='neutral'>        }</span>
 341 | *   | <span class='executed'>        subjects.push(curvesTokenSubject);</span>
 342 |     | <span class='neutral'>    }</span>
 343 |     | <span class='neutral'></span>
 344 | *   | <span class='executed'>    function _deployERC20(</span>
 345 |     | <span class='neutral'>        address curvesTokenSubject,</span>
 346 |     | <span class='neutral'>        string memory name,</span>
 347 |     | <span class='neutral'>        string memory symbol</span>
 348 | *   | <span class='executed'>    ) internal returns (address) {</span>
 349 |     | <span class='neutral'>        // If the token&#39;s symbol is CURVES, append a counter value</span>
 350 | *   | <span class='executed'>        if (keccak256(bytes(symbol)) == keccak256(bytes(DEFAULT_SYMBOL))) {</span>
 351 | *   | <span class='executed'>            _curvesTokenCounter += 1;</span>
 352 |     | <span class='neutral'>            //@audit abi.encodePacked for strings.</span>
 353 | *   | <span class='executed'>            name = string(abi.encodePacked(name, &quot; &quot;, Strings.toString(_curvesTokenCounter)));</span>
 354 | *   | <span class='executed'>            symbol = string(abi.encodePacked(symbol, Strings.toString(_curvesTokenCounter)));</span>
 355 |     | <span class='neutral'>        }</span>
 356 |     | <span class='neutral'></span>
 357 | *   | <span class='executed'>        if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();</span>
 358 |     | <span class='neutral'></span>
 359 | *   | <span class='executed'>        address tokenContract = CurvesERC20Factory(curvesERC20Factory).deploy(name, symbol, address(this));</span>
 360 |     | <span class='neutral'></span>
 361 | *   | <span class='executed'>        externalCurvesTokens[curvesTokenSubject].token = tokenContract;</span>
 362 | *   | <span class='executed'>        externalCurvesTokens[curvesTokenSubject].name = name;</span>
 363 | *   | <span class='executed'>        externalCurvesTokens[curvesTokenSubject].symbol = symbol;</span>
 364 | *   | <span class='executed'>        externalCurvesToSubject[tokenContract] = curvesTokenSubject;</span>
 365 | *   | <span class='executed'>        symbolToSubject[symbol] = curvesTokenSubject;</span>
 366 |     | <span class='neutral'></span>
 367 | *   | <span class='executed'>        emit TokenDeployed(curvesTokenSubject, tokenContract, name, symbol);</span>
 368 | *   | <span class='executed'>        return address(tokenContract);</span>
 369 |     | <span class='neutral'>    }</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='unexecuted'>    function buyCurvesTokenWithName(</span>
 372 |     | <span class='neutral'>        address curvesTokenSubject,</span>
 373 |     | <span class='neutral'>        uint256 amount,</span>
 374 |     | <span class='neutral'>        string memory name,</span>
 375 |     | <span class='neutral'>        string memory symbol</span>
 376 |     | <span class='unexecuted'>    ) public payable {</span>
 377 |     | <span class='unexecuted'>        uint256 supply = curvesTokenSupply[curvesTokenSubject];</span>
 378 |     | <span class='unexecuted'>        if (supply != 0) revert CurveAlreadyExists();</span>
 379 |     | <span class='neutral'></span>
 380 |     | <span class='unexecuted'>        _buyCurvesToken(curvesTokenSubject, amount);</span>
 381 |     | <span class='unexecuted'>        _mint(curvesTokenSubject, name, symbol);</span>
 382 |     | <span class='neutral'>    }</span>
 383 |     | <span class='neutral'></span>
 384 |     | <span class='unexecuted'>    function buyCurvesTokenForPresale(</span>
 385 |     | <span class='neutral'>        address curvesTokenSubject,</span>
 386 |     | <span class='neutral'>        uint256 amount,</span>
 387 |     | <span class='neutral'>        uint256 startTime,</span>
 388 |     | <span class='neutral'>        bytes32 merkleRoot,</span>
 389 |     | <span class='neutral'>        uint256 maxBuy</span>
 390 |     | <span class='unexecuted'>    ) public payable onlyTokenSubject(curvesTokenSubject) {</span>
 391 |     | <span class='unexecuted'>        if (startTime &lt;= block.timestamp) revert InvalidPresaleStartTime();</span>
 392 |     | <span class='unexecuted'>        uint256 supply = curvesTokenSupply[curvesTokenSubject];</span>
 393 |     | <span class='unexecuted'>        if (supply != 0) revert CurveAlreadyExists();</span>
 394 |     | <span class='unexecuted'>        presalesMeta[curvesTokenSubject].startTime = startTime;</span>
 395 |     | <span class='unexecuted'>        presalesMeta[curvesTokenSubject].merkleRoot = merkleRoot;</span>
 396 |     | <span class='unexecuted'>        presalesMeta[curvesTokenSubject].maxBuy = (maxBuy == 0 ? type(uint256).max : maxBuy);</span>
 397 |     | <span class='neutral'></span>
 398 |     | <span class='unexecuted'>        _buyCurvesToken(curvesTokenSubject, amount);</span>
 399 |     | <span class='neutral'>    }</span>
 400 |     | <span class='neutral'></span>
 401 |     | <span class='unexecuted'>    function setWhitelist(bytes32 merkleRoot) external {</span>
 402 |     | <span class='unexecuted'>        uint256 supply = curvesTokenSupply[msg.sender];</span>
 403 |     | <span class='unexecuted'>        if (supply &gt; 1) revert CurveAlreadyExists();</span>
 404 |     | <span class='neutral'></span>
 405 |     | <span class='unexecuted'>        if (presalesMeta[msg.sender].merkleRoot != merkleRoot) {</span>
 406 |     | <span class='unexecuted'>            presalesMeta[msg.sender].merkleRoot = merkleRoot;</span>
 407 |     | <span class='unexecuted'>            emit WhitelistUpdated(msg.sender, merkleRoot);</span>
 408 |     | <span class='neutral'>        }</span>
 409 |     | <span class='neutral'>    }</span>
 410 |     | <span class='neutral'></span>
 411 |     | <span class='unexecuted'>    function buyCurvesTokenWhitelisted(</span>
 412 |     | <span class='neutral'>        address curvesTokenSubject,</span>
 413 |     | <span class='neutral'>        uint256 amount,</span>
 414 |     | <span class='neutral'>        bytes32[] memory proof</span>
 415 |     | <span class='unexecuted'>    ) public payable {</span>
 416 |     | <span class='unexecuted'>        if (</span>
 417 |     | <span class='unexecuted'>            presalesMeta[curvesTokenSubject].startTime == 0 ||</span>
 418 |     | <span class='unexecuted'>            presalesMeta[curvesTokenSubject].startTime &lt;= block.timestamp</span>
 419 |     | <span class='unexecuted'>        ) revert PresaleUnavailable();</span>
 420 |     | <span class='neutral'></span>
 421 |     | <span class='unexecuted'>        presalesBuys[curvesTokenSubject][msg.sender] += amount;</span>
 422 |     | <span class='unexecuted'>        uint256 tokenBought = presalesBuys[curvesTokenSubject][msg.sender];</span>
 423 |     | <span class='unexecuted'>        if (tokenBought &gt; presalesMeta[curvesTokenSubject].maxBuy) revert ExceededMaxBuyAmount();</span>
 424 |     | <span class='neutral'></span>
 425 |     | <span class='unexecuted'>        verifyMerkle(curvesTokenSubject, msg.sender, proof);</span>
 426 |     | <span class='unexecuted'>        _buyCurvesToken(curvesTokenSubject, amount);</span>
 427 |     | <span class='neutral'>    }</span>
 428 |     | <span class='neutral'></span>
 429 |     | <span class='unexecuted'>    function verifyMerkle(address curvesTokenSubject, address caller, bytes32[] memory proof) public view {</span>
 430 |     | <span class='neutral'>        // Verify merkle proof</span>
 431 |     | <span class='unexecuted'>        bytes32 leaf = keccak256(abi.encodePacked(caller));</span>
 432 |     | <span class='unexecuted'>        if (!MerkleProof.verify(proof, presalesMeta[curvesTokenSubject].merkleRoot, leaf)) revert UnverifiedProof();</span>
 433 |     | <span class='neutral'>    }</span>
 434 |     | <span class='neutral'></span>
 435 |     | <span class='unexecuted'>    function setNameAndSymbol(</span>
 436 |     | <span class='neutral'>        address curvesTokenSubject,</span>
 437 |     | <span class='neutral'>        string memory name,</span>
 438 |     | <span class='neutral'>        string memory symbol</span>
 439 |     | <span class='unexecuted'>    ) external onlyTokenSubject(curvesTokenSubject) {</span>
 440 |     | <span class='unexecuted'>        if (externalCurvesTokens[curvesTokenSubject].token != address(0)) revert ERC20TokenAlreadyMinted();</span>
 441 |     | <span class='unexecuted'>        if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();</span>
 442 |     | <span class='unexecuted'>        externalCurvesTokens[curvesTokenSubject].name = name;</span>
 443 |     | <span class='unexecuted'>        externalCurvesTokens[curvesTokenSubject].symbol = symbol;</span>
 444 |     | <span class='neutral'>    }</span>
 445 |     | <span class='neutral'></span>
 446 | *   | <span class='executed'>    function mint(address curvesTokenSubject) external onlyTokenSubject(curvesTokenSubject) {</span>
 447 | *   | <span class='executed'>        if (</span>
 448 | *   | <span class='executed'>            keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==</span>
 449 | *   | <span class='executed'>            keccak256(abi.encodePacked(&quot;&quot;)) ||</span>
 450 |     | <span class='unexecuted'>            keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==</span>
 451 |     | <span class='unexecuted'>            keccak256(abi.encodePacked(&quot;&quot;))</span>
 452 |     | <span class='neutral'>        ) {</span>
 453 | *   | <span class='executed'>            externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME;</span>
 454 | *   | <span class='executed'>            externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL;</span>
 455 |     | <span class='neutral'>        }</span>
 456 | *   | <span class='executed'>        _mint(</span>
 457 | *   | <span class='executed'>            curvesTokenSubject,</span>
 458 | *   | <span class='executed'>            externalCurvesTokens[curvesTokenSubject].name,</span>
 459 | *   | <span class='executed'>            externalCurvesTokens[curvesTokenSubject].symbol</span>
 460 |     | <span class='neutral'>        );</span>
 461 |     | <span class='neutral'>    }</span>
 462 |     | <span class='neutral'></span>
 463 | *   | <span class='executed'>    function _mint(</span>
 464 |     | <span class='neutral'>        address curvesTokenSubject,</span>
 465 |     | <span class='neutral'>        string memory name,</span>
 466 |     | <span class='neutral'>        string memory symbol</span>
 467 | *   | <span class='executed'>    ) internal onlyTokenSubject(curvesTokenSubject) {</span>
 468 | *   | <span class='executed'>        if (externalCurvesTokens[curvesTokenSubject].token != address(0)) revert ERC20TokenAlreadyMinted();</span>
 469 | *   | <span class='executed'>        _deployERC20(curvesTokenSubject, name, symbol);</span>
 470 |     | <span class='neutral'>    }</span>
 471 |     | <span class='neutral'></span>
 472 | *   | <span class='executed'>    function withdraw(address curvesTokenSubject, uint256 amount) public {</span>
 473 | *   | <span class='executed'>        if (amount &gt; curvesTokenBalance[curvesTokenSubject][msg.sender]) revert InsufficientBalance();</span>
 474 |     | <span class='neutral'></span>
 475 | *   | <span class='executed'>        address externalToken = externalCurvesTokens[curvesTokenSubject].token;</span>
 476 | *   | <span class='executed'>        if (externalToken == address(0)) {</span>
 477 | *   | <span class='executed'>            if (</span>
 478 | *   | <span class='executed'>                keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==</span>
 479 | *   | <span class='executed'>                keccak256(abi.encodePacked(&quot;&quot;)) ||</span>
 480 |     | <span class='unexecuted'>                keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==</span>
 481 |     | <span class='unexecuted'>                keccak256(abi.encodePacked(&quot;&quot;))</span>
 482 |     | <span class='neutral'>            ) {</span>
 483 | *   | <span class='executed'>                externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME;</span>
 484 | *   | <span class='executed'>                externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL;</span>
 485 |     | <span class='neutral'>            }</span>
 486 | *   | <span class='executed'>            _deployERC20(</span>
 487 | *   | <span class='executed'>                curvesTokenSubject,</span>
 488 | *   | <span class='executed'>                externalCurvesTokens[curvesTokenSubject].name,</span>
 489 | *   | <span class='executed'>                externalCurvesTokens[curvesTokenSubject].symbol</span>
 490 |     | <span class='neutral'>            );</span>
 491 | *   | <span class='executed'>            externalToken = externalCurvesTokens[curvesTokenSubject].token;</span>
 492 |     | <span class='neutral'>        }</span>
 493 | *   | <span class='executed'>        _transfer(curvesTokenSubject, msg.sender, address(this), amount);</span>
 494 | *   | <span class='executed'>        CurvesERC20(externalToken).mint(msg.sender, amount * 1 ether);</span>
 495 |     | <span class='neutral'>    }</span>
 496 |     | <span class='neutral'></span>
 497 | *   | <span class='executed'>    function deposit(address curvesTokenSubject, uint256 amount) public {</span>
 498 | *   | <span class='executed'>        if (amount % 1 ether != 0) revert NonIntegerDepositAmount();</span>
 499 |     | <span class='neutral'></span>
 500 | *   | <span class='executed'>        address externalToken = externalCurvesTokens[curvesTokenSubject].token;</span>
 501 | *   | <span class='executed'>        uint256 tokenAmount = amount / 1 ether;</span>
 502 |     | <span class='neutral'></span>
 503 | *   | <span class='executed'>        if (externalToken == address(0)) revert TokenAbsentForCurvesTokenSubject();</span>
 504 | *   | <span class='executed'>        if (amount &gt; CurvesERC20(externalToken).balanceOf(msg.sender)) revert InsufficientBalance();</span>
 505 | *   | <span class='executed'>        if (tokenAmount &gt; curvesTokenBalance[curvesTokenSubject][address(this)]) revert InsufficientBalance();</span>
 506 |     | <span class='neutral'></span>
 507 | *   | <span class='executed'>        CurvesERC20(externalToken).burn(msg.sender, amount);</span>
 508 | *   | <span class='executed'>        _transfer(curvesTokenSubject, address(this), msg.sender, tokenAmount);</span>
 509 |     | <span class='neutral'>    }</span>
 510 |     | <span class='neutral'></span>
 511 |     | <span class='unexecuted'>    function sellExternalCurvesToken(address curvesTokenSubject, uint256 amount) public {</span>
 512 |     | <span class='unexecuted'>        if (externalCurvesTokens[curvesTokenSubject].token == address(0)) revert TokenAbsentForCurvesTokenSubject();</span>
 513 |     | <span class='neutral'></span>
 514 |     | <span class='unexecuted'>        deposit(curvesTokenSubject, amount);</span>
 515 |     | <span class='unexecuted'>        sellCurvesToken(curvesTokenSubject, amount / 1 ether);</span>
 516 |     | <span class='neutral'>    }</span>
 517 |     | <span class='neutral'>}</span>
 518 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/contracts/CurvesERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.7;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 | *   | <span class='executed'>contract CurvesERC20 is ERC20, Ownable {</span>
  8 |     | <span class='unexecuted'>    constructor(string memory name_, string memory symbol_, address owner) ERC20(name_, symbol_) {</span>
  9 |     | <span class='unexecuted'>        transferOwnership(owner);</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'></span>
 12 | *   | <span class='executed'>    function mint(address to, uint256 amount) public onlyOwner {</span>
 13 | *   | <span class='executed'>        _mint(to, amount);</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 | *   | <span class='executed'>    function burn(address from, uint256 amount) public onlyOwner {</span>
 17 | *   | <span class='executed'>        _burn(from, amount);</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/contracts/CurvesERC20Factory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.7;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./CurvesERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 | *   | <span class='executed'>contract CurvesERC20Factory {</span>
  7 | *   | <span class='executed'>    function deploy(string memory name, string memory symbol, address owner) public returns (address) {</span>
  8 | *   | <span class='executed'>        CurvesERC20 tokenContract = new CurvesERC20(name, symbol, owner);</span>
  9 | *   | <span class='executed'>        return address(tokenContract);</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'>}</span>
 12 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/contracts/EchidnaCurves.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.7;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@crytic/properties/contracts/util/PropertiesHelper.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;@crytic/properties/contracts/util/PropertiesConstants.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import &quot;@crytic/properties/contracts/util/Hevm.sol&quot;;</span>
   8 |     | <span class='neutral'>import {Curves} from &quot;./Curves.sol&quot;; </span>
   9 |     | <span class='neutral'>import {CurvesERC20} from &quot;./CurvesERC20.sol&quot;;</span>
  10 |     | <span class='neutral'>import {CurvesERC20Factory} from &quot;./CurvesERC20Factory.sol&quot;;</span>
  11 |     | <span class='neutral'>import {FeeSplitter} from &quot;./FeeSplitter.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 | *r  | <span class='executed'>contract EchidnaCurves is PropertiesAsserts, PropertiesConstants{</span>
  14 |     | <span class='neutral'>    Curves curves; </span>
  15 |     | <span class='neutral'>    FeeSplitter feeSplitter; </span>
  16 |     | <span class='neutral'>    mapping(address=&gt; bool) hasAReference; </span>
  17 |     | <span class='neutral'>    mapping(address =&gt; bool) isExternal;</span>
  18 |     | <span class='neutral'>    mapping(address=&gt; mapping(address=&gt; uint256)) amountDeposited;</span>
  19 |     | <span class='unexecuted'>    address owner= hevm.addr(666);</span>
  20 |     | <span class='neutral'>    uint256 amountExternal; </span>
  21 |     | <span class='unexecuted'>    constructor() payable {</span>
  22 |     | <span class='unexecuted'>        CurvesERC20Factory factory = new CurvesERC20Factory(); </span>
  23 |     | <span class='unexecuted'>        feeSplitter = new FeeSplitter();</span>
  24 |     | <span class='unexecuted'>        curves = new Curves(address(factory), address(feeSplitter));</span>
  25 |     | <span class='unexecuted'>        feeSplitter.setCurves(curves); </span>
  26 |     | <span class='unexecuted'>        feeSplitter.setManager(address(curves), true);</span>
  27 |     | <span class='unexecuted'>        curves.setManager(address(this), false);</span>
  28 |     | <span class='unexecuted'>        curves.transferOwnership(owner); </span>
  29 |     | <span class='unexecuted'>        hevm.prank(owner);</span>
  30 |     | <span class='unexecuted'>        curves.setManager(owner, true);</span>
  31 |     | <span class='unexecuted'>        hevm.prank(owner); </span>
  32 |     | <span class='unexecuted'>        curves.setMaxFeePercent(0.4e18);</span>
  33 |     | <span class='unexecuted'>        hevm.prank(owner); </span>
  34 |     | <span class='unexecuted'>        curves.setProtocolFeePercent(0.1e18, owner);</span>
  35 |     | <span class='unexecuted'>        hevm.prank(owner); </span>
  36 |     | <span class='unexecuted'>        curves.setExternalFeePercent(0.2e18,0,0.1e18);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    }</span>
  40 |     | <span class='neutral'></span>
  41 | *   | <span class='executed'>    function test_buyCurvesTokensForTheFirstTime(uint256 _amount) public payable  {</span>
  42 | *   | <span class='executed'>        _amount=clampBetween(_amount, 0, 100_000);</span>
  43 |     | <span class='neutral'>         </span>
  44 | *   | <span class='executed'>          uint256 supply = curves.curvesTokenSupply(msg.sender);</span>
  45 | *   | <span class='executed'>          uint256 priceBefore = curves.getPrice(supply, 1);</span>
  46 | *r  | <span class='executed'>          uint256 price = curves.getPrice(supply, _amount);</span>
  47 | *   | <span class='executed'>          (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holdersFee, uint256 totalFee) = curves.getFees(price); </span>
  48 | *   | <span class='executed'>          if(msg.value &gt; msg.sender.balance)return; </span>
  49 | *   | <span class='executed'>          if(msg.value &lt; price +totalFee) return; </span>
  50 | *   | <span class='executed'>          emit LogUint256(&quot;this is the value&quot;, msg.value);</span>
  51 | *   | <span class='executed'>          emit LogUint256(&quot;that is what we should pay.&quot;, price +totalFee);</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>          </span>
  54 | *   | <span class='executed'>        hevm.prank(msg.sender); </span>
  55 | *   | <span class='executed'>        try curves.buyCurvesToken{value: msg.value }(msg.sender, _amount){</span>
  56 | *   | <span class='executed'>            uint256 supplyAfter = curves.curvesTokenSupply(msg.sender);</span>
  57 | *   | <span class='executed'>            uint256 priceAfter = curves.getPrice(supplyAfter, 1);</span>
  58 | *   | <span class='executed'>            assertEq(supplyAfter, supply+_amount, &quot;Supply didn&#39;t increase&quot;);</span>
  59 | *   | <span class='executed'>            assertGte(priceAfter, priceBefore, &quot;price should increase&quot;); </span>
  60 | *   | <span class='executed'>            hasAReference[msg.sender]= true; </span>
  61 | *   | <span class='executed'>            amountDeposited[msg.sender][msg.sender]+=_amount; </span>
  62 |     | <span class='neutral'>        } catch {</span>
  63 | *   | <span class='executed'>        assertWithMsg(false, &quot;buyCurvesToken should not revert.&quot;);</span>
  64 |     | <span class='neutral'>        }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>        }</span>
  67 | *   | <span class='executed'>        function test_buyCurvesTokensForUser(uint256 _amount, uint256 _whichUser) external payable  {</span>
  68 | *   | <span class='executed'>         _whichUser = clampBetween(_whichUser, 1,3); </span>
  69 | *   | <span class='executed'>         address user = _chooseUser(_whichUser); </span>
  70 | *   | <span class='executed'>         if(!hasAReference[user])return; </span>
  71 | *   | <span class='executed'>         _amount=clampBetween(_amount, 0, 100_000);</span>
  72 |     | <span class='neutral'>      </span>
  73 | *   | <span class='executed'>          uint256 supply = curves.curvesTokenSupply(user);</span>
  74 | *   | <span class='executed'>            uint256 priceBefore = curves.getPrice(supply, 1);</span>
  75 |     | <span class='neutral'></span>
  76 | *   | <span class='executed'>          uint256 price = curves.getPrice(supply, _amount);</span>
  77 | *   | <span class='executed'>          (, , , , uint256 totalFee) = curves.getFees(price);</span>
  78 | *   | <span class='executed'>          if(msg.value &gt; msg.sender.balance)return; </span>
  79 | *   | <span class='executed'>          if(msg.value &lt; price +totalFee) return; </span>
  80 | *   | <span class='executed'>           hevm.prank(msg.sender); </span>
  81 | *   | <span class='executed'>        try curves.buyCurvesToken{value: msg.value }(user, _amount){</span>
  82 | *   | <span class='executed'>         uint256 supplyAfter = curves.curvesTokenSupply(user);</span>
  83 | *   | <span class='executed'>            uint256 priceAfter = curves.getPrice(supplyAfter, 1);</span>
  84 |     | <span class='neutral'></span>
  85 | *   | <span class='executed'>            assertEq(supplyAfter, supply+_amount, &quot;Supply didn&#39;t increase&quot;);</span>
  86 | *   | <span class='executed'>            if(supplyAfter&gt;supply){</span>
  87 | *   | <span class='executed'>            assertGt(priceAfter, priceBefore, &quot;price should increase&quot;);</span>
  88 |     | <span class='neutral'>            } else {</span>
  89 | *   | <span class='executed'>            assertEq(priceAfter, priceBefore, &quot;price should be egal&quot;);</span>
  90 |     | <span class='neutral'>            }</span>
  91 | *   | <span class='executed'>            assertEq(curves.curvesTokenBalance(user, USER1)+curves.curvesTokenBalance(user, USER2)+curves.curvesTokenBalance(user, USER3)+curves.curvesTokenBalance(user, address(curves)), supplyAfter, &quot;The amount should be right&quot;);</span>
  92 | *   | <span class='executed'>            amountDeposited[user][msg.sender]+=_amount; </span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>        } catch {</span>
  95 | *   | <span class='executed'>        assertWithMsg(false, &quot;buyCurvesToken should not revert.&quot;);</span>
  96 |     | <span class='neutral'>        }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>        }</span>
  99 |     | <span class='neutral'> </span>
 100 | *   | <span class='executed'> function test_sellCurvesTokens(uint256 _whichUser, uint256 _amount ) external {</span>
 101 | *   | <span class='executed'>    _whichUser = clampBetween(_whichUser, 1,3); </span>
 102 | *   | <span class='executed'>         address user = _chooseUser(_whichUser); </span>
 103 | *   | <span class='executed'>         if(!hasAReference[user])return; </span>
 104 | *   | <span class='executed'>         uint256 balancBefore = curves.curvesTokenBalance(user, msg.sender);</span>
 105 | *   | <span class='executed'>         uint256 supply = curves.curvesTokenSupply(user);</span>
 106 | *   | <span class='executed'>                     uint256 priceBefore = curves.getPrice(supply, 1);</span>
 107 | *   | <span class='executed'>    _amount = clampBetween(_amount,0,balancBefore);</span>
 108 | *   | <span class='executed'>    _amount = clampBetween(_amount,0,supply-1);</span>
 109 | *   | <span class='executed'>    uint256 _userBalanceBefore = msg.sender.balance;</span>
 110 | *   | <span class='executed'>    if(balancBefore ==0) return;</span>
 111 | *   | <span class='executed'>    hevm.prank(msg.sender);</span>
 112 | *   | <span class='executed'>    try curves.sellCurvesToken(user,_amount){</span>
 113 | *   | <span class='executed'>        uint256 _userBalanceAfter = msg.sender.balance;</span>
 114 | *   | <span class='executed'>         uint256 supplyAfter = curves.curvesTokenSupply(user);</span>
 115 | *   | <span class='executed'>         uint256 priceAfter = curves.getPrice(supplyAfter, 1);</span>
 116 | *   | <span class='executed'>          assertEq(supplyAfter, supply-_amount, &quot;Supply didn&#39;t decrease&quot;);</span>
 117 | *   | <span class='executed'>          if(supplyAfter&lt;supply){</span>
 118 | *   | <span class='executed'>            assertLt(priceAfter, priceBefore, &quot;price should decrease&quot;);</span>
 119 |     | <span class='neutral'>            } else {</span>
 120 | *   | <span class='executed'>            assertEq(priceAfter, priceBefore, &quot;price should be egal&quot;);</span>
 121 |     | <span class='neutral'>            }</span>
 122 | *   | <span class='executed'>            assertEq(curves.curvesTokenBalance(user, USER1)+curves.curvesTokenBalance(user, USER2)+curves.curvesTokenBalance(user, USER3)+curves.curvesTokenBalance(user, address(curves)), supplyAfter, &quot;The amount should be right&quot;);</span>
 123 | *   | <span class='executed'>            assertGte(_userBalanceAfter,_userBalanceBefore, &quot;the user didn&#39;t get ETH&quot;);</span>
 124 | *   | <span class='executed'>            amountDeposited[user][msg.sender]-=_amount; </span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    }catch {</span>
 127 | *   | <span class='executed'>        assertWithMsg(false, &quot;sellCurvesToken should not revert.&quot;);</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'> }</span>
 132 | *   | <span class='executed'> function test_mint() external {</span>
 133 | *   | <span class='executed'>if( !hasAReference[msg.sender])return; </span>
 134 | *   | <span class='executed'>if(isExternal[msg.sender]) return;</span>
 135 | *   | <span class='executed'>hevm.prank(msg.sender); </span>
 136 | *   | <span class='executed'>try curves.mint(msg.sender) {</span>
 137 | *   | <span class='executed'>    isExternal[msg.sender] = true; </span>
 138 |     | <span class='neutral'>} catch {</span>
 139 |     | <span class='unexecuted'>assertWithMsg(false, &quot;Should not revert.&quot;);</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>}</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'> }</span>
 144 | *   | <span class='executed'>function test_withdraw(uint256 _amount, uint256 _whichUser) external {</span>
 145 | *   | <span class='executed'>_whichUser = clampBetween(_whichUser, 1,3); </span>
 146 | *   | <span class='executed'>address user = _chooseUser(_whichUser); </span>
 147 | *   | <span class='executed'>uint256 ERC20BalanceBefore;</span>
 148 | *   | <span class='executed'>bool wasExternal = isExternal[user];</span>
 149 | *   | <span class='executed'> (,,address tokenAddressBefore) = curves.externalCurvesTokens(user);</span>
 150 | *   | <span class='executed'>if(wasExternal) {</span>
 151 | *   | <span class='executed'>    ERC20BalanceBefore =CurvesERC20(tokenAddressBefore).balanceOf(msg.sender);</span>
 152 |     | <span class='neutral'>}</span>
 153 | *   | <span class='executed'> if(!hasAReference[user])return; </span>
 154 | *   | <span class='executed'>         uint256 balancBefore = curves.curvesTokenBalance(user, msg.sender);</span>
 155 | *   | <span class='executed'>         uint256 supply = curves.curvesTokenSupply(user);</span>
 156 | *   | <span class='executed'> _amount = clampBetween(_amount,0,balancBefore);</span>
 157 | *   | <span class='executed'>hevm.prank(msg.sender);</span>
 158 | *   | <span class='executed'> try curves.withdraw(user, _amount) {</span>
 159 | *   | <span class='executed'>        isExternal[user] = true; </span>
 160 | *   | <span class='executed'>        (,,address tokenAddress) = curves.externalCurvesTokens(user);</span>
 161 | *   | <span class='executed'>        assertWithMsg(tokenAddress!= address(0), &quot;Token wasn&#39;t deployed&quot;);</span>
 162 | *   | <span class='executed'>        if(wasExternal) {</span>
 163 | *   | <span class='executed'>        assertEq(CurvesERC20(tokenAddress).balanceOf(msg.sender),ERC20BalanceBefore + _amount*1 ether, &quot;The user didn&#39;t receive the tokens.&quot;); </span>
 164 |     | <span class='neutral'>        }</span>
 165 | *   | <span class='executed'>        amountExternal+= _amount; </span>
 166 | *   | <span class='executed'>        assertEq(amountExternal, curves.curvesTokenBalance(USER2, address(curves))+ curves.curvesTokenBalance(USER3, address(curves))+curves.curvesTokenBalance(USER1, address(curves)), &quot;Some amount was gained&quot;);</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'> } catch {</span>
 169 |     | <span class='unexecuted'>    assertWithMsg(false, &quot;Should not revert.&quot;);</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'> }</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>}</span>
 175 | *   | <span class='executed'>        function test_deposit(uint256 _whichUser, uint256 _amount) external {</span>
 176 | *   | <span class='executed'>            _whichUser = clampBetween(_whichUser, 1,3); </span>
 177 | *   | <span class='executed'>            address user = _chooseUser(_whichUser); </span>
 178 | *   | <span class='executed'>            uint256 ERC20BalanceBefore;</span>
 179 | *   | <span class='executed'>            bool wasExternal = isExternal[user];</span>
 180 | *   | <span class='executed'>            (,,address tokenAddressBefore) = curves.externalCurvesTokens(user);</span>
 181 | *   | <span class='executed'>            if(wasExternal) {</span>
 182 | *   | <span class='executed'>             ERC20BalanceBefore =CurvesERC20(tokenAddressBefore).balanceOf(msg.sender);</span>
 183 |     | <span class='neutral'>            }</span>
 184 | *   | <span class='executed'>        if(!hasAReference[user])return; </span>
 185 | *   | <span class='executed'>        if(!wasExternal)return;</span>
 186 | *   | <span class='executed'>        _amount= clampBetween(_amount,0,amountExternal);</span>
 187 | *   | <span class='executed'>        hevm.prank(msg.sender); </span>
 188 | *   | <span class='executed'>        try curves.deposit(user, _amount*1 ether) {</span>
 189 | *   | <span class='executed'>        (,,address tokenAddress) = curves.externalCurvesTokens(user);</span>
 190 | *   | <span class='executed'>        amountExternal-= _amount; </span>
 191 |     | <span class='neutral'></span>
 192 | *   | <span class='executed'>        assertEq(CurvesERC20(tokenAddress).balanceOf(msg.sender),ERC20BalanceBefore + _amount*1 ether, &quot;The user didn&#39;t receive the tokens.&quot;); </span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>        } catch {    </span>
 195 | *   | <span class='executed'>            assertWithMsg(false, &quot;Should not revert.&quot;);</span>
 196 |     | <span class='neutral'>}</span>
 197 |     | <span class='neutral'>        }</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='neutral'></span>
 200 | *   | <span class='executed'>        function test_claimFees(uint256 _whichUser) external {</span>
 201 | *   | <span class='executed'>            _whichUser = clampBetween(_whichUser, 1,3); </span>
 202 | *   | <span class='executed'>            address user = _chooseUser(_whichUser); </span>
 203 | *   | <span class='executed'>           uint256 feesClaimable = feeSplitter.getClaimableFees(user, msg.sender); </span>
 204 | *   | <span class='executed'>           if(feesClaimable ==0)return; </span>
 205 | *   | <span class='executed'>            hevm.prank(msg.sender); </span>
 206 | *   | <span class='executed'>            try feeSplitter.claimFees(user) {} catch {</span>
 207 |     | <span class='unexecuted'>            assertWithMsg(false, &quot;Should not revert.&quot;);</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>            }</span>
 210 |     | <span class='neutral'>        }</span>
 211 | *   | <span class='executed'>        function _chooseUser(uint256 _whichUser) internal pure returns(address user){</span>
 212 | *   | <span class='executed'>         if(_whichUser==1) user= USER1;</span>
 213 | *   | <span class='executed'>         if(_whichUser==2)user= USER2;</span>
 214 | *   | <span class='executed'>         if(_whichUser==3)user= USER3;</span>
 215 |     | <span class='neutral'>        }</span>
 216 |     | <span class='neutral'>        receive() payable external {}</span>
 217 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/contracts/FeeSplitter.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.7;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./Curves.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./Security.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 | *   | <span class='executed'>contract FeeSplitter is Security {</span>
  10 |     | <span class='unexecuted'>    Curves public curves;</span>
  11 | *   | <span class='executed'>    uint256 constant PRECISION = 1e18;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    // Custom errors</span>
  14 |     | <span class='neutral'>    error NoFeesToClaim();</span>
  15 |     | <span class='neutral'>    error NoTokenHolders();</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    struct TokenData {</span>
  18 |     | <span class='neutral'>        uint256 cumulativeFeePerToken;</span>
  19 |     | <span class='neutral'>        mapping(address =&gt; uint256) userFeeOffset;</span>
  20 |     | <span class='neutral'>        mapping(address =&gt; uint256) unclaimedFees;</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    struct UserClaimData {</span>
  24 |     | <span class='neutral'>        uint256 claimableFees;</span>
  25 |     | <span class='neutral'>        address token;</span>
  26 |     | <span class='neutral'>    }</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    mapping(address =&gt; TokenData) internal tokensData;</span>
  29 |     | <span class='neutral'>    mapping(address =&gt; address[]) internal userTokens;</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    event FeesClaimed(address indexed token, address indexed user, uint256 amount);</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='unexecuted'>    constructor() Security() {}</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>    function setCurves(Curves curves_) public {</span>
  36 |     | <span class='unexecuted'>        curves = curves_;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 | *   | <span class='executed'>    function balanceOf(address token, address account) public view returns (uint256) {</span>
  40 | *   | <span class='executed'>        return curves.curvesTokenBalance(token, account) * PRECISION;</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 | *   | <span class='executed'>    function totalSupply(address token) public view returns (uint256) {</span>
  44 |     | <span class='neutral'>        //@dev: this is the amount of tokens that are not locked in the contract. The locked tokens are in the ERC20 contract</span>
  45 | *   | <span class='executed'>        return (curves.curvesTokenSupply(token) - curves.curvesTokenBalance(token, address(curves))) * PRECISION;</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>    function getUserTokens(address user) public view returns (address[] memory) {</span>
  49 |     | <span class='unexecuted'>        return userTokens[user];</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='unexecuted'>    function getUserTokensAndClaimable(address user) public view returns (UserClaimData[] memory) {</span>
  53 |     | <span class='unexecuted'>        address[] memory tokens = getUserTokens(user);</span>
  54 |     | <span class='unexecuted'>        UserClaimData[] memory result = new UserClaimData[](tokens.length);</span>
  55 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; tokens.length; i++) {</span>
  56 |     | <span class='unexecuted'>            address token = tokens[i];</span>
  57 |     | <span class='unexecuted'>            uint256 claimable = getClaimableFees(token, user);</span>
  58 |     | <span class='unexecuted'>            result[i] = UserClaimData(claimable, token);</span>
  59 |     | <span class='neutral'>        }</span>
  60 |     | <span class='unexecuted'>        return result;</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 | *   | <span class='executed'>    function updateFeeCredit(address token, address account) internal {</span>
  64 | *   | <span class='executed'>        TokenData storage data = tokensData[token];</span>
  65 | *   | <span class='executed'>        uint256 balance = balanceOf(token, account);</span>
  66 | *   | <span class='executed'>        if (balance &gt; 0) {</span>
  67 |     | <span class='neutral'>            //@audit problem here.</span>
  68 | *   | <span class='executed'>            uint256 owed = (data.cumulativeFeePerToken - data.userFeeOffset[account]) * balance;</span>
  69 | *   | <span class='executed'>            data.unclaimedFees[account] += owed / PRECISION;</span>
  70 | *   | <span class='executed'>            data.userFeeOffset[account] = data.cumulativeFeePerToken;</span>
  71 |     | <span class='neutral'>        }</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 | *   | <span class='executed'>    function getClaimableFees(address token, address account) public view returns (uint256) {</span>
  75 | *   | <span class='executed'>        TokenData storage data = tokensData[token];</span>
  76 | *   | <span class='executed'>        uint256 balance = balanceOf(token, account);</span>
  77 | *   | <span class='executed'>        uint256 owed = (data.cumulativeFeePerToken - data.userFeeOffset[account]) * balance;</span>
  78 | *   | <span class='executed'>        return (owed / PRECISION) + data.unclaimedFees[account];</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 | *   | <span class='executed'>    function claimFees(address token) external {</span>
  82 | *   | <span class='executed'>        updateFeeCredit(token, msg.sender);</span>
  83 | *   | <span class='executed'>        uint256 claimable = getClaimableFees(token, msg.sender);</span>
  84 | *   | <span class='executed'>        if (claimable == 0) revert NoFeesToClaim();</span>
  85 | *   | <span class='executed'>        tokensData[token].unclaimedFees[msg.sender] = 0;</span>
  86 | *   | <span class='executed'>        payable(msg.sender).transfer(claimable);</span>
  87 | *   | <span class='executed'>        emit FeesClaimed(token, msg.sender, claimable);</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 | *   | <span class='executed'>    function addFees(address token) public payable onlyManager {</span>
  91 | *   | <span class='executed'>        uint256 totalSupply_ = totalSupply(token);</span>
  92 | *   | <span class='executed'>        if (totalSupply_ == 0) revert NoTokenHolders();</span>
  93 | *   | <span class='executed'>        TokenData storage data = tokensData[token];</span>
  94 | *   | <span class='executed'>        data.cumulativeFeePerToken += (msg.value * PRECISION) / totalSupply_;</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 | *   | <span class='executed'>    function onBalanceChange(address token, address account) public onlyManager {</span>
  98 | *   | <span class='executed'>        TokenData storage data = tokensData[token];</span>
  99 | *   | <span class='executed'>        data.userFeeOffset[account] = data.cumulativeFeePerToken;</span>
 100 | *   | <span class='executed'>        if (balanceOf(token, account) &gt; 0) userTokens[account].push(token);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    //@dev: this may fail if the the list is long. Get first the list with getUserTokens to estimate and prepare the batch</span>
 104 |     | <span class='unexecuted'>    function batchClaiming(address[] calldata tokenList) external {</span>
 105 |     | <span class='unexecuted'>        uint256 totalClaimable = 0;</span>
 106 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; tokenList.length; i++) {</span>
 107 |     | <span class='unexecuted'>            address token = tokenList[i];</span>
 108 |     | <span class='unexecuted'>            updateFeeCredit(token, msg.sender);</span>
 109 |     | <span class='unexecuted'>            uint256 claimable = getClaimableFees(token, msg.sender);</span>
 110 |     | <span class='unexecuted'>            if (claimable &gt; 0) {</span>
 111 |     | <span class='unexecuted'>                tokensData[token].unclaimedFees[msg.sender] = 0;</span>
 112 |     | <span class='unexecuted'>                totalClaimable += claimable;</span>
 113 |     | <span class='unexecuted'>                emit FeesClaimed(token, msg.sender, claimable);</span>
 114 |     | <span class='neutral'>            }</span>
 115 |     | <span class='neutral'>        }</span>
 116 |     | <span class='unexecuted'>        if (totalClaimable == 0) revert NoFeesToClaim();</span>
 117 |     | <span class='unexecuted'>        payable(msg.sender).transfer(totalClaimable);</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>    receive() external payable {}</span>
 121 |     | <span class='neutral'>}</span>
 122 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/contracts/Security.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.7;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>contract Security {</span>
  5 |     | <span class='unexecuted'>    address public owner;</span>
  6 |     | <span class='unexecuted'>    mapping(address =&gt; bool) public managers;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    modifier onlyOwner() {</span>
  9 |     | <span class='unexecuted'>        msg.sender == owner;</span>
 10 |     | <span class='neutral'>        _;</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    modifier onlyManager() {</span>
 14 | *   | <span class='executed'>        managers[msg.sender] == true;</span>
 15 |     | <span class='neutral'>        _;</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='unexecuted'>    constructor() {</span>
 19 |     | <span class='unexecuted'>        owner = msg.sender;</span>
 20 |     | <span class='unexecuted'>        managers[msg.sender] = true;</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    function setManager(address manager_, bool value) public onlyOwner {</span>
 24 |     | <span class='unexecuted'>        managers[manager_] = value;</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function transferOwnership(address owner_) public onlyOwner {</span>
 28 |     | <span class='unexecuted'>        owner = owner_;</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'>}</span>
 31 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/contracts/Test/MockCurvesForFee.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.7;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;hardhat/console.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>contract MockCurvesForFee {</span>
  9 |     | <span class='unexecuted'>    function curvesTokenBalance(address token, address account) public view returns (uint256) {</span>
 10 |     | <span class='unexecuted'>        return IERC20(token).balanceOf(account);</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>    function curvesTokenSupply(address token) public view returns (uint256) {</span>
 14 |     | <span class='unexecuted'>        return IERC20(token).totalSupply();</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'>}</span>
 17 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/contracts/Test/MockERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.7;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>contract MockERC20 is ERC20 {</span>
  7 |     | <span class='neutral'>    uint8 private _decimals;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>    constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_) {</span>
 10 |     | <span class='unexecuted'>        _decimals = decimals_;</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>    function mint(address account, uint256 amount) public {</span>
 14 |     | <span class='unexecuted'>        _mint(account, amount);</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    function burn(address account, uint256 amount) public {</span>
 18 |     | <span class='unexecuted'>        _burn(account, amount);</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>    function decimals() public view virtual override returns (uint8) {</span>
 22 |     | <span class='unexecuted'>        return _decimals;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/youssefaboutika/Desktop/Curves audit/2024-01-curves/node_modules/hardhat/console.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='unexecuted'>library console {</span>
    5 |     | <span class='neutral'>    address constant CONSOLE_ADDRESS =</span>
    6 |     | <span class='neutral'>        0x000000000000000000636F6e736F6c652e6c6f67;</span>
    7 |     | <span class='neutral'></span>
    8 |     | <span class='neutral'>    function _sendLogPayloadImplementation(bytes memory payload) internal view {</span>
    9 |     | <span class='neutral'>        address consoleAddress = CONSOLE_ADDRESS;</span>
   10 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   11 |     | <span class='neutral'>        assembly {</span>
   12 |     | <span class='neutral'>            pop(</span>
   13 |     | <span class='neutral'>                staticcall(</span>
   14 |     | <span class='neutral'>                    gas(),</span>
   15 |     | <span class='neutral'>                    consoleAddress,</span>
   16 |     | <span class='neutral'>                    add(payload, 32),</span>
   17 |     | <span class='neutral'>                    mload(payload),</span>
   18 |     | <span class='neutral'>                    0,</span>
   19 |     | <span class='neutral'>                    0</span>
   20 |     | <span class='neutral'>                )</span>
   21 |     | <span class='neutral'>            )</span>
   22 |     | <span class='neutral'>        }</span>
   23 |     | <span class='neutral'>    }</span>
   24 |     | <span class='neutral'></span>
   25 |     | <span class='neutral'>    function _castToPure(</span>
   26 |     | <span class='neutral'>      function(bytes memory) internal view fnIn</span>
   27 |     | <span class='neutral'>    ) internal pure returns (function(bytes memory) pure fnOut) {</span>
   28 |     | <span class='neutral'>        assembly {</span>
   29 |     | <span class='neutral'>            fnOut := fnIn</span>
   30 |     | <span class='neutral'>        }</span>
   31 |     | <span class='neutral'>    }</span>
   32 |     | <span class='neutral'></span>
   33 |     | <span class='neutral'>    function _sendLogPayload(bytes memory payload) internal pure {</span>
   34 |     | <span class='neutral'>        _castToPure(_sendLogPayloadImplementation)(payload);</span>
   35 |     | <span class='neutral'>    }</span>
   36 |     | <span class='neutral'></span>
   37 |     | <span class='neutral'>    function log() internal pure {</span>
   38 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log()&quot;));</span>
   39 |     | <span class='neutral'>    }</span>
   40 |     | <span class='neutral'>    function logInt(int256 p0) internal pure {</span>
   41 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(int256)&quot;, p0));</span>
   42 |     | <span class='neutral'>    }</span>
   43 |     | <span class='neutral'></span>
   44 |     | <span class='neutral'>    function logUint(uint256 p0) internal pure {</span>
   45 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256)&quot;, p0));</span>
   46 |     | <span class='neutral'>    }</span>
   47 |     | <span class='neutral'></span>
   48 |     | <span class='neutral'>    function logString(string memory p0) internal pure {</span>
   49 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
   50 |     | <span class='neutral'>    }</span>
   51 |     | <span class='neutral'></span>
   52 |     | <span class='neutral'>    function logBool(bool p0) internal pure {</span>
   53 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
   54 |     | <span class='neutral'>    }</span>
   55 |     | <span class='neutral'></span>
   56 |     | <span class='neutral'>    function logAddress(address p0) internal pure {</span>
   57 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
   58 |     | <span class='neutral'>    }</span>
   59 |     | <span class='neutral'></span>
   60 |     | <span class='neutral'>    function logBytes(bytes memory p0) internal pure {</span>
   61 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes)&quot;, p0));</span>
   62 |     | <span class='neutral'>    }</span>
   63 |     | <span class='neutral'></span>
   64 |     | <span class='neutral'>    function logBytes1(bytes1 p0) internal pure {</span>
   65 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes1)&quot;, p0));</span>
   66 |     | <span class='neutral'>    }</span>
   67 |     | <span class='neutral'></span>
   68 |     | <span class='neutral'>    function logBytes2(bytes2 p0) internal pure {</span>
   69 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes2)&quot;, p0));</span>
   70 |     | <span class='neutral'>    }</span>
   71 |     | <span class='neutral'></span>
   72 |     | <span class='neutral'>    function logBytes3(bytes3 p0) internal pure {</span>
   73 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes3)&quot;, p0));</span>
   74 |     | <span class='neutral'>    }</span>
   75 |     | <span class='neutral'></span>
   76 |     | <span class='neutral'>    function logBytes4(bytes4 p0) internal pure {</span>
   77 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes4)&quot;, p0));</span>
   78 |     | <span class='neutral'>    }</span>
   79 |     | <span class='neutral'></span>
   80 |     | <span class='neutral'>    function logBytes5(bytes5 p0) internal pure {</span>
   81 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes5)&quot;, p0));</span>
   82 |     | <span class='neutral'>    }</span>
   83 |     | <span class='neutral'></span>
   84 |     | <span class='neutral'>    function logBytes6(bytes6 p0) internal pure {</span>
   85 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes6)&quot;, p0));</span>
   86 |     | <span class='neutral'>    }</span>
   87 |     | <span class='neutral'></span>
   88 |     | <span class='neutral'>    function logBytes7(bytes7 p0) internal pure {</span>
   89 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes7)&quot;, p0));</span>
   90 |     | <span class='neutral'>    }</span>
   91 |     | <span class='neutral'></span>
   92 |     | <span class='neutral'>    function logBytes8(bytes8 p0) internal pure {</span>
   93 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes8)&quot;, p0));</span>
   94 |     | <span class='neutral'>    }</span>
   95 |     | <span class='neutral'></span>
   96 |     | <span class='neutral'>    function logBytes9(bytes9 p0) internal pure {</span>
   97 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes9)&quot;, p0));</span>
   98 |     | <span class='neutral'>    }</span>
   99 |     | <span class='neutral'></span>
  100 |     | <span class='neutral'>    function logBytes10(bytes10 p0) internal pure {</span>
  101 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes10)&quot;, p0));</span>
  102 |     | <span class='neutral'>    }</span>
  103 |     | <span class='neutral'></span>
  104 |     | <span class='neutral'>    function logBytes11(bytes11 p0) internal pure {</span>
  105 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes11)&quot;, p0));</span>
  106 |     | <span class='neutral'>    }</span>
  107 |     | <span class='neutral'></span>
  108 |     | <span class='neutral'>    function logBytes12(bytes12 p0) internal pure {</span>
  109 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes12)&quot;, p0));</span>
  110 |     | <span class='neutral'>    }</span>
  111 |     | <span class='neutral'></span>
  112 |     | <span class='neutral'>    function logBytes13(bytes13 p0) internal pure {</span>
  113 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes13)&quot;, p0));</span>
  114 |     | <span class='neutral'>    }</span>
  115 |     | <span class='neutral'></span>
  116 |     | <span class='neutral'>    function logBytes14(bytes14 p0) internal pure {</span>
  117 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes14)&quot;, p0));</span>
  118 |     | <span class='neutral'>    }</span>
  119 |     | <span class='neutral'></span>
  120 |     | <span class='neutral'>    function logBytes15(bytes15 p0) internal pure {</span>
  121 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes15)&quot;, p0));</span>
  122 |     | <span class='neutral'>    }</span>
  123 |     | <span class='neutral'></span>
  124 |     | <span class='neutral'>    function logBytes16(bytes16 p0) internal pure {</span>
  125 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes16)&quot;, p0));</span>
  126 |     | <span class='neutral'>    }</span>
  127 |     | <span class='neutral'></span>
  128 |     | <span class='neutral'>    function logBytes17(bytes17 p0) internal pure {</span>
  129 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes17)&quot;, p0));</span>
  130 |     | <span class='neutral'>    }</span>
  131 |     | <span class='neutral'></span>
  132 |     | <span class='neutral'>    function logBytes18(bytes18 p0) internal pure {</span>
  133 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes18)&quot;, p0));</span>
  134 |     | <span class='neutral'>    }</span>
  135 |     | <span class='neutral'></span>
  136 |     | <span class='neutral'>    function logBytes19(bytes19 p0) internal pure {</span>
  137 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes19)&quot;, p0));</span>
  138 |     | <span class='neutral'>    }</span>
  139 |     | <span class='neutral'></span>
  140 |     | <span class='neutral'>    function logBytes20(bytes20 p0) internal pure {</span>
  141 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes20)&quot;, p0));</span>
  142 |     | <span class='neutral'>    }</span>
  143 |     | <span class='neutral'></span>
  144 |     | <span class='neutral'>    function logBytes21(bytes21 p0) internal pure {</span>
  145 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes21)&quot;, p0));</span>
  146 |     | <span class='neutral'>    }</span>
  147 |     | <span class='neutral'></span>
  148 |     | <span class='neutral'>    function logBytes22(bytes22 p0) internal pure {</span>
  149 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes22)&quot;, p0));</span>
  150 |     | <span class='neutral'>    }</span>
  151 |     | <span class='neutral'></span>
  152 |     | <span class='neutral'>    function logBytes23(bytes23 p0) internal pure {</span>
  153 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes23)&quot;, p0));</span>
  154 |     | <span class='neutral'>    }</span>
  155 |     | <span class='neutral'></span>
  156 |     | <span class='neutral'>    function logBytes24(bytes24 p0) internal pure {</span>
  157 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes24)&quot;, p0));</span>
  158 |     | <span class='neutral'>    }</span>
  159 |     | <span class='neutral'></span>
  160 |     | <span class='neutral'>    function logBytes25(bytes25 p0) internal pure {</span>
  161 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes25)&quot;, p0));</span>
  162 |     | <span class='neutral'>    }</span>
  163 |     | <span class='neutral'></span>
  164 |     | <span class='neutral'>    function logBytes26(bytes26 p0) internal pure {</span>
  165 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes26)&quot;, p0));</span>
  166 |     | <span class='neutral'>    }</span>
  167 |     | <span class='neutral'></span>
  168 |     | <span class='neutral'>    function logBytes27(bytes27 p0) internal pure {</span>
  169 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes27)&quot;, p0));</span>
  170 |     | <span class='neutral'>    }</span>
  171 |     | <span class='neutral'></span>
  172 |     | <span class='neutral'>    function logBytes28(bytes28 p0) internal pure {</span>
  173 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes28)&quot;, p0));</span>
  174 |     | <span class='neutral'>    }</span>
  175 |     | <span class='neutral'></span>
  176 |     | <span class='neutral'>    function logBytes29(bytes29 p0) internal pure {</span>
  177 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes29)&quot;, p0));</span>
  178 |     | <span class='neutral'>    }</span>
  179 |     | <span class='neutral'></span>
  180 |     | <span class='neutral'>    function logBytes30(bytes30 p0) internal pure {</span>
  181 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes30)&quot;, p0));</span>
  182 |     | <span class='neutral'>    }</span>
  183 |     | <span class='neutral'></span>
  184 |     | <span class='neutral'>    function logBytes31(bytes31 p0) internal pure {</span>
  185 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes31)&quot;, p0));</span>
  186 |     | <span class='neutral'>    }</span>
  187 |     | <span class='neutral'></span>
  188 |     | <span class='neutral'>    function logBytes32(bytes32 p0) internal pure {</span>
  189 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes32)&quot;, p0));</span>
  190 |     | <span class='neutral'>    }</span>
  191 |     | <span class='neutral'></span>
  192 |     | <span class='neutral'>    function log(uint256 p0) internal pure {</span>
  193 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256)&quot;, p0));</span>
  194 |     | <span class='neutral'>    }</span>
  195 |     | <span class='neutral'></span>
  196 |     | <span class='neutral'>    function log(string memory p0) internal pure {</span>
  197 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
  198 |     | <span class='neutral'>    }</span>
  199 |     | <span class='neutral'></span>
  200 |     | <span class='neutral'>    function log(bool p0) internal pure {</span>
  201 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
  202 |     | <span class='neutral'>    }</span>
  203 |     | <span class='neutral'></span>
  204 |     | <span class='neutral'>    function log(address p0) internal pure {</span>
  205 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
  206 |     | <span class='neutral'>    }</span>
  207 |     | <span class='neutral'></span>
  208 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1) internal pure {</span>
  209 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256)&quot;, p0, p1));</span>
  210 |     | <span class='neutral'>    }</span>
  211 |     | <span class='neutral'></span>
  212 |     | <span class='neutral'>    function log(uint256 p0, string memory p1) internal pure {</span>
  213 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string)&quot;, p0, p1));</span>
  214 |     | <span class='neutral'>    }</span>
  215 |     | <span class='neutral'></span>
  216 |     | <span class='neutral'>    function log(uint256 p0, bool p1) internal pure {</span>
  217 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool)&quot;, p0, p1));</span>
  218 |     | <span class='neutral'>    }</span>
  219 |     | <span class='neutral'></span>
  220 |     | <span class='neutral'>    function log(uint256 p0, address p1) internal pure {</span>
  221 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address)&quot;, p0, p1));</span>
  222 |     | <span class='neutral'>    }</span>
  223 |     | <span class='neutral'></span>
  224 |     | <span class='neutral'>    function log(string memory p0, uint256 p1) internal pure {</span>
  225 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256)&quot;, p0, p1));</span>
  226 |     | <span class='neutral'>    }</span>
  227 |     | <span class='neutral'></span>
  228 |     | <span class='neutral'>    function log(string memory p0, string memory p1) internal pure {</span>
  229 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string)&quot;, p0, p1));</span>
  230 |     | <span class='neutral'>    }</span>
  231 |     | <span class='neutral'></span>
  232 |     | <span class='neutral'>    function log(string memory p0, bool p1) internal pure {</span>
  233 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool)&quot;, p0, p1));</span>
  234 |     | <span class='neutral'>    }</span>
  235 |     | <span class='neutral'></span>
  236 |     | <span class='neutral'>    function log(string memory p0, address p1) internal pure {</span>
  237 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address)&quot;, p0, p1));</span>
  238 |     | <span class='neutral'>    }</span>
  239 |     | <span class='neutral'></span>
  240 |     | <span class='neutral'>    function log(bool p0, uint256 p1) internal pure {</span>
  241 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256)&quot;, p0, p1));</span>
  242 |     | <span class='neutral'>    }</span>
  243 |     | <span class='neutral'></span>
  244 |     | <span class='neutral'>    function log(bool p0, string memory p1) internal pure {</span>
  245 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string)&quot;, p0, p1));</span>
  246 |     | <span class='neutral'>    }</span>
  247 |     | <span class='neutral'></span>
  248 |     | <span class='neutral'>    function log(bool p0, bool p1) internal pure {</span>
  249 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool)&quot;, p0, p1));</span>
  250 |     | <span class='neutral'>    }</span>
  251 |     | <span class='neutral'></span>
  252 |     | <span class='neutral'>    function log(bool p0, address p1) internal pure {</span>
  253 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address)&quot;, p0, p1));</span>
  254 |     | <span class='neutral'>    }</span>
  255 |     | <span class='neutral'></span>
  256 |     | <span class='neutral'>    function log(address p0, uint256 p1) internal pure {</span>
  257 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256)&quot;, p0, p1));</span>
  258 |     | <span class='neutral'>    }</span>
  259 |     | <span class='neutral'></span>
  260 |     | <span class='neutral'>    function log(address p0, string memory p1) internal pure {</span>
  261 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string)&quot;, p0, p1));</span>
  262 |     | <span class='neutral'>    }</span>
  263 |     | <span class='neutral'></span>
  264 |     | <span class='neutral'>    function log(address p0, bool p1) internal pure {</span>
  265 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool)&quot;, p0, p1));</span>
  266 |     | <span class='neutral'>    }</span>
  267 |     | <span class='neutral'></span>
  268 |     | <span class='neutral'>    function log(address p0, address p1) internal pure {</span>
  269 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address)&quot;, p0, p1));</span>
  270 |     | <span class='neutral'>    }</span>
  271 |     | <span class='neutral'></span>
  272 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {</span>
  273 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256)&quot;, p0, p1, p2));</span>
  274 |     | <span class='neutral'>    }</span>
  275 |     | <span class='neutral'></span>
  276 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2) internal pure {</span>
  277 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string)&quot;, p0, p1, p2));</span>
  278 |     | <span class='neutral'>    }</span>
  279 |     | <span class='neutral'></span>
  280 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2) internal pure {</span>
  281 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool)&quot;, p0, p1, p2));</span>
  282 |     | <span class='neutral'>    }</span>
  283 |     | <span class='neutral'></span>
  284 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2) internal pure {</span>
  285 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address)&quot;, p0, p1, p2));</span>
  286 |     | <span class='neutral'>    }</span>
  287 |     | <span class='neutral'></span>
  288 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2) internal pure {</span>
  289 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256)&quot;, p0, p1, p2));</span>
  290 |     | <span class='neutral'>    }</span>
  291 |     | <span class='neutral'></span>
  292 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2) internal pure {</span>
  293 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string)&quot;, p0, p1, p2));</span>
  294 |     | <span class='neutral'>    }</span>
  295 |     | <span class='neutral'></span>
  296 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2) internal pure {</span>
  297 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool)&quot;, p0, p1, p2));</span>
  298 |     | <span class='neutral'>    }</span>
  299 |     | <span class='neutral'></span>
  300 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2) internal pure {</span>
  301 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address)&quot;, p0, p1, p2));</span>
  302 |     | <span class='neutral'>    }</span>
  303 |     | <span class='neutral'></span>
  304 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2) internal pure {</span>
  305 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256)&quot;, p0, p1, p2));</span>
  306 |     | <span class='neutral'>    }</span>
  307 |     | <span class='neutral'></span>
  308 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2) internal pure {</span>
  309 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string)&quot;, p0, p1, p2));</span>
  310 |     | <span class='neutral'>    }</span>
  311 |     | <span class='neutral'></span>
  312 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2) internal pure {</span>
  313 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool)&quot;, p0, p1, p2));</span>
  314 |     | <span class='neutral'>    }</span>
  315 |     | <span class='neutral'></span>
  316 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2) internal pure {</span>
  317 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address)&quot;, p0, p1, p2));</span>
  318 |     | <span class='neutral'>    }</span>
  319 |     | <span class='neutral'></span>
  320 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2) internal pure {</span>
  321 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256)&quot;, p0, p1, p2));</span>
  322 |     | <span class='neutral'>    }</span>
  323 |     | <span class='neutral'></span>
  324 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2) internal pure {</span>
  325 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string)&quot;, p0, p1, p2));</span>
  326 |     | <span class='neutral'>    }</span>
  327 |     | <span class='neutral'></span>
  328 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2) internal pure {</span>
  329 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool)&quot;, p0, p1, p2));</span>
  330 |     | <span class='neutral'>    }</span>
  331 |     | <span class='neutral'></span>
  332 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2) internal pure {</span>
  333 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address)&quot;, p0, p1, p2));</span>
  334 |     | <span class='neutral'>    }</span>
  335 |     | <span class='neutral'></span>
  336 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2) internal pure {</span>
  337 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256)&quot;, p0, p1, p2));</span>
  338 |     | <span class='neutral'>    }</span>
  339 |     | <span class='neutral'></span>
  340 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2) internal pure {</span>
  341 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string)&quot;, p0, p1, p2));</span>
  342 |     | <span class='neutral'>    }</span>
  343 |     | <span class='neutral'></span>
  344 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2) internal pure {</span>
  345 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool)&quot;, p0, p1, p2));</span>
  346 |     | <span class='neutral'>    }</span>
  347 |     | <span class='neutral'></span>
  348 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2) internal pure {</span>
  349 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address)&quot;, p0, p1, p2));</span>
  350 |     | <span class='neutral'>    }</span>
  351 |     | <span class='neutral'></span>
  352 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2) internal pure {</span>
  353 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256)&quot;, p0, p1, p2));</span>
  354 |     | <span class='neutral'>    }</span>
  355 |     | <span class='neutral'></span>
  356 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2) internal pure {</span>
  357 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string)&quot;, p0, p1, p2));</span>
  358 |     | <span class='neutral'>    }</span>
  359 |     | <span class='neutral'></span>
  360 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2) internal pure {</span>
  361 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool)&quot;, p0, p1, p2));</span>
  362 |     | <span class='neutral'>    }</span>
  363 |     | <span class='neutral'></span>
  364 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2) internal pure {</span>
  365 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address)&quot;, p0, p1, p2));</span>
  366 |     | <span class='neutral'>    }</span>
  367 |     | <span class='neutral'></span>
  368 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2) internal pure {</span>
  369 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256)&quot;, p0, p1, p2));</span>
  370 |     | <span class='neutral'>    }</span>
  371 |     | <span class='neutral'></span>
  372 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2) internal pure {</span>
  373 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string)&quot;, p0, p1, p2));</span>
  374 |     | <span class='neutral'>    }</span>
  375 |     | <span class='neutral'></span>
  376 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2) internal pure {</span>
  377 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool)&quot;, p0, p1, p2));</span>
  378 |     | <span class='neutral'>    }</span>
  379 |     | <span class='neutral'></span>
  380 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2) internal pure {</span>
  381 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address)&quot;, p0, p1, p2));</span>
  382 |     | <span class='neutral'>    }</span>
  383 |     | <span class='neutral'></span>
  384 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2) internal pure {</span>
  385 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256)&quot;, p0, p1, p2));</span>
  386 |     | <span class='neutral'>    }</span>
  387 |     | <span class='neutral'></span>
  388 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2) internal pure {</span>
  389 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string)&quot;, p0, p1, p2));</span>
  390 |     | <span class='neutral'>    }</span>
  391 |     | <span class='neutral'></span>
  392 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2) internal pure {</span>
  393 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool)&quot;, p0, p1, p2));</span>
  394 |     | <span class='neutral'>    }</span>
  395 |     | <span class='neutral'></span>
  396 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2) internal pure {</span>
  397 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address)&quot;, p0, p1, p2));</span>
  398 |     | <span class='neutral'>    }</span>
  399 |     | <span class='neutral'></span>
  400 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2) internal pure {</span>
  401 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256)&quot;, p0, p1, p2));</span>
  402 |     | <span class='neutral'>    }</span>
  403 |     | <span class='neutral'></span>
  404 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2) internal pure {</span>
  405 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string)&quot;, p0, p1, p2));</span>
  406 |     | <span class='neutral'>    }</span>
  407 |     | <span class='neutral'></span>
  408 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2) internal pure {</span>
  409 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool)&quot;, p0, p1, p2));</span>
  410 |     | <span class='neutral'>    }</span>
  411 |     | <span class='neutral'></span>
  412 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2) internal pure {</span>
  413 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address)&quot;, p0, p1, p2));</span>
  414 |     | <span class='neutral'>    }</span>
  415 |     | <span class='neutral'></span>
  416 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2) internal pure {</span>
  417 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256)&quot;, p0, p1, p2));</span>
  418 |     | <span class='neutral'>    }</span>
  419 |     | <span class='neutral'></span>
  420 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2) internal pure {</span>
  421 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string)&quot;, p0, p1, p2));</span>
  422 |     | <span class='neutral'>    }</span>
  423 |     | <span class='neutral'></span>
  424 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2) internal pure {</span>
  425 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool)&quot;, p0, p1, p2));</span>
  426 |     | <span class='neutral'>    }</span>
  427 |     | <span class='neutral'></span>
  428 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2) internal pure {</span>
  429 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address)&quot;, p0, p1, p2));</span>
  430 |     | <span class='neutral'>    }</span>
  431 |     | <span class='neutral'></span>
  432 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2) internal pure {</span>
  433 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256)&quot;, p0, p1, p2));</span>
  434 |     | <span class='neutral'>    }</span>
  435 |     | <span class='neutral'></span>
  436 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2) internal pure {</span>
  437 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string)&quot;, p0, p1, p2));</span>
  438 |     | <span class='neutral'>    }</span>
  439 |     | <span class='neutral'></span>
  440 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2) internal pure {</span>
  441 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool)&quot;, p0, p1, p2));</span>
  442 |     | <span class='neutral'>    }</span>
  443 |     | <span class='neutral'></span>
  444 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2) internal pure {</span>
  445 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address)&quot;, p0, p1, p2));</span>
  446 |     | <span class='neutral'>    }</span>
  447 |     | <span class='neutral'></span>
  448 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2) internal pure {</span>
  449 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256)&quot;, p0, p1, p2));</span>
  450 |     | <span class='neutral'>    }</span>
  451 |     | <span class='neutral'></span>
  452 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2) internal pure {</span>
  453 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string)&quot;, p0, p1, p2));</span>
  454 |     | <span class='neutral'>    }</span>
  455 |     | <span class='neutral'></span>
  456 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2) internal pure {</span>
  457 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool)&quot;, p0, p1, p2));</span>
  458 |     | <span class='neutral'>    }</span>
  459 |     | <span class='neutral'></span>
  460 |     | <span class='neutral'>    function log(bool p0, address p1, address p2) internal pure {</span>
  461 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address)&quot;, p0, p1, p2));</span>
  462 |     | <span class='neutral'>    }</span>
  463 |     | <span class='neutral'></span>
  464 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2) internal pure {</span>
  465 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256)&quot;, p0, p1, p2));</span>
  466 |     | <span class='neutral'>    }</span>
  467 |     | <span class='neutral'></span>
  468 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2) internal pure {</span>
  469 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string)&quot;, p0, p1, p2));</span>
  470 |     | <span class='neutral'>    }</span>
  471 |     | <span class='neutral'></span>
  472 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2) internal pure {</span>
  473 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool)&quot;, p0, p1, p2));</span>
  474 |     | <span class='neutral'>    }</span>
  475 |     | <span class='neutral'></span>
  476 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2) internal pure {</span>
  477 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address)&quot;, p0, p1, p2));</span>
  478 |     | <span class='neutral'>    }</span>
  479 |     | <span class='neutral'></span>
  480 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2) internal pure {</span>
  481 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256)&quot;, p0, p1, p2));</span>
  482 |     | <span class='neutral'>    }</span>
  483 |     | <span class='neutral'></span>
  484 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2) internal pure {</span>
  485 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string)&quot;, p0, p1, p2));</span>
  486 |     | <span class='neutral'>    }</span>
  487 |     | <span class='neutral'></span>
  488 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2) internal pure {</span>
  489 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool)&quot;, p0, p1, p2));</span>
  490 |     | <span class='neutral'>    }</span>
  491 |     | <span class='neutral'></span>
  492 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2) internal pure {</span>
  493 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address)&quot;, p0, p1, p2));</span>
  494 |     | <span class='neutral'>    }</span>
  495 |     | <span class='neutral'></span>
  496 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2) internal pure {</span>
  497 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256)&quot;, p0, p1, p2));</span>
  498 |     | <span class='neutral'>    }</span>
  499 |     | <span class='neutral'></span>
  500 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2) internal pure {</span>
  501 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string)&quot;, p0, p1, p2));</span>
  502 |     | <span class='neutral'>    }</span>
  503 |     | <span class='neutral'></span>
  504 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2) internal pure {</span>
  505 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool)&quot;, p0, p1, p2));</span>
  506 |     | <span class='neutral'>    }</span>
  507 |     | <span class='neutral'></span>
  508 |     | <span class='neutral'>    function log(address p0, bool p1, address p2) internal pure {</span>
  509 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address)&quot;, p0, p1, p2));</span>
  510 |     | <span class='neutral'>    }</span>
  511 |     | <span class='neutral'></span>
  512 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2) internal pure {</span>
  513 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256)&quot;, p0, p1, p2));</span>
  514 |     | <span class='neutral'>    }</span>
  515 |     | <span class='neutral'></span>
  516 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2) internal pure {</span>
  517 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string)&quot;, p0, p1, p2));</span>
  518 |     | <span class='neutral'>    }</span>
  519 |     | <span class='neutral'></span>
  520 |     | <span class='neutral'>    function log(address p0, address p1, bool p2) internal pure {</span>
  521 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool)&quot;, p0, p1, p2));</span>
  522 |     | <span class='neutral'>    }</span>
  523 |     | <span class='neutral'></span>
  524 |     | <span class='neutral'>    function log(address p0, address p1, address p2) internal pure {</span>
  525 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address)&quot;, p0, p1, p2));</span>
  526 |     | <span class='neutral'>    }</span>
  527 |     | <span class='neutral'></span>
  528 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
  529 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  530 |     | <span class='neutral'>    }</span>
  531 |     | <span class='neutral'></span>
  532 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {</span>
  533 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
  534 |     | <span class='neutral'>    }</span>
  535 |     | <span class='neutral'></span>
  536 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
  537 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  538 |     | <span class='neutral'>    }</span>
  539 |     | <span class='neutral'></span>
  540 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
  541 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
  542 |     | <span class='neutral'>    }</span>
  543 |     | <span class='neutral'></span>
  544 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {</span>
  545 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
  546 |     | <span class='neutral'>    }</span>
  547 |     | <span class='neutral'></span>
  548 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {</span>
  549 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
  550 |     | <span class='neutral'>    }</span>
  551 |     | <span class='neutral'></span>
  552 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {</span>
  553 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
  554 |     | <span class='neutral'>    }</span>
  555 |     | <span class='neutral'></span>
  556 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {</span>
  557 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
  558 |     | <span class='neutral'>    }</span>
  559 |     | <span class='neutral'></span>
  560 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
  561 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  562 |     | <span class='neutral'>    }</span>
  563 |     | <span class='neutral'></span>
  564 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {</span>
  565 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
  566 |     | <span class='neutral'>    }</span>
  567 |     | <span class='neutral'></span>
  568 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {</span>
  569 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
  570 |     | <span class='neutral'>    }</span>
  571 |     | <span class='neutral'></span>
  572 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {</span>
  573 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
  574 |     | <span class='neutral'>    }</span>
  575 |     | <span class='neutral'></span>
  576 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
  577 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
  578 |     | <span class='neutral'>    }</span>
  579 |     | <span class='neutral'></span>
  580 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {</span>
  581 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
  582 |     | <span class='neutral'>    }</span>
  583 |     | <span class='neutral'></span>
  584 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {</span>
  585 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
  586 |     | <span class='neutral'>    }</span>
  587 |     | <span class='neutral'></span>
  588 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {</span>
  589 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
  590 |     | <span class='neutral'>    }</span>
  591 |     | <span class='neutral'></span>
  592 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {</span>
  593 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  594 |     | <span class='neutral'>    }</span>
  595 |     | <span class='neutral'></span>
  596 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {</span>
  597 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
  598 |     | <span class='neutral'>    }</span>
  599 |     | <span class='neutral'></span>
  600 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {</span>
  601 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  602 |     | <span class='neutral'>    }</span>
  603 |     | <span class='neutral'></span>
  604 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {</span>
  605 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
  606 |     | <span class='neutral'>    }</span>
  607 |     | <span class='neutral'></span>
  608 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {</span>
  609 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
  610 |     | <span class='neutral'>    }</span>
  611 |     | <span class='neutral'></span>
  612 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {</span>
  613 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,string)&quot;, p0, p1, p2, p3));</span>
  614 |     | <span class='neutral'>    }</span>
  615 |     | <span class='neutral'></span>
  616 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {</span>
  617 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  618 |     | <span class='neutral'>    }</span>
  619 |     | <span class='neutral'></span>
  620 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {</span>
  621 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,address)&quot;, p0, p1, p2, p3));</span>
  622 |     | <span class='neutral'>    }</span>
  623 |     | <span class='neutral'></span>
  624 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {</span>
  625 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  626 |     | <span class='neutral'>    }</span>
  627 |     | <span class='neutral'></span>
  628 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {</span>
  629 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  630 |     | <span class='neutral'>    }</span>
  631 |     | <span class='neutral'></span>
  632 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {</span>
  633 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  634 |     | <span class='neutral'>    }</span>
  635 |     | <span class='neutral'></span>
  636 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {</span>
  637 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  638 |     | <span class='neutral'>    }</span>
  639 |     | <span class='neutral'></span>
  640 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {</span>
  641 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
  642 |     | <span class='neutral'>    }</span>
  643 |     | <span class='neutral'></span>
  644 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {</span>
  645 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,string)&quot;, p0, p1, p2, p3));</span>
  646 |     | <span class='neutral'>    }</span>
  647 |     | <span class='neutral'></span>
  648 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {</span>
  649 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  650 |     | <span class='neutral'>    }</span>
  651 |     | <span class='neutral'></span>
  652 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {</span>
  653 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,address)&quot;, p0, p1, p2, p3));</span>
  654 |     | <span class='neutral'>    }</span>
  655 |     | <span class='neutral'></span>
  656 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
  657 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  658 |     | <span class='neutral'>    }</span>
  659 |     | <span class='neutral'></span>
  660 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {</span>
  661 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
  662 |     | <span class='neutral'>    }</span>
  663 |     | <span class='neutral'></span>
  664 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {</span>
  665 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  666 |     | <span class='neutral'>    }</span>
  667 |     | <span class='neutral'></span>
  668 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {</span>
  669 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
  670 |     | <span class='neutral'>    }</span>
  671 |     | <span class='neutral'></span>
  672 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {</span>
  673 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
  674 |     | <span class='neutral'>    }</span>
  675 |     | <span class='neutral'></span>
  676 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {</span>
  677 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  678 |     | <span class='neutral'>    }</span>
  679 |     | <span class='neutral'></span>
  680 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {</span>
  681 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  682 |     | <span class='neutral'>    }</span>
  683 |     | <span class='neutral'></span>
  684 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {</span>
  685 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  686 |     | <span class='neutral'>    }</span>
  687 |     | <span class='neutral'></span>
  688 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {</span>
  689 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  690 |     | <span class='neutral'>    }</span>
  691 |     | <span class='neutral'></span>
  692 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {</span>
  693 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  694 |     | <span class='neutral'>    }</span>
  695 |     | <span class='neutral'></span>
  696 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {</span>
  697 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  698 |     | <span class='neutral'>    }</span>
  699 |     | <span class='neutral'></span>
  700 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {</span>
  701 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  702 |     | <span class='neutral'>    }</span>
  703 |     | <span class='neutral'></span>
  704 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {</span>
  705 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
  706 |     | <span class='neutral'>    }</span>
  707 |     | <span class='neutral'></span>
  708 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {</span>
  709 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  710 |     | <span class='neutral'>    }</span>
  711 |     | <span class='neutral'></span>
  712 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {</span>
  713 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  714 |     | <span class='neutral'>    }</span>
  715 |     | <span class='neutral'></span>
  716 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, address p3) internal pure {</span>
  717 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  718 |     | <span class='neutral'>    }</span>
  719 |     | <span class='neutral'></span>
  720 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
  721 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  722 |     | <span class='neutral'>    }</span>
  723 |     | <span class='neutral'></span>
  724 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {</span>
  725 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
  726 |     | <span class='neutral'>    }</span>
  727 |     | <span class='neutral'></span>
  728 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {</span>
  729 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  730 |     | <span class='neutral'>    }</span>
  731 |     | <span class='neutral'></span>
  732 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {</span>
  733 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
  734 |     | <span class='neutral'>    }</span>
  735 |     | <span class='neutral'></span>
  736 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {</span>
  737 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
  738 |     | <span class='neutral'>    }</span>
  739 |     | <span class='neutral'></span>
  740 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {</span>
  741 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,string)&quot;, p0, p1, p2, p3));</span>
  742 |     | <span class='neutral'>    }</span>
  743 |     | <span class='neutral'></span>
  744 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {</span>
  745 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  746 |     | <span class='neutral'>    }</span>
  747 |     | <span class='neutral'></span>
  748 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {</span>
  749 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,address)&quot;, p0, p1, p2, p3));</span>
  750 |     | <span class='neutral'>    }</span>
  751 |     | <span class='neutral'></span>
  752 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {</span>
  753 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  754 |     | <span class='neutral'>    }</span>
  755 |     | <span class='neutral'></span>
  756 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {</span>
  757 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,string)&quot;, p0, p1, p2, p3));</span>
  758 |     | <span class='neutral'>    }</span>
  759 |     | <span class='neutral'></span>
  760 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {</span>
  761 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
  762 |     | <span class='neutral'>    }</span>
  763 |     | <span class='neutral'></span>
  764 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, address p3) internal pure {</span>
  765 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,address)&quot;, p0, p1, p2, p3));</span>
  766 |     | <span class='neutral'>    }</span>
  767 |     | <span class='neutral'></span>
  768 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {</span>
  769 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
  770 |     | <span class='neutral'>    }</span>
  771 |     | <span class='neutral'></span>
  772 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {</span>
  773 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,string)&quot;, p0, p1, p2, p3));</span>
  774 |     | <span class='neutral'>    }</span>
  775 |     | <span class='neutral'></span>
  776 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, bool p3) internal pure {</span>
  777 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,bool)&quot;, p0, p1, p2, p3));</span>
  778 |     | <span class='neutral'>    }</span>
  779 |     | <span class='neutral'></span>
  780 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, address p3) internal pure {</span>
  781 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,address)&quot;, p0, p1, p2, p3));</span>
  782 |     | <span class='neutral'>    }</span>
  783 |     | <span class='neutral'></span>
  784 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
  785 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  786 |     | <span class='neutral'>    }</span>
  787 |     | <span class='neutral'></span>
  788 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {</span>
  789 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
  790 |     | <span class='neutral'>    }</span>
  791 |     | <span class='neutral'></span>
  792 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
  793 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  794 |     | <span class='neutral'>    }</span>
  795 |     | <span class='neutral'></span>
  796 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
  797 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
  798 |     | <span class='neutral'>    }</span>
  799 |     | <span class='neutral'></span>
  800 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {</span>
  801 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
  802 |     | <span class='neutral'>    }</span>
  803 |     | <span class='neutral'></span>
  804 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {</span>
  805 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
  806 |     | <span class='neutral'>    }</span>
  807 |     | <span class='neutral'></span>
  808 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {</span>
  809 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
  810 |     | <span class='neutral'>    }</span>
  811 |     | <span class='neutral'></span>
  812 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {</span>
  813 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
  814 |     | <span class='neutral'>    }</span>
  815 |     | <span class='neutral'></span>
  816 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
  817 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  818 |     | <span class='neutral'>    }</span>
  819 |     | <span class='neutral'></span>
  820 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {</span>
  821 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
  822 |     | <span class='neutral'>    }</span>
  823 |     | <span class='neutral'></span>
  824 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {</span>
  825 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
  826 |     | <span class='neutral'>    }</span>
  827 |     | <span class='neutral'></span>
  828 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {</span>
  829 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
  830 |     | <span class='neutral'>    }</span>
  831 |     | <span class='neutral'></span>
  832 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
  833 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
  834 |     | <span class='neutral'>    }</span>
  835 |     | <span class='neutral'></span>
  836 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {</span>
  837 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
  838 |     | <span class='neutral'>    }</span>
  839 |     | <span class='neutral'></span>
  840 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {</span>
  841 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
  842 |     | <span class='neutral'>    }</span>
  843 |     | <span class='neutral'></span>
  844 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {</span>
  845 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
  846 |     | <span class='neutral'>    }</span>
  847 |     | <span class='neutral'></span>
  848 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {</span>
  849 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  850 |     | <span class='neutral'>    }</span>
  851 |     | <span class='neutral'></span>
  852 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {</span>
  853 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
  854 |     | <span class='neutral'>    }</span>
  855 |     | <span class='neutral'></span>
  856 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {</span>
  857 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  858 |     | <span class='neutral'>    }</span>
  859 |     | <span class='neutral'></span>
  860 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {</span>
  861 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
  862 |     | <span class='neutral'>    }</span>
  863 |     | <span class='neutral'></span>
  864 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {</span>
  865 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
  866 |     | <span class='neutral'>    }</span>
  867 |     | <span class='neutral'></span>
  868 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {</span>
  869 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,string)&quot;, p0, p1, p2, p3));</span>
  870 |     | <span class='neutral'>    }</span>
  871 |     | <span class='neutral'></span>
  872 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {</span>
  873 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  874 |     | <span class='neutral'>    }</span>
  875 |     | <span class='neutral'></span>
  876 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {</span>
  877 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,address)&quot;, p0, p1, p2, p3));</span>
  878 |     | <span class='neutral'>    }</span>
  879 |     | <span class='neutral'></span>
  880 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {</span>
  881 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  882 |     | <span class='neutral'>    }</span>
  883 |     | <span class='neutral'></span>
  884 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {</span>
  885 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  886 |     | <span class='neutral'>    }</span>
  887 |     | <span class='neutral'></span>
  888 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {</span>
  889 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  890 |     | <span class='neutral'>    }</span>
  891 |     | <span class='neutral'></span>
  892 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {</span>
  893 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  894 |     | <span class='neutral'>    }</span>
  895 |     | <span class='neutral'></span>
  896 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {</span>
  897 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
  898 |     | <span class='neutral'>    }</span>
  899 |     | <span class='neutral'></span>
  900 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {</span>
  901 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,string)&quot;, p0, p1, p2, p3));</span>
  902 |     | <span class='neutral'>    }</span>
  903 |     | <span class='neutral'></span>
  904 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {</span>
  905 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  906 |     | <span class='neutral'>    }</span>
  907 |     | <span class='neutral'></span>
  908 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, address p3) internal pure {</span>
  909 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,address)&quot;, p0, p1, p2, p3));</span>
  910 |     | <span class='neutral'>    }</span>
  911 |     | <span class='neutral'></span>
  912 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
  913 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  914 |     | <span class='neutral'>    }</span>
  915 |     | <span class='neutral'></span>
  916 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {</span>
  917 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
  918 |     | <span class='neutral'>    }</span>
  919 |     | <span class='neutral'></span>
  920 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {</span>
  921 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  922 |     | <span class='neutral'>    }</span>
  923 |     | <span class='neutral'></span>
  924 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {</span>
  925 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
  926 |     | <span class='neutral'>    }</span>
  927 |     | <span class='neutral'></span>
  928 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {</span>
  929 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
  930 |     | <span class='neutral'>    }</span>
  931 |     | <span class='neutral'></span>
  932 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {</span>
  933 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  934 |     | <span class='neutral'>    }</span>
  935 |     | <span class='neutral'></span>
  936 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {</span>
  937 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  938 |     | <span class='neutral'>    }</span>
  939 |     | <span class='neutral'></span>
  940 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {</span>
  941 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  942 |     | <span class='neutral'>    }</span>
  943 |     | <span class='neutral'></span>
  944 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {</span>
  945 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  946 |     | <span class='neutral'>    }</span>
  947 |     | <span class='neutral'></span>
  948 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {</span>
  949 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  950 |     | <span class='neutral'>    }</span>
  951 |     | <span class='neutral'></span>
  952 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {</span>
  953 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  954 |     | <span class='neutral'>    }</span>
  955 |     | <span class='neutral'></span>
  956 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, address p3) internal pure {</span>
  957 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  958 |     | <span class='neutral'>    }</span>
  959 |     | <span class='neutral'></span>
  960 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {</span>
  961 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
  962 |     | <span class='neutral'>    }</span>
  963 |     | <span class='neutral'></span>
  964 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {</span>
  965 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  966 |     | <span class='neutral'>    }</span>
  967 |     | <span class='neutral'></span>
  968 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, bool p3) internal pure {</span>
  969 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  970 |     | <span class='neutral'>    }</span>
  971 |     | <span class='neutral'></span>
  972 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, address p3) internal pure {</span>
  973 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  974 |     | <span class='neutral'>    }</span>
  975 |     | <span class='neutral'></span>
  976 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
  977 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  978 |     | <span class='neutral'>    }</span>
  979 |     | <span class='neutral'></span>
  980 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {</span>
  981 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
  982 |     | <span class='neutral'>    }</span>
  983 |     | <span class='neutral'></span>
  984 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {</span>
  985 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  986 |     | <span class='neutral'>    }</span>
  987 |     | <span class='neutral'></span>
  988 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {</span>
  989 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
  990 |     | <span class='neutral'>    }</span>
  991 |     | <span class='neutral'></span>
  992 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {</span>
  993 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
  994 |     | <span class='neutral'>    }</span>
  995 |     | <span class='neutral'></span>
  996 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {</span>
  997 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,string)&quot;, p0, p1, p2, p3));</span>
  998 |     | <span class='neutral'>    }</span>
  999 |     | <span class='neutral'></span>
 1000 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {</span>
 1001 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1002 |     | <span class='neutral'>    }</span>
 1003 |     | <span class='neutral'></span>
 1004 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, address p3) internal pure {</span>
 1005 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1006 |     | <span class='neutral'>    }</span>
 1007 |     | <span class='neutral'></span>
 1008 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {</span>
 1009 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1010 |     | <span class='neutral'>    }</span>
 1011 |     | <span class='neutral'></span>
 1012 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {</span>
 1013 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1014 |     | <span class='neutral'>    }</span>
 1015 |     | <span class='neutral'></span>
 1016 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, bool p3) internal pure {</span>
 1017 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1018 |     | <span class='neutral'>    }</span>
 1019 |     | <span class='neutral'></span>
 1020 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, address p3) internal pure {</span>
 1021 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1022 |     | <span class='neutral'>    }</span>
 1023 |     | <span class='neutral'></span>
 1024 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {</span>
 1025 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1026 |     | <span class='neutral'>    }</span>
 1027 |     | <span class='neutral'></span>
 1028 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, string memory p3) internal pure {</span>
 1029 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1030 |     | <span class='neutral'>    }</span>
 1031 |     | <span class='neutral'></span>
 1032 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, bool p3) internal pure {</span>
 1033 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1034 |     | <span class='neutral'>    }</span>
 1035 |     | <span class='neutral'></span>
 1036 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, address p3) internal pure {</span>
 1037 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1038 |     | <span class='neutral'>    }</span>
 1039 |     | <span class='neutral'></span>
 1040 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
 1041 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1042 |     | <span class='neutral'>    }</span>
 1043 |     | <span class='neutral'></span>
 1044 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {</span>
 1045 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1046 |     | <span class='neutral'>    }</span>
 1047 |     | <span class='neutral'></span>
 1048 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
 1049 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1050 |     | <span class='neutral'>    }</span>
 1051 |     | <span class='neutral'></span>
 1052 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
 1053 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1054 |     | <span class='neutral'>    }</span>
 1055 |     | <span class='neutral'></span>
 1056 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {</span>
 1057 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1058 |     | <span class='neutral'>    }</span>
 1059 |     | <span class='neutral'></span>
 1060 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {</span>
 1061 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
 1062 |     | <span class='neutral'>    }</span>
 1063 |     | <span class='neutral'></span>
 1064 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {</span>
 1065 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
 1066 |     | <span class='neutral'>    }</span>
 1067 |     | <span class='neutral'></span>
 1068 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {</span>
 1069 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
 1070 |     | <span class='neutral'>    }</span>
 1071 |     | <span class='neutral'></span>
 1072 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
 1073 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1074 |     | <span class='neutral'>    }</span>
 1075 |     | <span class='neutral'></span>
 1076 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {</span>
 1077 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
 1078 |     | <span class='neutral'>    }</span>
 1079 |     | <span class='neutral'></span>
 1080 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {</span>
 1081 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1082 |     | <span class='neutral'>    }</span>
 1083 |     | <span class='neutral'></span>
 1084 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {</span>
 1085 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
 1086 |     | <span class='neutral'>    }</span>
 1087 |     | <span class='neutral'></span>
 1088 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
 1089 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1090 |     | <span class='neutral'>    }</span>
 1091 |     | <span class='neutral'></span>
 1092 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {</span>
 1093 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
 1094 |     | <span class='neutral'>    }</span>
 1095 |     | <span class='neutral'></span>
 1096 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {</span>
 1097 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
 1098 |     | <span class='neutral'>    }</span>
 1099 |     | <span class='neutral'></span>
 1100 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, address p3) internal pure {</span>
 1101 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
 1102 |     | <span class='neutral'>    }</span>
 1103 |     | <span class='neutral'></span>
 1104 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {</span>
 1105 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1106 |     | <span class='neutral'>    }</span>
 1107 |     | <span class='neutral'></span>
 1108 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {</span>
 1109 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1110 |     | <span class='neutral'>    }</span>
 1111 |     | <span class='neutral'></span>
 1112 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {</span>
 1113 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1114 |     | <span class='neutral'>    }</span>
 1115 |     | <span class='neutral'></span>
 1116 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {</span>
 1117 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1118 |     | <span class='neutral'>    }</span>
 1119 |     | <span class='neutral'></span>
 1120 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {</span>
 1121 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1122 |     | <span class='neutral'>    }</span>
 1123 |     | <span class='neutral'></span>
 1124 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {</span>
 1125 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1126 |     | <span class='neutral'>    }</span>
 1127 |     | <span class='neutral'></span>
 1128 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {</span>
 1129 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1130 |     | <span class='neutral'>    }</span>
 1131 |     | <span class='neutral'></span>
 1132 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {</span>
 1133 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1134 |     | <span class='neutral'>    }</span>
 1135 |     | <span class='neutral'></span>
 1136 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {</span>
 1137 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1138 |     | <span class='neutral'>    }</span>
 1139 |     | <span class='neutral'></span>
 1140 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {</span>
 1141 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1142 |     | <span class='neutral'>    }</span>
 1143 |     | <span class='neutral'></span>
 1144 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {</span>
 1145 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1146 |     | <span class='neutral'>    }</span>
 1147 |     | <span class='neutral'></span>
 1148 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, address p3) internal pure {</span>
 1149 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1150 |     | <span class='neutral'>    }</span>
 1151 |     | <span class='neutral'></span>
 1152 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {</span>
 1153 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1154 |     | <span class='neutral'>    }</span>
 1155 |     | <span class='neutral'></span>
 1156 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {</span>
 1157 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1158 |     | <span class='neutral'>    }</span>
 1159 |     | <span class='neutral'></span>
 1160 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, bool p3) internal pure {</span>
 1161 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1162 |     | <span class='neutral'>    }</span>
 1163 |     | <span class='neutral'></span>
 1164 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, address p3) internal pure {</span>
 1165 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1166 |     | <span class='neutral'>    }</span>
 1167 |     | <span class='neutral'></span>
 1168 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
 1169 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1170 |     | <span class='neutral'>    }</span>
 1171 |     | <span class='neutral'></span>
 1172 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {</span>
 1173 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1174 |     | <span class='neutral'>    }</span>
 1175 |     | <span class='neutral'></span>
 1176 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {</span>
 1177 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1178 |     | <span class='neutral'>    }</span>
 1179 |     | <span class='neutral'></span>
 1180 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {</span>
 1181 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1182 |     | <span class='neutral'>    }</span>
 1183 |     | <span class='neutral'></span>
 1184 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {</span>
 1185 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1186 |     | <span class='neutral'>    }</span>
 1187 |     | <span class='neutral'></span>
 1188 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {</span>
 1189 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1190 |     | <span class='neutral'>    }</span>
 1191 |     | <span class='neutral'></span>
 1192 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {</span>
 1193 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1194 |     | <span class='neutral'>    }</span>
 1195 |     | <span class='neutral'></span>
 1196 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, address p3) internal pure {</span>
 1197 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1198 |     | <span class='neutral'>    }</span>
 1199 |     | <span class='neutral'></span>
 1200 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {</span>
 1201 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1202 |     | <span class='neutral'>    }</span>
 1203 |     | <span class='neutral'></span>
 1204 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {</span>
 1205 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1206 |     | <span class='neutral'>    }</span>
 1207 |     | <span class='neutral'></span>
 1208 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, bool p3) internal pure {</span>
 1209 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1210 |     | <span class='neutral'>    }</span>
 1211 |     | <span class='neutral'></span>
 1212 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, address p3) internal pure {</span>
 1213 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1214 |     | <span class='neutral'>    }</span>
 1215 |     | <span class='neutral'></span>
 1216 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {</span>
 1217 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1218 |     | <span class='neutral'>    }</span>
 1219 |     | <span class='neutral'></span>
 1220 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, string memory p3) internal pure {</span>
 1221 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1222 |     | <span class='neutral'>    }</span>
 1223 |     | <span class='neutral'></span>
 1224 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, bool p3) internal pure {</span>
 1225 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1226 |     | <span class='neutral'>    }</span>
 1227 |     | <span class='neutral'></span>
 1228 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, address p3) internal pure {</span>
 1229 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1230 |     | <span class='neutral'>    }</span>
 1231 |     | <span class='neutral'></span>
 1232 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
 1233 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1234 |     | <span class='neutral'>    }</span>
 1235 |     | <span class='neutral'></span>
 1236 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {</span>
 1237 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1238 |     | <span class='neutral'>    }</span>
 1239 |     | <span class='neutral'></span>
 1240 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {</span>
 1241 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1242 |     | <span class='neutral'>    }</span>
 1243 |     | <span class='neutral'></span>
 1244 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, address p3) internal pure {</span>
 1245 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1246 |     | <span class='neutral'>    }</span>
 1247 |     | <span class='neutral'></span>
 1248 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {</span>
 1249 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1250 |     | <span class='neutral'>    }</span>
 1251 |     | <span class='neutral'></span>
 1252 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {</span>
 1253 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1254 |     | <span class='neutral'>    }</span>
 1255 |     | <span class='neutral'></span>
 1256 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, bool p3) internal pure {</span>
 1257 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1258 |     | <span class='neutral'>    }</span>
 1259 |     | <span class='neutral'></span>
 1260 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, address p3) internal pure {</span>
 1261 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1262 |     | <span class='neutral'>    }</span>
 1263 |     | <span class='neutral'></span>
 1264 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {</span>
 1265 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1266 |     | <span class='neutral'>    }</span>
 1267 |     | <span class='neutral'></span>
 1268 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, string memory p3) internal pure {</span>
 1269 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1270 |     | <span class='neutral'>    }</span>
 1271 |     | <span class='neutral'></span>
 1272 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, bool p3) internal pure {</span>
 1273 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1274 |     | <span class='neutral'>    }</span>
 1275 |     | <span class='neutral'></span>
 1276 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, address p3) internal pure {</span>
 1277 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1278 |     | <span class='neutral'>    }</span>
 1279 |     | <span class='neutral'></span>
 1280 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, uint256 p3) internal pure {</span>
 1281 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1282 |     | <span class='neutral'>    }</span>
 1283 |     | <span class='neutral'></span>
 1284 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, string memory p3) internal pure {</span>
 1285 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1286 |     | <span class='neutral'>    }</span>
 1287 |     | <span class='neutral'></span>
 1288 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, bool p3) internal pure {</span>
 1289 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1290 |     | <span class='neutral'>    }</span>
 1291 |     | <span class='neutral'></span>
 1292 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, address p3) internal pure {</span>
 1293 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1294 |     | <span class='neutral'>    }</span>
 1295 |     | <span class='neutral'></span>
 1296 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
 1297 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1298 |     | <span class='neutral'>    }</span>
 1299 |     | <span class='neutral'></span>
 1300 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {</span>
 1301 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1302 |     | <span class='neutral'>    }</span>
 1303 |     | <span class='neutral'></span>
 1304 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
 1305 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1306 |     | <span class='neutral'>    }</span>
 1307 |     | <span class='neutral'></span>
 1308 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
 1309 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1310 |     | <span class='neutral'>    }</span>
 1311 |     | <span class='neutral'></span>
 1312 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {</span>
 1313 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1314 |     | <span class='neutral'>    }</span>
 1315 |     | <span class='neutral'></span>
 1316 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {</span>
 1317 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
 1318 |     | <span class='neutral'>    }</span>
 1319 |     | <span class='neutral'></span>
 1320 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {</span>
 1321 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
 1322 |     | <span class='neutral'>    }</span>
 1323 |     | <span class='neutral'></span>
 1324 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {</span>
 1325 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
 1326 |     | <span class='neutral'>    }</span>
 1327 |     | <span class='neutral'></span>
 1328 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
 1329 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1330 |     | <span class='neutral'>    }</span>
 1331 |     | <span class='neutral'></span>
 1332 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {</span>
 1333 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
 1334 |     | <span class='neutral'>    }</span>
 1335 |     | <span class='neutral'></span>
 1336 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {</span>
 1337 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1338 |     | <span class='neutral'>    }</span>
 1339 |     | <span class='neutral'></span>
 1340 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, address p3) internal pure {</span>
 1341 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
 1342 |     | <span class='neutral'>    }</span>
 1343 |     | <span class='neutral'></span>
 1344 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
 1345 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1346 |     | <span class='neutral'>    }</span>
 1347 |     | <span class='neutral'></span>
 1348 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {</span>
 1349 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
 1350 |     | <span class='neutral'>    }</span>
 1351 |     | <span class='neutral'></span>
 1352 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, bool p3) internal pure {</span>
 1353 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
 1354 |     | <span class='neutral'>    }</span>
 1355 |     | <span class='neutral'></span>
 1356 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, address p3) internal pure {</span>
 1357 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
 1358 |     | <span class='neutral'>    }</span>
 1359 |     | <span class='neutral'></span>
 1360 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {</span>
 1361 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1362 |     | <span class='neutral'>    }</span>
 1363 |     | <span class='neutral'></span>
 1364 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {</span>
 1365 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1366 |     | <span class='neutral'>    }</span>
 1367 |     | <span class='neutral'></span>
 1368 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {</span>
 1369 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1370 |     | <span class='neutral'>    }</span>
 1371 |     | <span class='neutral'></span>
 1372 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {</span>
 1373 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1374 |     | <span class='neutral'>    }</span>
 1375 |     | <span class='neutral'></span>
 1376 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {</span>
 1377 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1378 |     | <span class='neutral'>    }</span>
 1379 |     | <span class='neutral'></span>
 1380 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {</span>
 1381 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1382 |     | <span class='neutral'>    }</span>
 1383 |     | <span class='neutral'></span>
 1384 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {</span>
 1385 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1386 |     | <span class='neutral'>    }</span>
 1387 |     | <span class='neutral'></span>
 1388 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, address p3) internal pure {</span>
 1389 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1390 |     | <span class='neutral'>    }</span>
 1391 |     | <span class='neutral'></span>
 1392 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {</span>
 1393 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1394 |     | <span class='neutral'>    }</span>
 1395 |     | <span class='neutral'></span>
 1396 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {</span>
 1397 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1398 |     | <span class='neutral'>    }</span>
 1399 |     | <span class='neutral'></span>
 1400 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, bool p3) internal pure {</span>
 1401 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1402 |     | <span class='neutral'>    }</span>
 1403 |     | <span class='neutral'></span>
 1404 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, address p3) internal pure {</span>
 1405 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1406 |     | <span class='neutral'>    }</span>
 1407 |     | <span class='neutral'></span>
 1408 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {</span>
 1409 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1410 |     | <span class='neutral'>    }</span>
 1411 |     | <span class='neutral'></span>
 1412 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, string memory p3) internal pure {</span>
 1413 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1414 |     | <span class='neutral'>    }</span>
 1415 |     | <span class='neutral'></span>
 1416 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, bool p3) internal pure {</span>
 1417 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1418 |     | <span class='neutral'>    }</span>
 1419 |     | <span class='neutral'></span>
 1420 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, address p3) internal pure {</span>
 1421 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1422 |     | <span class='neutral'>    }</span>
 1423 |     | <span class='neutral'></span>
 1424 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
 1425 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1426 |     | <span class='neutral'>    }</span>
 1427 |     | <span class='neutral'></span>
 1428 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {</span>
 1429 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1430 |     | <span class='neutral'>    }</span>
 1431 |     | <span class='neutral'></span>
 1432 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {</span>
 1433 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1434 |     | <span class='neutral'>    }</span>
 1435 |     | <span class='neutral'></span>
 1436 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, address p3) internal pure {</span>
 1437 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1438 |     | <span class='neutral'>    }</span>
 1439 |     | <span class='neutral'></span>
 1440 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {</span>
 1441 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1442 |     | <span class='neutral'>    }</span>
 1443 |     | <span class='neutral'></span>
 1444 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {</span>
 1445 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1446 |     | <span class='neutral'>    }</span>
 1447 |     | <span class='neutral'></span>
 1448 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, bool p3) internal pure {</span>
 1449 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1450 |     | <span class='neutral'>    }</span>
 1451 |     | <span class='neutral'></span>
 1452 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, address p3) internal pure {</span>
 1453 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1454 |     | <span class='neutral'>    }</span>
 1455 |     | <span class='neutral'></span>
 1456 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {</span>
 1457 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1458 |     | <span class='neutral'>    }</span>
 1459 |     | <span class='neutral'></span>
 1460 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, string memory p3) internal pure {</span>
 1461 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1462 |     | <span class='neutral'>    }</span>
 1463 |     | <span class='neutral'></span>
 1464 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, bool p3) internal pure {</span>
 1465 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1466 |     | <span class='neutral'>    }</span>
 1467 |     | <span class='neutral'></span>
 1468 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, address p3) internal pure {</span>
 1469 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1470 |     | <span class='neutral'>    }</span>
 1471 |     | <span class='neutral'></span>
 1472 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, uint256 p3) internal pure {</span>
 1473 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1474 |     | <span class='neutral'>    }</span>
 1475 |     | <span class='neutral'></span>
 1476 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, string memory p3) internal pure {</span>
 1477 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1478 |     | <span class='neutral'>    }</span>
 1479 |     | <span class='neutral'></span>
 1480 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, bool p3) internal pure {</span>
 1481 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1482 |     | <span class='neutral'>    }</span>
 1483 |     | <span class='neutral'></span>
 1484 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, address p3) internal pure {</span>
 1485 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1486 |     | <span class='neutral'>    }</span>
 1487 |     | <span class='neutral'></span>
 1488 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
 1489 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1490 |     | <span class='neutral'>    }</span>
 1491 |     | <span class='neutral'></span>
 1492 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {</span>
 1493 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1494 |     | <span class='neutral'>    }</span>
 1495 |     | <span class='neutral'></span>
 1496 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, bool p3) internal pure {</span>
 1497 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1498 |     | <span class='neutral'>    }</span>
 1499 |     | <span class='neutral'></span>
 1500 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, address p3) internal pure {</span>
 1501 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1502 |     | <span class='neutral'>    }</span>
 1503 |     | <span class='neutral'></span>
 1504 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {</span>
 1505 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1506 |     | <span class='neutral'>    }</span>
 1507 |     | <span class='neutral'></span>
 1508 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, string memory p3) internal pure {</span>
 1509 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1510 |     | <span class='neutral'>    }</span>
 1511 |     | <span class='neutral'></span>
 1512 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, bool p3) internal pure {</span>
 1513 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1514 |     | <span class='neutral'>    }</span>
 1515 |     | <span class='neutral'></span>
 1516 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, address p3) internal pure {</span>
 1517 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1518 |     | <span class='neutral'>    }</span>
 1519 |     | <span class='neutral'></span>
 1520 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, uint256 p3) internal pure {</span>
 1521 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1522 |     | <span class='neutral'>    }</span>
 1523 |     | <span class='neutral'></span>
 1524 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, string memory p3) internal pure {</span>
 1525 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1526 |     | <span class='neutral'>    }</span>
 1527 |     | <span class='neutral'></span>
 1528 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, bool p3) internal pure {</span>
 1529 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1530 |     | <span class='neutral'>    }</span>
 1531 |     | <span class='neutral'></span>
 1532 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, address p3) internal pure {</span>
 1533 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1534 |     | <span class='neutral'>    }</span>
 1535 |     | <span class='neutral'></span>
 1536 |     | <span class='neutral'>    function log(address p0, address p1, address p2, uint256 p3) internal pure {</span>
 1537 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1538 |     | <span class='neutral'>    }</span>
 1539 |     | <span class='neutral'></span>
 1540 |     | <span class='neutral'>    function log(address p0, address p1, address p2, string memory p3) internal pure {</span>
 1541 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1542 |     | <span class='neutral'>    }</span>
 1543 |     | <span class='neutral'></span>
 1544 |     | <span class='neutral'>    function log(address p0, address p1, address p2, bool p3) internal pure {</span>
 1545 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1546 |     | <span class='neutral'>    }</span>
 1547 |     | <span class='neutral'></span>
 1548 |     | <span class='neutral'>    function log(address p0, address p1, address p2, address p3) internal pure {</span>
 1549 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1550 |     | <span class='neutral'>    }</span>
 1551 |     | <span class='neutral'></span>
 1552 |     | <span class='neutral'>}</span>
 1553 |     | <span class='neutral'></span>

</code>
<br />

