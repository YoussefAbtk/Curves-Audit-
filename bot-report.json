{
  "reportUid": "YJafVVxnQFA",
  "labels": [
    {
      "name": "QA (Quality Assurance)",
      "color": "1D76DB"
    }
  ],
  "comment": "LightChaser-V3",
  "footnote": "V4 wen?",
  "findings": [
    {
      "severity": "NonCritical",
      "title": "Events may be emitted out of order due to code not follow the best practice of check-effects-interaction ",
      "description": "The \"check-effects-interaction\" pattern also impacts event ordering. When a contract doesn't adhere to this pattern, events might be emitted in a sequence that doesn't reflect the actual logical flow of operations. This can cause confusion during event tracking, potentially leading to erroneous off-chain interpretations. To rectify this, always ensure that checks are performed first, state modifications come next, and interactions with external contracts or addresses are done last. This will ensure events are emitted in a logical, consistent manner, providing a clear and accurate chronological record of on-chain actions for off-chain systems and observers.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n218:     function _transferFees(\n219:         address curvesTokenSubject,\n220:         bool isBuy,\n221:         uint256 price,\n222:         uint256 amount,\n223:         uint256 supply\n224:     ) internal {\n225:         (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holderFee, ) = getFees(price);\n226:         {\n227:             bool referralDefined = referralFeeDestination[curvesTokenSubject] != address(0);\n228:             {\n229:                 address firstDestination = isBuy ? feesEconomics.protocolFeeDestination : msg.sender;\n230:                 uint256 buyValue = referralDefined ? protocolFee : protocolFee + referralFee;\n231:                 uint256 sellValue = price - protocolFee - subjectFee - referralFee - holderFee;\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\"); // <= FOUND\n233:                 if (!success1) revert CannotSendFunds();\n234:             }\n235:             {\n236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}(\"\"); // <= FOUND\n237:                 if (!success2) revert CannotSendFunds();\n238:             }\n239:             {\n240:                 (bool success3, ) = referralDefined\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}(\"\")\n242:                     : (true, bytes(\"\"));\n243:                 if (!success3) revert CannotSendFunds();\n244:             }\n245: \n246:             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0)) {\n247:                 feeRedistributor.onBalanceChange(curvesTokenSubject, msg.sender);\n248:                 feeRedistributor.addFees{value: holderFee}(curvesTokenSubject);\n249:             }\n250:         }\n251:         emit Trade( // <= FOUND\n252:             msg.sender,\n253:             curvesTokenSubject,\n254:             isBuy,\n255:             amount,\n256:             price,\n257:             protocolFee,\n258:             subjectFee,\n259:             isBuy ? supply + amount : supply - amount\n260:         );\n261:     }\n\n```\n",
          "loc": [
            "[218](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L218-L251)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Lack of unchecked in loops ",
      "description": "In Solidity, the `unchecked` block allows arithmetic operations to not revert on overflow. Without using `unchecked` in loops, extra gas is consumed due to overflow checks. If it's certain that overflows won't occur within the loop, using `unchecked` can make the loop more gas-efficient by skipping unnecessary checks.",
      "gasSavings": 240,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n305:        for (uint256 i = 0; i < subjects.length; i++) {\n306:             uint256 amount = curvesTokenBalance[subjects[i]][msg.sender];\n307:             if (amount > 0) {\n308:                 _transfer(subjects[i], msg.sender, to, amount);\n309:             }\n310:         }\n\n```\n",
          "loc": [
            "[305](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L305-L305)"
          ]
        },
        {
          "content": "```solidity\n330:        for (uint256 i = 0; i < subjects.length; i++) {\n331:             if (subjects[i] == curvesTokenSubject) {\n332:                 return;\n333:             }\n334:         }\n\n```\n",
          "loc": [
            "[330](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L330-L330)"
          ]
        },
        {
          "content": "```solidity\n55:        for (uint256 i = 0; i < tokens.length; i++) {\n56:             address token = tokens[i];\n57:             uint256 claimable = getClaimableFees(token, user);\n58:             result[i] = UserClaimData(claimable, token);\n59:         }\n\n```\n",
          "loc": [
            "[55](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L55-L55)"
          ]
        },
        {
          "content": "```solidity\n105:        for (uint256 i = 0; i < tokenList.length; i++) {\n106:             address token = tokenList[i];\n107:             updateFeeCredit(token, msg.sender);\n108:             uint256 claimable = getClaimableFees(token, msg.sender);\n109:             if (claimable > 0) {\n110:                 tokensData[token].unclaimedFees[msg.sender] = 0;\n111:                 totalClaimable += claimable;\n112:                 emit FeesClaimed(token, msg.sender, claimable);\n113:             }\n114:         }\n\n```\n",
          "loc": [
            "[105](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L105-L105)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Multiple accesses of the same mapping/array key/index should be cached ",
      "description": "Caching repeated accesses to the same mapping or array key/index in smart contracts can lead to significant gas savings. In Solidity, each read operation from storage (like accessing a value in a mapping or array using a key or index) costs gas. By storing the accessed value in a local variable and reusing it within the function, you avoid multiple expensive storage read operations. This practice is particularly beneficial in loops or functions with multiple reads of the same data. Implementing this caching approach enhances efficiency and reduces transaction costs, which is crucial for optimizing smart contract performance and user experience on the blockchain.",
      "gasSavings": 84,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n439:     function mint(address curvesTokenSubject) external onlyTokenSubject(curvesTokenSubject) {\n440:         if (\n441:             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) == // <= FOUND\n442:             keccak256(abi.encodePacked(\"\")) ||\n443:             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) == // <= FOUND\n444:             keccak256(abi.encodePacked(\"\"))\n445:         ) {\n446:             externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME; // <= FOUND\n447:             externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL; // <= FOUND\n448:         }\n449:         _mint(\n450:             curvesTokenSubject,\n451:             externalCurvesTokens[curvesTokenSubject].name, // <= FOUND\n452:             externalCurvesTokens[curvesTokenSubject].symbol // <= FOUND\n453:         );\n454:     }\n\n```\n",
          "loc": [
            "[439](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L439-L452)"
          ]
        },
        {
          "content": "```solidity\n465:     function withdraw(address curvesTokenSubject, uint256 amount) public {\n466:         if (amount > curvesTokenBalance[curvesTokenSubject][msg.sender]) revert InsufficientBalance(); // <= FOUND\n467: \n468:         address externalToken = externalCurvesTokens[curvesTokenSubject].token; // <= FOUND\n469:         if (externalToken == address(0)) {\n470:             if (\n471:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) == // <= FOUND\n472:                 keccak256(abi.encodePacked(\"\")) ||\n473:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) == // <= FOUND\n474:                 keccak256(abi.encodePacked(\"\"))\n475:             ) {\n476:                 externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME; // <= FOUND\n477:                 externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL; // <= FOUND\n478:             }\n479:             _deployERC20(\n480:                 curvesTokenSubject,\n481:                 externalCurvesTokens[curvesTokenSubject].name, // <= FOUND\n482:                 externalCurvesTokens[curvesTokenSubject].symbol // <= FOUND\n483:             );\n484:             externalToken = externalCurvesTokens[curvesTokenSubject].token; // <= FOUND\n485:         }\n486:         _transfer(curvesTokenSubject, msg.sender, address(this), amount);\n487:         CurvesERC20(externalToken).mint(msg.sender, amount * 1 ether);\n488:     }\n\n```\n",
          "loc": [
            "[465](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L465-L484)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Non constant/immutable state variables are missing a setter post deployment ",
      "description": "Non-constant or non-immutable state variables lacking a setter function can create inflexibility in contract operations. If there's no way to update these variables post-deployment, the contract might not adapt to changing conditions or requirements, which can be a significant drawback, especially in upgradable or long-lived contracts. To resolve this, implement setter functions guarded by appropriate access controls, like `onlyOwner` or similar modifiers, so that these variables can be updated as required while maintaining security. This enables smoother contract maintenance and feature upgrades.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n77: FeesEconomics public feesEconomics;\n\n```\n",
          "loc": [
            "[77](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L77-L77)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Functions with array parameters should have length checks in place ",
      "description": "Functions in Solidity that accept array parameters should incorporate length checks as a security measure. This is to prevent potential overflow errors, unwanted gas consumption, and manipulation attempts. Without length checks, an attacker could pass excessively large arrays as input, causing excessive computation and potentially causing the function to exceed the block gas limit, leading to a denial-of-service. Additionally, unexpected array sizes could lead to logic errors within the function. As a resolution, always validate array length at the start of functions handling array inputs, ensuring it aligns with the expectations of the function logic. This makes the code more robust and predictable.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n404:     function buyCurvesTokenWhitelisted(\n405:         address curvesTokenSubject,\n406:         uint256 amount,\n407:         bytes32[] memory proof // <= FOUND\n408:     ) public payable {\n409:         if (\n410:             presalesMeta[curvesTokenSubject].startTime == 0 ||\n411:             presalesMeta[curvesTokenSubject].startTime <= block.timestamp\n412:         ) revert PresaleUnavailable();\n413: \n414:         presalesBuys[curvesTokenSubject][msg.sender] += amount;\n415:         uint256 tokenBought = presalesBuys[curvesTokenSubject][msg.sender];\n416:         if (tokenBought > presalesMeta[curvesTokenSubject].maxBuy) revert ExceededMaxBuyAmount();\n417: \n418:         verifyMerkle(curvesTokenSubject, msg.sender, proof);\n419:         _buyCurvesToken(curvesTokenSubject, amount);\n420:     }\n\n```\n",
          "loc": [
            "[404](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L404-L407)"
          ]
        },
        {
          "content": "```solidity\n422:     function verifyMerkle(address curvesTokenSubject, address caller, bytes32[] memory proof) public view { // <= FOUND\n423:         \n424:         bytes32 leaf = keccak256(abi.encodePacked(caller));\n425:         if (!MerkleProof.verify(proof, presalesMeta[curvesTokenSubject].merkleRoot, leaf)) revert UnverifiedProof();\n426:     }\n\n```\n",
          "loc": [
            "[422](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L422-L422)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Overly complicated arithmetic ",
      "description": "To maintain readability in code, particularly in Solidity which can involve complex mathematical operations, it is often recommended to limit the number of arithmetic operations to a maximum of 2-3 per line. Too many operations in a single line can make the code difficult to read and understand, increase the likelihood of mistakes, and complicate the process of debugging and reviewing the code. Consider splitting such operations over more than one line, take special care when dealing with division however. Try to limit the number of arithmetic operations to a maximum of 3 per line.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n180:     function getPrice(uint256 supply, uint256 amount) public pure returns (uint256) {\n181:         uint256 sum1 = supply == 0 ? 0 : ((supply - 1) * (supply) * (2 * (supply - 1) + 1)) / 6; // <= FOUND\n182:         uint256 sum2 = supply == 0 && amount == 1\n183:             ? 0\n184:             : ((supply - 1 + amount) * (supply + amount) * (2 * (supply - 1 + amount) + 1)) / 6; // <= FOUND\n185:         uint256 summation = sum2 - sum1;\n186:         return (summation * 1 ether) / 16000;\n187:     }\n\n```\n",
          "loc": [
            "[181](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L181-L184)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Empty constructor body without natspec comments ",
      "description": "A void constructor in Solidity refers to a constructor that has no logic or code within it. It can be redundant and should be avoided because it unnecessarily increases the contract's bytecode, leading to higher deployment and gas costs. In a contract, a constructor is often used to initialize state variables or set specific conditions at the time of deployment. If no such initialization or conditions are required, the empty or void constructor serves no functional purpose. The resolution is simply to omit the constructor if it is not needed, thereby optimizing the contract for efficiency and readability.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n33:     constructor() Security() {}\n\n```\n",
          "loc": [
            "[33](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L33-L33)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Sending tokens in a for loop ",
      "description": "Performing token transfers in a loop in a Solidity contract is generally not recommended due to various reasons. One of these reasons is the \"Fail-Silently\" issue.\n\nIn a Solidity loop, if one transfer operation fails, it causes the entire transaction to fail. This issue can be particularly troublesome when you're dealing with multiple transfers in one transaction. For instance, if you're looping through an array of recipients to distribute dividends or rewards, a single failed transfer will prevent all the subsequent recipients from receiving their transfers. This could be due to the recipient contract throwing an exception or due to other issues like a gas limit being exceeded.\n\nMoreover, such a design could also inadvertently lead to a situation where a malicious contract intentionally causes a failure when receiving Ether to prevent other participants from getting their rightful transfers. This could open up avenues for griefing attacks in the system.\n\nResolution: To mitigate this problem, it's typically recommended to follow the \"withdraw pattern\" in your contracts instead of pushing payments. In this model, each recipient would be responsible for triggering their own payment. This separates each transfer operation, so a failure in one doesn't impact the others. Additionally, it greatly reduces the chance of malicious interference as the control over fund withdrawal lies with the intended recipient and not with an external loop operation.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n305:        for (uint256 i = 0; i < subjects.length; i++) {\n306:             uint256 amount = curvesTokenBalance[subjects[i]][msg.sender];\n307:             if (amount > 0) {\n308:                 _transfer(subjects[i], msg.sender, to, amount); // <= FOUND\n309:             }\n310:         }\n\n```\n",
          "loc": [
            "[305](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L305-L308)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Inconsistent comment spacing ",
      "description": "Some comments use // X and others //X Amend comments to use only use // X or //X consistently",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n44: //@dev: this is the amount of tokens that are not locked in the contract. The locked tokens are in the ERC20 contract\n\n```\n",
          "loc": [
            "[44](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L44-L44)"
          ]
        },
        {
          "content": "```solidity\n102: //@dev: this may fail if the the list is long. Get first the list with getUserTokens to estimate and prepare the batch\n\n```\n",
          "loc": [
            "[102](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L102-L102)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider adding emergency-stop functionality ",
      "description": "In the event of a security breach or any unforeseen emergency, swiftly suspending all protocol operations becomes crucial. Having a mechanism in place to halt all functions collectively, instead of pausing individual contracts separately, substantially enhances the efficiency of mitigating ongoing attacks or vulnerabilities. This not only quickens the response time to potential threats but also reduces operational stress during these critical periods. Therefore, consider integrating a 'circuit breaker' or 'emergency stop' function into the smart contract system architecture. Such a feature would provide the capability to suspend the entire protocol instantly, which could prove invaluable during a time-sensitive crisis management situation.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n41: contract Curves is CurvesErrors, Security \n\n```\n",
          "loc": [
            "[41](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L41-L41)"
          ]
        },
        {
          "content": "```solidity\n9: contract FeeSplitter is Security \n\n```\n",
          "loc": [
            "[9](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L9-L9)"
          ]
        },
        {
          "content": "```solidity\n4: contract Security \n\n```\n",
          "loc": [
            "[4](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n7: contract CurvesERC20 is ERC20, Ownable \n\n```\n",
          "loc": [
            "[7](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L7-L7)"
          ]
        },
        {
          "content": "```solidity\n6: contract CurvesERC20Factory \n\n```\n",
          "loc": [
            "[6](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20Factory.sol#L6-L6)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Duplicated revert() checks should be refactored to a modifier or function ",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n297:         if (to == address(this)) revert ContractCannotReceiveTransfer(); // <= FOUND\n\n```\n",
          "loc": [
            "[297](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L297-L297)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Missing events in sensitive functions ",
      "description": "Sensitive setter functions in smart contracts often alter critical state variables. Without events emitted in these functions, external observers or dApps cannot easily track or react to these state changes. Missing events can obscure contract activity, hampering transparency and making integration more challenging. To resolve this, incorporate appropriate event emissions within these functions. Events offer an efficient way to log crucial changes, aiding in real-time tracking and post-transaction verification.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner { // <= FOUND\n114:         feeRedistributor = FeeSplitter(payable(feeRedistributor_));\n115:     }\n\n```\n",
          "loc": [
            "[113](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L113-L113)"
          ]
        },
        {
          "content": "```solidity\n117:     function setMaxFeePercent(uint256 maxFeePercent_) external onlyManager { // <= FOUND\n118:         if (\n119:             feesEconomics.protocolFeePercent +\n120:                 feesEconomics.subjectFeePercent +\n121:                 feesEconomics.referralFeePercent +\n122:                 feesEconomics.holdersFeePercent >\n123:             maxFeePercent_\n124:         ) revert InvalidFeeDefinition();\n125:         feesEconomics.maxFeePercent = maxFeePercent_;\n126:     }\n\n```\n",
          "loc": [
            "[117](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L117-L117)"
          ]
        },
        {
          "content": "```solidity\n128:     function setProtocolFeePercent(uint256 protocolFeePercent_, address protocolFeeDestination_) external onlyOwner { // <= FOUND\n129:         if (\n130:             protocolFeePercent_ +\n131:                 feesEconomics.subjectFeePercent +\n132:                 feesEconomics.referralFeePercent +\n133:                 feesEconomics.holdersFeePercent >\n134:             feesEconomics.maxFeePercent ||\n135:             protocolFeeDestination_ == address(0)\n136:         ) revert InvalidFeeDefinition();\n137:         feesEconomics.protocolFeePercent = protocolFeePercent_;\n138:         feesEconomics.protocolFeeDestination = protocolFeeDestination_;\n139:     }\n\n```\n",
          "loc": [
            "[128](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L128-L128)"
          ]
        },
        {
          "content": "```solidity\n141:     function setExternalFeePercent( // <= FOUND\n142:         uint256 subjectFeePercent_,\n143:         uint256 referralFeePercent_,\n144:         uint256 holdersFeePercent_\n145:     ) external onlyManager {\n146:         if (\n147:             feesEconomics.protocolFeePercent + subjectFeePercent_ + referralFeePercent_ + holdersFeePercent_ >\n148:             feesEconomics.maxFeePercent\n149:         ) revert InvalidFeeDefinition();\n150:         feesEconomics.subjectFeePercent = subjectFeePercent_;\n151:         feesEconomics.referralFeePercent = referralFeePercent_;\n152:         feesEconomics.holdersFeePercent = holdersFeePercent_;\n153:     }\n\n```\n",
          "loc": [
            "[141](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L141-L141)"
          ]
        },
        {
          "content": "```solidity\n155:     function setReferralFeeDestination( // <= FOUND\n156:         address curvesTokenSubject,\n157:         address referralFeeDestination_\n158:     ) public onlyTokenSubject(curvesTokenSubject) {\n159:         referralFeeDestination[curvesTokenSubject] = referralFeeDestination_;\n160:     }\n\n```\n",
          "loc": [
            "[155](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L155-L155)"
          ]
        },
        {
          "content": "```solidity\n162:     function setERC20Factory(address factory_) external onlyOwner { // <= FOUND\n163:         curvesERC20Factory = factory_;\n164:     }\n\n```\n",
          "loc": [
            "[162](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L162-L162)"
          ]
        },
        {
          "content": "```solidity\n428:     function setNameAndSymbol( // <= FOUND\n429:         address curvesTokenSubject,\n430:         string memory name,\n431:         string memory symbol\n432:     ) external onlyTokenSubject(curvesTokenSubject) {\n433:         if (externalCurvesTokens[curvesTokenSubject].token != address(0)) revert ERC20TokenAlreadyMinted();\n434:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();\n435:         externalCurvesTokens[curvesTokenSubject].name = name;\n436:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;\n437:     }\n\n```\n",
          "loc": [
            "[428](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L428-L428)"
          ]
        },
        {
          "content": "```solidity\n23:     function setManager(address manager_, bool value) public onlyOwner { // <= FOUND\n24:         managers[manager_] = value;\n25:     }\n\n```\n",
          "loc": [
            "[23](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L23-L23)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider making private state variables internal to increase flexibility ",
      "description": "In Solidity, `private` state variables are strictly confined to the contract they are defined in and can't be accessed or modified by its derived contracts. While this offers strong encapsulation, it can limit contract extensibility and modification in inheritance chains. On the other hand, `internal` variables can be accessed and potentially overridden by child contracts, granting more flexibility in contract development and upgrades. Therefore, it's recommended to use `private` only when you explicitly want to prevent child contract access. Otherwise, prefer `internal` to maintain a balance between encapsulation and the flexibility offered by inheritance patterns in Solidity.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n47: uint256 private _curvesTokenCounter = 0; // <= FOUND\n\n```\n",
          "loc": [
            "[47](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L47-L47)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "File is missing NatSpec ",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n1: // SPDX-License-Identifier: MIT\n2: pragma solidity ^0.8.7;\n3: \n4: contract Security {\n5:     address public owner;\n6:     mapping(address => bool) public managers;\n7: \n8:     modifier onlyOwner() {\n9:         msg.sender == owner;\n10:         _;\n11:     }\n12: \n13:     modifier onlyManager() {\n14:         managers[msg.sender] == true;\n15:         _;\n16:     }\n17: \n18:     constructor() {\n19:         owner = msg.sender;\n20:         managers[msg.sender] = true;\n21:     }\n22: \n23:     function setManager(address manager_, bool value) public onlyOwner {\n24:         managers[manager_] = value;\n25:     }\n26: \n27:     function transferOwnership(address owner_) public onlyOwner {\n28:         owner = owner_;\n29:     }\n30: }\n31: \n\n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L1-L1)"
          ]
        },
        {
          "content": "```solidity\n1: // SPDX-License-Identifier: MIT\n2: pragma solidity 0.8.7;\n3: \n4: import \"@openzeppelin/contracts/utils/Strings.sol\";\n5: import \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n6: \n7: import \"./CurvesERC20.sol\";\n8: import \"./CurvesERC20Factory.sol\";\n9: \n10: import \"./FeeSplitter.sol\";\n11: import \"./Security.sol\";\n12: \n13: interface CurvesErrors {\n14:     // Access-related\n15:     error UnauthorizedCurvesTokenSubject();\n16:     // Balance-related\n17:     error InsufficientPayment();\n18:     error CannotSendFunds();\n19:     error InsufficientBalance();\n20:     // ERC20-related\n21:     error InvalidERC20Metadata();\n22:     error ERC20TokenAlreadyMinted();\n23:     // State-related\n24:     error TokenAbsentForCurvesTokenSubject();\n25:     error CurveAlreadyExists();\n26:     // Transaction-related\n27:     error LastTokenCannotBeSold();\n28:     error ContractCannotReceiveTransfer();\n29:     error ExceededMaxBuyAmount();\n30:     error NonIntegerDepositAmount();\n31:     // Proof-related\n32:     error UnverifiedProof();\n33:     // Presale-related\n34:     error PresaleUnavailable();\n35:     error InvalidPresaleStartTime();\n36:     error SaleNotOpen();\n37:     // Fee related\n38:     error InvalidFeeDefinition();\n39: }\n40: \n41: contract Curves is CurvesErrors, Security {\n42:     address public curvesERC20Factory;\n43:     FeeSplitter public feeRedistributor;\n44:     string public constant DEFAULT_NAME = \"Curves\";\n45:     string public constant DEFAULT_SYMBOL = \"CURVES\";\n46:     // Counter for CURVES tokens minted\n47:     uint256 private _curvesTokenCounter = 0;\n48: \n49:     struct ExternalTokenMeta {\n50:         string name;\n51:         string symbol;\n52:         address token;\n53:     }\n54: \n55:     struct PresaleMeta {\n56:         uint256 startTime;\n57:         bytes32 merkleRoot;\n58:         uint256 maxBuy;\n59:     }\n60: \n61:     mapping(address => ExternalTokenMeta) public externalCurvesTokens;\n62:     mapping(address => address) public externalCurvesToSubject;\n63:     mapping(string => address) public symbolToSubject;\n64: \n65:     mapping(address => PresaleMeta) public presalesMeta;\n66:     mapping(address => mapping(address => uint256)) public presalesBuys;\n67: \n68:     struct FeesEconomics {\n69:         address protocolFeeDestination;\n70:         uint256 protocolFeePercent;\n71:         uint256 subjectFeePercent;\n72:         uint256 referralFeePercent;\n73:         uint256 holdersFeePercent;\n74:         uint256 maxFeePercent;\n75:     }\n76: \n77:     FeesEconomics public feesEconomics;\n78:     mapping(address => address) public referralFeeDestination;\n79: \n80:     event Trade(\n81:         address trader,\n82:         address subject,\n83:         bool isBuy,\n84:         uint256 tokenAmount,\n85:         uint256 ethAmount,\n86:         uint256 protocolEthAmount,\n87:         uint256 subjectEthAmount,\n88:         uint256 supply\n89:     );\n90: \n91:     event Transfer(address indexed curvesTokenSubject, address indexed from, address indexed to, uint256 value);\n92:     event WhitelistUpdated(address indexed presale, bytes32 indexed root);\n93:     event TokenDeployed(address indexed curvesTokenSubject, address indexed erc20token, string name, string symbol);\n94: \n95:     // TokenSubject => (Holder => Balance)\n96:     mapping(address => mapping(address => uint256)) public curvesTokenBalance;\n97: \n98:     // TokenSubject => Supply\n99:     mapping(address => uint256) public curvesTokenSupply;\n100: \n101:     mapping(address => address[]) private ownedCurvesTokenSubjects;\n102: \n103:     modifier onlyTokenSubject(address curvesTokenSubject) {\n104:         if (curvesTokenSubject != msg.sender) revert UnauthorizedCurvesTokenSubject();\n105:         _;\n106:     }\n107: \n108:     constructor(address curvesERC20Factory_, address feeRedistributor_) Security() {\n109:         curvesERC20Factory = curvesERC20Factory_;\n110:         feeRedistributor = FeeSplitter(payable(feeRedistributor_));\n111:     }\n112: \n113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner {\n114:         feeRedistributor = FeeSplitter(payable(feeRedistributor_));\n115:     }\n116: \n117:     function setMaxFeePercent(uint256 maxFeePercent_) external onlyManager {\n118:         if (\n119:             feesEconomics.protocolFeePercent +\n120:                 feesEconomics.subjectFeePercent +\n121:                 feesEconomics.referralFeePercent +\n122:                 feesEconomics.holdersFeePercent >\n123:             maxFeePercent_\n124:         ) revert InvalidFeeDefinition();\n125:         feesEconomics.maxFeePercent = maxFeePercent_;\n126:     }\n127: \n128:     function setProtocolFeePercent(uint256 protocolFeePercent_, address protocolFeeDestination_) external onlyOwner {\n129:         if (\n130:             protocolFeePercent_ +\n131:                 feesEconomics.subjectFeePercent +\n132:                 feesEconomics.referralFeePercent +\n133:                 feesEconomics.holdersFeePercent >\n134:             feesEconomics.maxFeePercent ||\n135:             protocolFeeDestination_ == address(0)\n136:         ) revert InvalidFeeDefinition();\n137:         feesEconomics.protocolFeePercent = protocolFeePercent_;\n138:         feesEconomics.protocolFeeDestination = protocolFeeDestination_;\n139:     }\n140: \n141:     function setExternalFeePercent(\n142:         uint256 subjectFeePercent_,\n143:         uint256 referralFeePercent_,\n144:         uint256 holdersFeePercent_\n145:     ) external onlyManager {\n146:         if (\n147:             feesEconomics.protocolFeePercent + subjectFeePercent_ + referralFeePercent_ + holdersFeePercent_ >\n148:             feesEconomics.maxFeePercent\n149:         ) revert InvalidFeeDefinition();\n150:         feesEconomics.subjectFeePercent = subjectFeePercent_;\n151:         feesEconomics.referralFeePercent = referralFeePercent_;\n152:         feesEconomics.holdersFeePercent = holdersFeePercent_;\n153:     }\n154: \n155:     function setReferralFeeDestination(\n156:         address curvesTokenSubject,\n157:         address referralFeeDestination_\n158:     ) public onlyTokenSubject(curvesTokenSubject) {\n159:         referralFeeDestination[curvesTokenSubject] = referralFeeDestination_;\n160:     }\n161: \n162:     function setERC20Factory(address factory_) external onlyOwner {\n163:         curvesERC20Factory = factory_;\n164:     }\n165: \n166:     function getFees(\n167:         uint256 price\n168:     )\n169:         public\n170:         view\n171:         returns (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holdersFee, uint256 totalFee)\n172:     {\n173:         protocolFee = (price * feesEconomics.protocolFeePercent) / 1 ether;\n174:         subjectFee = (price * feesEconomics.subjectFeePercent) / 1 ether;\n175:         referralFee = (price * feesEconomics.referralFeePercent) / 1 ether;\n176:         holdersFee = (price * feesEconomics.holdersFeePercent) / 1 ether;\n177:         totalFee = protocolFee + subjectFee + referralFee + holdersFee;\n178:     }\n179: \n180:     function getPrice(uint256 supply, uint256 amount) public pure returns (uint256) {\n181:         uint256 sum1 = supply == 0 ? 0 : ((supply - 1) * (supply) * (2 * (supply - 1) + 1)) / 6;\n182:         uint256 sum2 = supply == 0 && amount == 1\n183:             ? 0\n184:             : ((supply - 1 + amount) * (supply + amount) * (2 * (supply - 1 + amount) + 1)) / 6;\n185:         uint256 summation = sum2 - sum1;\n186:         return (summation * 1 ether) / 16000;\n187:     }\n188: \n189:     function getBuyPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) {\n190:         return getPrice(curvesTokenSupply[curvesTokenSubject], amount);\n191:     }\n192: \n193:     function getSellPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) {\n194:         return getPrice(curvesTokenSupply[curvesTokenSubject] - amount, amount);\n195:     }\n196: \n197:     function getBuyPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {\n198:         uint256 price = getBuyPrice(curvesTokenSubject, amount);\n199:         (, , , , uint256 totalFee) = getFees(price);\n200: \n201:         return price + totalFee;\n202:     }\n203: \n204:     function getSellPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {\n205:         uint256 price = getSellPrice(curvesTokenSubject, amount);\n206:         (, , , , uint256 totalFee) = getFees(price);\n207: \n208:         return price - totalFee;\n209:     }\n210: \n211:     function buyCurvesToken(address curvesTokenSubject, uint256 amount) public payable {\n212:         uint256 startTime = presalesMeta[curvesTokenSubject].startTime;\n213:         if (startTime != 0 && startTime >= block.timestamp) revert SaleNotOpen();\n214: \n215:         _buyCurvesToken(curvesTokenSubject, amount);\n216:     }\n217: \n218:     function _transferFees(\n219:         address curvesTokenSubject,\n220:         bool isBuy,\n221:         uint256 price,\n222:         uint256 amount,\n223:         uint256 supply\n224:     ) internal {\n225:         (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holderFee, ) = getFees(price);\n226:         {\n227:             bool referralDefined = referralFeeDestination[curvesTokenSubject] != address(0);\n228:             {\n229:                 address firstDestination = isBuy ? feesEconomics.protocolFeeDestination : msg.sender;\n230:                 uint256 buyValue = referralDefined ? protocolFee : protocolFee + referralFee;\n231:                 uint256 sellValue = price - protocolFee - subjectFee - referralFee - holderFee;\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\");\n233:                 if (!success1) revert CannotSendFunds();\n234:             }\n235:             {\n236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}(\"\");\n237:                 if (!success2) revert CannotSendFunds();\n238:             }\n239:             {\n240:                 (bool success3, ) = referralDefined\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}(\"\")\n242:                     : (true, bytes(\"\"));\n243:                 if (!success3) revert CannotSendFunds();\n244:             }\n245: \n246:             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0)) {\n247:                 feeRedistributor.onBalanceChange(curvesTokenSubject, msg.sender);\n248:                 feeRedistributor.addFees{value: holderFee}(curvesTokenSubject);\n249:             }\n250:         }\n251:         emit Trade(\n252:             msg.sender,\n253:             curvesTokenSubject,\n254:             isBuy,\n255:             amount,\n256:             price,\n257:             protocolFee,\n258:             subjectFee,\n259:             isBuy ? supply + amount : supply - amount\n260:         );\n261:     }\n262: \n263:     function _buyCurvesToken(address curvesTokenSubject, uint256 amount) internal {\n264:         uint256 supply = curvesTokenSupply[curvesTokenSubject];\n265:         if (!(supply > 0 || curvesTokenSubject == msg.sender)) revert UnauthorizedCurvesTokenSubject();\n266: \n267:         uint256 price = getPrice(supply, amount);\n268:         (, , , , uint256 totalFee) = getFees(price);\n269: \n270:         if (msg.value < price + totalFee) revert InsufficientPayment();\n271: \n272:         curvesTokenBalance[curvesTokenSubject][msg.sender] += amount;\n273:         curvesTokenSupply[curvesTokenSubject] = supply + amount;\n274:         _transferFees(curvesTokenSubject, true, price, amount, supply);\n275: \n276:         // If is the first token bought, add to the list of owned tokens\n277:         if (curvesTokenBalance[curvesTokenSubject][msg.sender] - amount == 0) {\n278:             _addOwnedCurvesTokenSubject(msg.sender, curvesTokenSubject);\n279:         }\n280:     }\n281: \n282:     function sellCurvesToken(address curvesTokenSubject, uint256 amount) public {\n283:         uint256 supply = curvesTokenSupply[curvesTokenSubject];\n284:         if (supply <= amount) revert LastTokenCannotBeSold();\n285:         if (curvesTokenBalance[curvesTokenSubject][msg.sender] < amount) revert InsufficientBalance();\n286: \n287:         uint256 price = getPrice(supply - amount, amount);\n288: \n289:         curvesTokenBalance[curvesTokenSubject][msg.sender] -= amount;\n290:         curvesTokenSupply[curvesTokenSubject] = supply - amount;\n291: \n292:         _transferFees(curvesTokenSubject, false, price, amount, supply);\n293:     }\n294: \n295:     // Transfers tokens from current owner to receiver. Can be used for gifting or distributing tokens.\n296:     function transferCurvesToken(address curvesTokenSubject, address to, uint256 amount) external {\n297:         if (to == address(this)) revert ContractCannotReceiveTransfer();\n298:         _transfer(curvesTokenSubject, msg.sender, to, amount);\n299:     }\n300: \n301:     // Transfer the total balance of all my tokens to another address. Can be used for migrating tokens.\n302:     function transferAllCurvesTokens(address to) external {\n303:         if (to == address(this)) revert ContractCannotReceiveTransfer();\n304:         address[] storage subjects = ownedCurvesTokenSubjects[msg.sender];\n305:         for (uint256 i = 0; i < subjects.length; i++) {\n306:             uint256 amount = curvesTokenBalance[subjects[i]][msg.sender];\n307:             if (amount > 0) {\n308:                 _transfer(subjects[i], msg.sender, to, amount);\n309:             }\n310:         }\n311:     }\n312: \n313:     function _transfer(address curvesTokenSubject, address from, address to, uint256 amount) internal {\n314:         if (amount > curvesTokenBalance[curvesTokenSubject][from]) revert InsufficientBalance();\n315: \n316:         // If transferring from oneself, skip adding to the list\n317:         if (from != to) {\n318:             _addOwnedCurvesTokenSubject(to, curvesTokenSubject);\n319:         }\n320: \n321:         curvesTokenBalance[curvesTokenSubject][from] = curvesTokenBalance[curvesTokenSubject][from] - amount;\n322:         curvesTokenBalance[curvesTokenSubject][to] = curvesTokenBalance[curvesTokenSubject][to] + amount;\n323: \n324:         emit Transfer(curvesTokenSubject, from, to, amount);\n325:     }\n326: \n327:     // Internal function to add a curvesTokenSubject to the list if not already present\n328:     function _addOwnedCurvesTokenSubject(address owner_, address curvesTokenSubject) internal {\n329:         address[] storage subjects = ownedCurvesTokenSubjects[owner_];\n330:         for (uint256 i = 0; i < subjects.length; i++) {\n331:             if (subjects[i] == curvesTokenSubject) {\n332:                 return;\n333:             }\n334:         }\n335:         subjects.push(curvesTokenSubject);\n336:     }\n337: \n338:     function _deployERC20(\n339:         address curvesTokenSubject,\n340:         string memory name,\n341:         string memory symbol\n342:     ) internal returns (address) {\n343:         // If the token's symbol is CURVES, append a counter value\n344:         if (keccak256(bytes(symbol)) == keccak256(bytes(DEFAULT_SYMBOL))) {\n345:             _curvesTokenCounter += 1;\n346:             name = string(abi.encodePacked(name, \" \", Strings.toString(_curvesTokenCounter)));\n347:             symbol = string(abi.encodePacked(symbol, Strings.toString(_curvesTokenCounter)));\n348:         }\n349: \n350:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();\n351: \n352:         address tokenContract = CurvesERC20Factory(curvesERC20Factory).deploy(name, symbol, address(this));\n353: \n354:         externalCurvesTokens[curvesTokenSubject].token = tokenContract;\n355:         externalCurvesTokens[curvesTokenSubject].name = name;\n356:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;\n357:         externalCurvesToSubject[tokenContract] = curvesTokenSubject;\n358:         symbolToSubject[symbol] = curvesTokenSubject;\n359: \n360:         emit TokenDeployed(curvesTokenSubject, tokenContract, name, symbol);\n361:         return address(tokenContract);\n362:     }\n363: \n364:     function buyCurvesTokenWithName(\n365:         address curvesTokenSubject,\n366:         uint256 amount,\n367:         string memory name,\n368:         string memory symbol\n369:     ) public payable {\n370:         uint256 supply = curvesTokenSupply[curvesTokenSubject];\n371:         if (supply != 0) revert CurveAlreadyExists();\n372: \n373:         _buyCurvesToken(curvesTokenSubject, amount);\n374:         _mint(curvesTokenSubject, name, symbol);\n375:     }\n376: \n377:     function buyCurvesTokenForPresale(\n378:         address curvesTokenSubject,\n379:         uint256 amount,\n380:         uint256 startTime,\n381:         bytes32 merkleRoot,\n382:         uint256 maxBuy\n383:     ) public payable onlyTokenSubject(curvesTokenSubject) {\n384:         if (startTime <= block.timestamp) revert InvalidPresaleStartTime();\n385:         uint256 supply = curvesTokenSupply[curvesTokenSubject];\n386:         if (supply != 0) revert CurveAlreadyExists();\n387:         presalesMeta[curvesTokenSubject].startTime = startTime;\n388:         presalesMeta[curvesTokenSubject].merkleRoot = merkleRoot;\n389:         presalesMeta[curvesTokenSubject].maxBuy = (maxBuy == 0 ? type(uint256).max : maxBuy);\n390: \n391:         _buyCurvesToken(curvesTokenSubject, amount);\n392:     }\n393: \n394:     function setWhitelist(bytes32 merkleRoot) external {\n395:         uint256 supply = curvesTokenSupply[msg.sender];\n396:         if (supply > 1) revert CurveAlreadyExists();\n397: \n398:         if (presalesMeta[msg.sender].merkleRoot != merkleRoot) {\n399:             presalesMeta[msg.sender].merkleRoot = merkleRoot;\n400:             emit WhitelistUpdated(msg.sender, merkleRoot);\n401:         }\n402:     }\n403: \n404:     function buyCurvesTokenWhitelisted(\n405:         address curvesTokenSubject,\n406:         uint256 amount,\n407:         bytes32[] memory proof\n408:     ) public payable {\n409:         if (\n410:             presalesMeta[curvesTokenSubject].startTime == 0 ||\n411:             presalesMeta[curvesTokenSubject].startTime <= block.timestamp\n412:         ) revert PresaleUnavailable();\n413: \n414:         presalesBuys[curvesTokenSubject][msg.sender] += amount;\n415:         uint256 tokenBought = presalesBuys[curvesTokenSubject][msg.sender];\n416:         if (tokenBought > presalesMeta[curvesTokenSubject].maxBuy) revert ExceededMaxBuyAmount();\n417: \n418:         verifyMerkle(curvesTokenSubject, msg.sender, proof);\n419:         _buyCurvesToken(curvesTokenSubject, amount);\n420:     }\n421: \n422:     function verifyMerkle(address curvesTokenSubject, address caller, bytes32[] memory proof) public view {\n423:         // Verify merkle proof\n424:         bytes32 leaf = keccak256(abi.encodePacked(caller));\n425:         if (!MerkleProof.verify(proof, presalesMeta[curvesTokenSubject].merkleRoot, leaf)) revert UnverifiedProof();\n426:     }\n427: \n428:     function setNameAndSymbol(\n429:         address curvesTokenSubject,\n430:         string memory name,\n431:         string memory symbol\n432:     ) external onlyTokenSubject(curvesTokenSubject) {\n433:         if (externalCurvesTokens[curvesTokenSubject].token != address(0)) revert ERC20TokenAlreadyMinted();\n434:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();\n435:         externalCurvesTokens[curvesTokenSubject].name = name;\n436:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;\n437:     }\n438: \n439:     function mint(address curvesTokenSubject) external onlyTokenSubject(curvesTokenSubject) {\n440:         if (\n441:             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==\n442:             keccak256(abi.encodePacked(\"\")) ||\n443:             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==\n444:             keccak256(abi.encodePacked(\"\"))\n445:         ) {\n446:             externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME;\n447:             externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL;\n448:         }\n449:         _mint(\n450:             curvesTokenSubject,\n451:             externalCurvesTokens[curvesTokenSubject].name,\n452:             externalCurvesTokens[curvesTokenSubject].symbol\n453:         );\n454:     }\n455: \n456:     function _mint(\n457:         address curvesTokenSubject,\n458:         string memory name,\n459:         string memory symbol\n460:     ) internal onlyTokenSubject(curvesTokenSubject) {\n461:         if (externalCurvesTokens[curvesTokenSubject].token != address(0)) revert ERC20TokenAlreadyMinted();\n462:         _deployERC20(curvesTokenSubject, name, symbol);\n463:     }\n464: \n465:     function withdraw(address curvesTokenSubject, uint256 amount) public {\n466:         if (amount > curvesTokenBalance[curvesTokenSubject][msg.sender]) revert InsufficientBalance();\n467: \n468:         address externalToken = externalCurvesTokens[curvesTokenSubject].token;\n469:         if (externalToken == address(0)) {\n470:             if (\n471:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==\n472:                 keccak256(abi.encodePacked(\"\")) ||\n473:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==\n474:                 keccak256(abi.encodePacked(\"\"))\n475:             ) {\n476:                 externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME;\n477:                 externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL;\n478:             }\n479:             _deployERC20(\n480:                 curvesTokenSubject,\n481:                 externalCurvesTokens[curvesTokenSubject].name,\n482:                 externalCurvesTokens[curvesTokenSubject].symbol\n483:             );\n484:             externalToken = externalCurvesTokens[curvesTokenSubject].token;\n485:         }\n486:         _transfer(curvesTokenSubject, msg.sender, address(this), amount);\n487:         CurvesERC20(externalToken).mint(msg.sender, amount * 1 ether);\n488:     }\n489: \n490:     function deposit(address curvesTokenSubject, uint256 amount) public {\n491:         if (amount % 1 ether != 0) revert NonIntegerDepositAmount();\n492: \n493:         address externalToken = externalCurvesTokens[curvesTokenSubject].token;\n494:         uint256 tokenAmount = amount / 1 ether;\n495: \n496:         if (externalToken == address(0)) revert TokenAbsentForCurvesTokenSubject();\n497:         if (amount > CurvesERC20(externalToken).balanceOf(msg.sender)) revert InsufficientBalance();\n498:         if (tokenAmount > curvesTokenBalance[curvesTokenSubject][address(this)]) revert InsufficientBalance();\n499: \n500:         CurvesERC20(externalToken).burn(msg.sender, amount);\n501:         _transfer(curvesTokenSubject, address(this), msg.sender, tokenAmount);\n502:     }\n503: \n504:     function sellExternalCurvesToken(address curvesTokenSubject, uint256 amount) public {\n505:         if (externalCurvesTokens[curvesTokenSubject].token == address(0)) revert TokenAbsentForCurvesTokenSubject();\n506: \n507:         deposit(curvesTokenSubject, amount);\n508:         sellCurvesToken(curvesTokenSubject, amount / 1 ether);\n509:     }\n510: }\n511: \n\n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L1-L1)"
          ]
        },
        {
          "content": "```solidity\n1: // SPDX-License-Identifier: MIT\n2: pragma solidity 0.8.7;\n3: \n4: import \"./CurvesERC20.sol\";\n5: \n6: contract CurvesERC20Factory {\n7:     function deploy(string memory name, string memory symbol, address owner) public returns (address) {\n8:         CurvesERC20 tokenContract = new CurvesERC20(name, symbol, owner);\n9:         return address(tokenContract);\n10:     }\n11: }\n12: \n\n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20Factory.sol#L1-L1)"
          ]
        },
        {
          "content": "```solidity\n1: // SPDX-License-Identifier: MIT\n2: pragma solidity 0.8.7;\n3: \n4: import \"@openzeppelin/contracts/access/Ownable.sol\";\n5: import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n6: \n7: contract CurvesERC20 is ERC20, Ownable {\n8:     constructor(string memory name_, string memory symbol_, address owner) ERC20(name_, symbol_) {\n9:         transferOwnership(owner);\n10:     }\n11: \n12:     function mint(address to, uint256 amount) public onlyOwner {\n13:         _mint(to, amount);\n14:     }\n15: \n16:     function burn(address from, uint256 amount) public onlyOwner {\n17:         _burn(from, amount);\n18:     }\n19: }\n20: \n\n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L1-L1)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Shorten the array rather than copying to a new one ",
      "description": "Leveraging inline assembly in Solidity provides the ability to directly manipulate the length slot of an array, thereby altering its length without the need to copy the elements to a new array of the desired size. This technique is more gas-efficient as it avoids the computational expense associated with array duplication. However, this method circumvents the type-checking and safety mechanisms of high-level Solidity and should be used judiciously. Always ensure that the array doesn't contain vital data beyond the revised length, as this data will become unreachable yet still consume storage space.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n54:         UserClaimData[] memory result = new UserClaimData[](tokens.length); // <= FOUND\n\n```\n",
          "loc": [
            "[54](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L54-L54)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Using bools for storage incurs overhead ",
      "description": "Using boolean variables (`bool`) for storage in Solidity can incur overhead due to the way data is packed in Ethereum's storage layout. A `bool` takes a full storage slot, even though it represents only a true or false value. This leads to inefficient usage of storage space and potentially higher gas costs. To resolve this issue, developers can use bit fields or uint8/uint256 to pack multiple boolean values into a single storage slot. By employing such optimization techniques, it's possible to save on storage space and reduce gas costs, making the contract more efficient.",
      "gasSavings": 70,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n227:             bool referralDefined = referralFeeDestination[curvesTokenSubject] != address(0); // <= FOUND\n\n```\n",
          "loc": [
            "[227](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L227-L227)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Low Level Calls to Custom Addresses",
      "description": "Low-level calls (such as `.call()`, `.delegatecall()`, or `.callcode()`) in Solidity provide a way to interact with other contracts or addresses. However, when these calls are made to addresses that are provided as parameters or are not well-validated, they pose a significant security risk. Untrusted addresses might contain malicious code leading to unexpected behavior, loss of funds, or vulnerabilities.\n\n**Resolution**: Prefer using high-level Solidity function calls or interface-based interactions with known contracts to ensure security. If low-level calls are necessary, rigorously validate the addresses and test all possible interactions. Implementing additional checks and fail-safes can help mitigate potential risks associated with low-level calls.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n218:     function _transferFees(\n219:         address curvesTokenSubject,\n220:         bool isBuy,\n221:         uint256 price,\n222:         uint256 amount,\n223:         uint256 supply\n224:     ) internal {\n225:         (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holderFee, ) = getFees(price);\n226:         {\n227:             bool referralDefined = referralFeeDestination[curvesTokenSubject] != address(0);\n228:             {\n229:                 address firstDestination = isBuy ? feesEconomics.protocolFeeDestination : msg.sender;\n230:                 uint256 buyValue = referralDefined ? protocolFee : protocolFee + referralFee;\n231:                 uint256 sellValue = price - protocolFee - subjectFee - referralFee - holderFee;\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\"); // <= FOUND\n233:                 if (!success1) revert CannotSendFunds();\n234:             }\n235:             {\n236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}(\"\"); // <= FOUND\n237:                 if (!success2) revert CannotSendFunds();\n238:             }\n239:             {\n240:                 (bool success3, ) = referralDefined\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}(\"\")\n242:                     : (true, bytes(\"\"));\n243:                 if (!success3) revert CannotSendFunds();\n244:             }\n245: \n246:             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0)) {\n247:                 feeRedistributor.onBalanceChange(curvesTokenSubject, msg.sender);\n248:                 feeRedistributor.addFees{value: holderFee}(curvesTokenSubject);\n249:             }\n250:         }\n251:         emit Trade(\n252:             msg.sender,\n253:             curvesTokenSubject,\n254:             isBuy,\n255:             amount,\n256:             price,\n257:             protocolFee,\n258:             subjectFee,\n259:             isBuy ? supply + amount : supply - amount\n260:         );\n261:     }\n\n```\n",
          "loc": [
            "[218](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L218-L236)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Using Low-Level Call for Transfers",
      "description": "Utilizing low-level calls like `.call{value: value}` for Ether transfers in Ethereum can be risky, as it can inadvertently allow malicious contract executions through fallback functions. To mitigate these risks and ensure safer Ether transfers, it is recommended to adopt more secure and explicit methods provided by reputable libraries such as OpenZeppelin. Functions like `Address.sendValue()` from OpenZeppelin provide a clearer and safer alternative for sending Ether, as they encapsulate necessary checks and error handling, ensuring that Ether is transferred securely and any errors are appropriately dealt with. This not only enhances the security of your smart contract but also improves code readability and maintainability, aligning with modern Solidity development practices.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\"); // <= FOUND\n\n```\n",
          "loc": [
            "[232](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L232-L232)"
          ]
        },
        {
          "content": "```solidity\n236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}(\"\"); // <= FOUND\n\n```\n",
          "loc": [
            "[236](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L236-L236)"
          ]
        },
        {
          "content": "```solidity\n240:                 (bool success3, ) = referralDefined\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}(\"\") // <= FOUND\n\n```\n",
          "loc": [
            "[240](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L240-L241)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Low level call can be optimized with assembly",
      "description": "Low-level calls, when optimized with assembly, can save gas by avoiding unnecessary operations related to unused returndata. In a typical `.call`, Solidity automatically allocates memory and handles returndata even if it's not used, incurring extra gas costs. By using assembly, a developer can precisely control the execution, selectively ignoring or handling returndata, thereby optimizing gas usage. This specific control over the EVM allows for more efficient execution of calls by eliminating unnecessary memory operations, providing a more gas-efficient method when unused returndata is a concern. However, such optimization should be handled with care, as improper use of assembly might lead to vulnerabilities.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\"); // <= FOUND\n\n```\n",
          "loc": [
            "[232](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L232-L232)"
          ]
        },
        {
          "content": "```solidity\n236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}(\"\"); // <= FOUND\n\n```\n",
          "loc": [
            "[236](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L236-L236)"
          ]
        },
        {
          "content": "```solidity\n240:                 (bool success3, ) = referralDefined\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}(\"\") // <= FOUND\n\n```\n",
          "loc": [
            "[241](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L241-L241)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Consider Using Solady's Gas Optimized Lib for Math",
      "description": "In instances where many similar mathematical operations are performed, consider using Solday's math lib to benefit from the gas saving it can introduce.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n173:         protocolFee = (price * feesEconomics.protocolFeePercent) / 1 ether; // <= FOUND\n\n```\n",
          "loc": [
            "[173](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L173-L173)"
          ]
        },
        {
          "content": "```solidity\n174:         subjectFee = (price * feesEconomics.subjectFeePercent) / 1 ether; // <= FOUND\n\n```\n",
          "loc": [
            "[174](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L174-L174)"
          ]
        },
        {
          "content": "```solidity\n175:         referralFee = (price * feesEconomics.referralFeePercent) / 1 ether; // <= FOUND\n\n```\n",
          "loc": [
            "[175](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L175-L175)"
          ]
        },
        {
          "content": "```solidity\n176:         holdersFee = (price * feesEconomics.holdersFeePercent) / 1 ether; // <= FOUND\n\n```\n",
          "loc": [
            "[176](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L176-L176)"
          ]
        },
        {
          "content": "```solidity\n181:         uint256 sum1 = supply == 0 ? 0 : ((supply - 1) * (supply) * (2 * (supply - 1) + 1)) / 6; // <= FOUND\n\n```\n",
          "loc": [
            "[181](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L181-L181)"
          ]
        },
        {
          "content": "```solidity\n182:         uint256 sum2 = supply == 0 && amount == 1\n183:             ? 0\n184:             : ((supply - 1 + amount) * (supply + amount) * (2 * (supply - 1 + amount) + 1)) / 6; // <= FOUND\n\n```\n",
          "loc": [
            "[182](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L182-L184)"
          ]
        },
        {
          "content": "```solidity\n186:         return (summation * 1 ether) / 16000; // <= FOUND\n\n```\n",
          "loc": [
            "[186](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L186-L186)"
          ]
        },
        {
          "content": "```solidity\n93:         data.cumulativeFeePerToken += (msg.value * PRECISION) / totalSupply_; // <= FOUND\n\n```\n",
          "loc": [
            "[93](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L93-L93)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Optimize Gas by Splitting if() revert Statements",
      "description": "Optimizing gas in smart contracts is crucial for performance and cost-effectiveness. One strategy to achieve this is splitting if() statements accompanied by revert() into separate lines, rather than chaining them with the || (OR) boolean operator. This is because, in Solidity, when conditions are chained using ||, all conditions might get evaluated even if one of them is true, resulting in unnecessary gas consumption. By breaking them into separate if() statements, the contract will exit as soon as one condition is met, saving gas.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n129:         if ( // <= FOUND\n130:             protocolFeePercent_ +\n131:                 feesEconomics.subjectFeePercent +\n132:                 feesEconomics.referralFeePercent +\n133:                 feesEconomics.holdersFeePercent >\n134:             feesEconomics.maxFeePercent || // <= FOUND\n135:             protocolFeeDestination_ == address(0)\n136:         ) revert InvalidFeeDefinition(); // <= FOUND\n\n```\n",
          "loc": [
            "[129](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L129-L136)"
          ]
        },
        {
          "content": "```solidity\n265:         if (!(supply > 0 || curvesTokenSubject == msg.sender)) revert UnauthorizedCurvesTokenSubject(); // <= FOUND\n\n```\n",
          "loc": [
            "[265](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L265-L265)"
          ]
        },
        {
          "content": "```solidity\n409:         if ( // <= FOUND\n410:             presalesMeta[curvesTokenSubject].startTime == 0 || // <= FOUND\n411:             presalesMeta[curvesTokenSubject].startTime <= block.timestamp\n412:         ) revert PresaleUnavailable(); // <= FOUND\n\n```\n",
          "loc": [
            "[409](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L409-L412)"
          ]
        }
      ]
    },
    {
      "severity": "High",
      "title": "Malformed equate statement",
      "description": "Using the provided modifier `onlyOwner` for function access control without a proper enforcement mechanism like `require` or `revert` is a dire mistake because it fails to restrict access as intended. The modifier merely evaluates a condition (`msg.sender == owner`) without any action taken based on the result. This means any user, regardless of whether they are the owner, can execute functions that are supposed to be restricted to the owner, potentially leading to unauthorized actions, such as withdrawing funds or altering critical contract settings.\n\n**Solution:**\nTo fix this, the modifier should enforce the ownership check using a `require` statement:\n\n```solidity\nmodifier onlyOwner() {\n    require(msg.sender == owner, \"Caller is not the owner\");\n    _;\n}\n```\n\nWith this correction, the modifier effectively ensures that only the account designated as `owner` can access the function. If a non-owner attempts to call the function, the transaction is reverted, maintaining the intended access control and contract integrity.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n8:     modifier onlyOwner() { // <= FOUND\n9:         msg.sender == owner; // <= FOUND\n10:         _;\n11:     }\n\n```\n",
          "loc": [
            "[8](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L8-L9)"
          ]
        },
        {
          "content": "```solidity\n13:     modifier onlyManager() { // <= FOUND\n14:         managers[msg.sender] == true; // <= FOUND\n15:         _;\n16:     }\n\n```\n",
          "loc": [
            "[13](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L13-L14)"
          ]
        }
      ]
    },
    {
      "severity": "Medium",
      "title": "Privileged functions can create points of failure",
      "description": "Ensure such accounts are protected and consider implementing multi sig to prevent a single point of failure",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner  // <= FOUND\n\n```\n",
          "loc": [
            "[113](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L113-L113)"
          ]
        },
        {
          "content": "```solidity\n128:     function setProtocolFeePercent(uint256 protocolFeePercent_, address protocolFeeDestination_) external onlyOwner  // <= FOUND\n\n```\n",
          "loc": [
            "[128](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L128-L128)"
          ]
        },
        {
          "content": "```solidity\n162:     function setERC20Factory(address factory_) external onlyOwner  // <= FOUND\n\n```\n",
          "loc": [
            "[162](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L162-L162)"
          ]
        },
        {
          "content": "```solidity\n23:     function setManager(address manager_, bool value) public onlyOwner  // <= FOUND\n\n```\n",
          "loc": [
            "[23](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L23-L23)"
          ]
        },
        {
          "content": "```solidity\n12:     function mint(address to, uint256 amount) public onlyOwner  // <= FOUND\n\n```\n",
          "loc": [
            "[12](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L12-L12)"
          ]
        },
        {
          "content": "```solidity\n16:     function burn(address from, uint256 amount) public onlyOwner  // <= FOUND\n\n```\n",
          "loc": [
            "[16](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L16-L16)"
          ]
        },
        {
          "content": "```solidity\n117:     function setMaxFeePercent(uint256 maxFeePercent_) external onlyManager  // <= FOUND\n\n```\n",
          "loc": [
            "[117](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L117-L117)"
          ]
        },
        {
          "content": "```solidity\n141:     function setExternalFeePercent(\n142:         uint256 subjectFeePercent_,\n143:         uint256 referralFeePercent_,\n144:         uint256 holdersFeePercent_\n145:     ) external onlyManager  // <= FOUND\n\n```\n",
          "loc": [
            "[145](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L145-L145)"
          ]
        },
        {
          "content": "```solidity\n89:     function addFees(address token) public payable onlyManager  // <= FOUND\n\n```\n",
          "loc": [
            "[89](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L89-L89)"
          ]
        },
        {
          "content": "```solidity\n96:     function onBalanceChange(address token, address account) public onlyManager  // <= FOUND\n\n```\n",
          "loc": [
            "[96](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L96-L96)"
          ]
        }
      ]
    },
    {
      "severity": "Medium",
      "title": "Use call instead of transfer on payable addresses",
      "description": "In Solidity, when transferring Ether, `.transfer()` and `.send()` are commonly used. However, they have a limitation: they forward only a stipend of 2300 gas, which isn't enough to execute any code in the recipient contract beyond a simple event emission. Thus, if the recipient is a contract, the transfer may fail unexpectedly. \n\nTo overcome this, Solidity introduced the `.call{value: _amount}(\"\")` method, which forwards all available gas and can invoke more complex functionality. It's also safer in that it does not revert on failure but instead returns a boolean value to indicate success or failure. Therefore, it is generally a better choice to use `.call` when transferring Ether to a payable address, with the necessary safety checks implemented to handle potential errors.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n80:     function claimFees(address token) external { // <= FOUND\n81:         updateFeeCredit(token, msg.sender);\n82:         uint256 claimable = getClaimableFees(token, msg.sender);\n83:         if (claimable == 0) revert NoFeesToClaim();\n84:         tokensData[token].unclaimedFees[msg.sender] = 0;\n85:         payable(msg.sender).transfer(claimable); // <= FOUND\n86:         emit FeesClaimed(token, msg.sender, claimable);\n87:     }\n\n```\n",
          "loc": [
            "[80](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L80-L85)"
          ]
        },
        {
          "content": "```solidity\n103:     function batchClaiming(address[] calldata tokenList) external { // <= FOUND\n104:         uint256 totalClaimable = 0;\n105:         for (uint256 i = 0; i < tokenList.length; i++) {\n106:             address token = tokenList[i];\n107:             updateFeeCredit(token, msg.sender);\n108:             uint256 claimable = getClaimableFees(token, msg.sender);\n109:             if (claimable > 0) {\n110:                 tokensData[token].unclaimedFees[msg.sender] = 0;\n111:                 totalClaimable += claimable;\n112:                 emit FeesClaimed(token, msg.sender, claimable);\n113:             }\n114:         }\n115:         if (totalClaimable == 0) revert NoFeesToClaim();\n116:         payable(msg.sender).transfer(totalClaimable); // <= FOUND\n117:     }\n\n```\n",
          "loc": [
            "[103](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L103-L116)"
          ]
        }
      ]
    },
    {
      "severity": "Medium",
      "title": "NFT minting can allow JSON Injection",
      "description": "Reason: JSON injection in NFT metadata can create various vulnerabilities and manipulation tactics in the NFT ecosystem. The metadata of NFTs, often stored off-chain and referenced by URI, could be manipulated through JSON injection if unsanitized inputs are allowed. This could alter the visual representation of an NFT on platforms and mislead buyers or impact the perceived value of the asset.\n\nResolution: To protect against JSON injection, the metadata processing system should properly sanitize and validate all inputs. Smart contracts should not handle this task due to their limitations. Instead, robust off-chain server code should manage the processing, using tools designed to prevent JSON injection such as input validation, escaping special characters, and utilizing secure JSON parsing libraries. In addition, implementing strict access control to the metadata storage can further safeguard against unauthorized changes.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n456:     function _mint( // <= FOUND\n457:         address curvesTokenSubject,\n458:         string memory name, // <= FOUND\n459:         string memory symbol // <= FOUND\n460:     ) internal onlyTokenSubject(curvesTokenSubject) {\n461:         if (externalCurvesTokens[curvesTokenSubject].token != address(0)) revert ERC20TokenAlreadyMinted();\n462:         _deployERC20(curvesTokenSubject, name, symbol);\n463:     }\n\n```\n",
          "loc": [
            "[456](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L456-L459)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Empty receive functions can cause gas issues",
      "description": "In Solidity, functions that receive Ether without corresponding functionality to utilize or withdraw these funds can inadvertently lead to a permanent loss of value. This is because if someone sends Ether to the contract, they may be unable to retrieve it. To avoid this, functions receiving Ether should be accompanied by additional methods that process or allow the withdrawal of these funds. If the intent is to use the received Ether, it should trigger a separate function; if not, it should revert the transaction (for instance, via `require(msg.sender == address(weth))`). Access control checks can also prevent unintended Ether transfers, despite the slight gas cost they entail. If concerns over gas costs persist, at minimum, include a rescue function to recover unused Ether. Missteps in handling Ether in smart contracts can lead to irreversible financial losses, hence these precautions are crucial.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n119:     receive() external payable {}\n\n```\n",
          "loc": [
            "[119](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L119-L119)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Function calls within for loops",
      "description": "Making function calls or external calls within loops in Solidity can lead to inefficient gas usage, potential bottlenecks, and increased vulnerability to attacks. Each function call or external call consumes gas, and when executed within a loop, the gas cost multiplies, potentially causing the transaction to run out of gas or exceed block gas limits. This can result in transaction failure or unpredictable behavior.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n305:        for (uint256 i = 0; i < subjects.length; i++) {\n306:             uint256 amount = curvesTokenBalance[subjects[i]][msg.sender];\n307:             if (amount > 0) {\n308:                 _transfer(subjects[i], msg.sender, to, amount); // <= FOUND\n309:             }\n310:         }\n\n```\n",
          "loc": [
            "[305](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L305-L308)"
          ]
        },
        {
          "content": "```solidity\n105:        for (uint256 i = 0; i < tokenList.length; i++) {\n106:             address token = tokenList[i];\n107:             updateFeeCredit(token, msg.sender); // <= FOUND\n108:             uint256 claimable = getClaimableFees(token, msg.sender); // <= FOUND\n109:             if (claimable > 0) {\n110:                 tokensData[token].unclaimedFees[msg.sender] = 0;\n111:                 totalClaimable += claimable;\n112:                 emit FeesClaimed(token, msg.sender, claimable);\n113:             }\n114:         }\n\n```\n",
          "loc": [
            "[105](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L105-L108)"
          ]
        },
        {
          "content": "```solidity\n55:        for (uint256 i = 0; i < tokens.length; i++) {\n56:             address token = tokens[i];\n57:             uint256 claimable = getClaimableFees(token, user); // <= FOUND\n58:             result[i] = UserClaimData(claimable, token);\n59:         }\n\n```\n",
          "loc": [
            "[55](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L55-L57)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "For loops in public or external functions should be avoided due to high gas costs and possible DOS",
      "description": "In Solidity, for loops can potentially cause Denial of Service (DoS) attacks if not handled carefully. DoS attacks can occur when an attacker intentionally exploits the gas cost of a function, causing it to run out of gas or making it too expensive for other users to call. Below are some scenarios where for loops can lead to DoS attacks: Nested for loops can become exceptionally gas expensive and should be used sparingly",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n302:     function transferAllCurvesTokens(address to) external {\n303:         if (to == address(this)) revert ContractCannotReceiveTransfer();\n304:         address[] storage subjects = ownedCurvesTokenSubjects[msg.sender];\n305:         for (uint256 i = 0; i < subjects.length; i++) { // <= FOUND\n306:             uint256 amount = curvesTokenBalance[subjects[i]][msg.sender];\n307:             if (amount > 0) {\n308:                 _transfer(subjects[i], msg.sender, to, amount);\n309:             }\n310:         }\n311:     }\n\n```\n",
          "loc": [
            "[305](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L305-L305)"
          ]
        },
        {
          "content": "```solidity\n103:     function batchClaiming(address[] calldata tokenList) external {\n104:         uint256 totalClaimable = 0;\n105:         for (uint256 i = 0; i < tokenList.length; i++) { // <= FOUND\n106:             address token = tokenList[i];\n107:             updateFeeCredit(token, msg.sender);\n108:             uint256 claimable = getClaimableFees(token, msg.sender);\n109:             if (claimable > 0) {\n110:                 tokensData[token].unclaimedFees[msg.sender] = 0;\n111:                 totalClaimable += claimable;\n112:                 emit FeesClaimed(token, msg.sender, claimable);\n113:             }\n114:         }\n115:         if (totalClaimable == 0) revert NoFeesToClaim();\n116:         payable(msg.sender).transfer(totalClaimable);\n117:     }\n\n```\n",
          "loc": [
            "[105](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L105-L105)"
          ]
        },
        {
          "content": "```solidity\n52:     function getUserTokensAndClaimable(address user) public view returns (UserClaimData[] memory) {\n53:         address[] memory tokens = getUserTokens(user);\n54:         UserClaimData[] memory result = new UserClaimData[](tokens.length);\n55:         for (uint256 i = 0; i < tokens.length; i++) { // <= FOUND\n56:             address token = tokens[i];\n57:             uint256 claimable = getClaimableFees(token, user);\n58:             result[i] = UserClaimData(claimable, token);\n59:         }\n60:         return result;\n61:     }\n\n```\n",
          "loc": [
            "[55](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L55-L55)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Missing zero address check in constructor",
      "description": "In Solidity, constructors often take address parameters to initialize important components of a contract, such as owner or linked contracts. However, without a check, there's a risk that an address parameter could be mistakenly set to the zero address (0x0). This could occur due to a mistake or oversight during contract deployment. A zero address in a crucial role can cause serious issues, as it cannot perform actions like a normal address, and any funds sent to it are irretrievable. Therefore, it's crucial to include a zero address check in constructors to prevent such potential problems. If a zero address is detected, the constructor should revert the transaction.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n108:     constructor(address curvesERC20Factory_, address feeRedistributor_) Security() { // <= FOUND\n109:         curvesERC20Factory = curvesERC20Factory_;\n110:         feeRedistributor = FeeSplitter(payable(feeRedistributor_));\n111:     }\n\n```\n",
          "loc": [
            "[108](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L108-L108)"
          ]
        },
        {
          "content": "```solidity\n8:     constructor(string memory name_, string memory symbol_, address owner) ERC20(name_, symbol_) { // <= FOUND\n9:         transferOwnership(owner);\n10:     }\n\n```\n",
          "loc": [
            "[8](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L8-L8)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Use of onlyOwner functions can be lost",
      "description": "In Solidity, renouncing ownership of a contract essentially transfers ownership to the zero address. This is an irreversible operation and has considerable security implications. If the renounceOwnership function is used, the contract will lose the ability to perform any operations that are limited to the owner. This can be problematic if there are any bugs, flaws, or unexpected events that require owner intervention to resolve. Therefore, in some instances, it is better to disable or omit the renounceOwnership function, and instead implement a secure transferOwnership function. This way, if necessary, ownership can be transferred to a new, trusted party without losing the potential for administrative intervention.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n7: contract CurvesERC20 is ERC20, Ownable  // <= FOUND\n\n```\n",
          "loc": [
            "[7](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L7-L7)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Critical functions should be a two step procedure",
      "description": "Critical functions in Solidity contracts should follow a two-step procedure to enhance security, minimize human error, and ensure proper access control. By dividing sensitive operations into distinct phases, such as initiation and confirmation, developers can introduce a safeguard against unintended actions or unauthorized access.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner  // <= FOUND\n\n```\n",
          "loc": [
            "[113](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L113-L113)"
          ]
        },
        {
          "content": "```solidity\n128:     function setProtocolFeePercent(uint256 protocolFeePercent_, address protocolFeeDestination_) external onlyOwner  // <= FOUND\n\n```\n",
          "loc": [
            "[128](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L128-L128)"
          ]
        },
        {
          "content": "```solidity\n162:     function setERC20Factory(address factory_) external onlyOwner  // <= FOUND\n\n```\n",
          "loc": [
            "[162](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L162-L162)"
          ]
        },
        {
          "content": "```solidity\n23:     function setManager(address manager_, bool value) public onlyOwner  // <= FOUND\n\n```\n",
          "loc": [
            "[23](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L23-L23)"
          ]
        },
        {
          "content": "```solidity\n117:     function setMaxFeePercent(uint256 maxFeePercent_) external onlyManager  // <= FOUND\n\n```\n",
          "loc": [
            "[117](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L117-L117)"
          ]
        },
        {
          "content": "```solidity\n141:     function setExternalFeePercent( // <= FOUND\n142:         uint256 subjectFeePercent_,\n143:         uint256 referralFeePercent_,\n144:         uint256 holdersFeePercent_\n145:     ) external onlyManager \n\n```\n",
          "loc": [
            "[141](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L141-L141)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Constant decimal values",
      "description": "The use of fixed decimal values such as 1e18 or 1e8 in Solidity contracts can lead to inaccuracies, bugs, and vulnerabilities, particularly when interacting with tokens having different decimal configurations. Not all ERC20 tokens follow the standard 18 decimal places, and assumptions about decimal places can lead to miscalculations.\n\nResolution: Always retrieve and use the `decimals()` function from the token contract itself when performing calculations involving token amounts. This ensures that your contract correctly handles tokens with any number of decimal places, mitigating the risk of numerical errors or under/overflows that could jeopardize contract integrity and user funds.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n11:     uint256 constant PRECISION = 1e18; // <= FOUND\n\n```\n",
          "loc": [
            "[11](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L11-L11)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Calculation will revert when totalSupply() returns zero",
      "description": "In the instance where the function totalSupply() returns zero, it will inevitably lead to a division by zero error when used in mathematical operations, causing the transaction to fail and potentially disrupting contract functionality. This situation can inadvertently serve as a blocking mechanism, preventing valid transactions and operations. It's crucial to accommodate this special scenario in your code. One resolution could be implementing condition checks in your function to detect a zero totalSupply() and handle it differently, perhaps by returning a specific value or altering the operational flow, thus ensuring that transactions do not revert and the contract functions smoothly even in this edge case.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n89:     function addFees(address token) public payable onlyManager { // <= FOUND\n90:         uint256 totalSupply_ = totalSupply(token);\n91:         if (totalSupply_ == 0) revert NoTokenHolders();\n92:         TokenData storage data = tokensData[token];\n93:         data.cumulativeFeePerToken += (msg.value * PRECISION) / totalSupply_; // <= FOUND\n94:     }\n\n```\n",
          "loc": [
            "[89](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L89-L93)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Critical functions should have a timelock",
      "description": "Critical functions, especially those affecting protocol parameters or user funds, are potential points of failure or exploitation. To mitigate risks, incorporating a timelock on such functions can be beneficial. A timelock requires a waiting period between the time an action is initiated and when it's executed, giving stakeholders time to react, potentially vetoing malicious or erroneous changes. To implement, integrate a smart contract like OpenZeppelin's `TimelockController` or build a custom mechanism. This ensures governance decisions or administrative changes are transparent and allows for community or multi-signature interventions, enhancing protocol security and trustworthiness.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner  // <= FOUND\n\n```\n",
          "loc": [
            "[113](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L113-L113)"
          ]
        },
        {
          "content": "```solidity\n128:     function setProtocolFeePercent(uint256 protocolFeePercent_, address protocolFeeDestination_) external onlyOwner  // <= FOUND\n\n```\n",
          "loc": [
            "[128](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L128-L128)"
          ]
        },
        {
          "content": "```solidity\n162:     function setERC20Factory(address factory_) external onlyOwner  // <= FOUND\n\n```\n",
          "loc": [
            "[162](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L162-L162)"
          ]
        },
        {
          "content": "```solidity\n23:     function setManager(address manager_, bool value) public onlyOwner  // <= FOUND\n\n```\n",
          "loc": [
            "[23](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L23-L23)"
          ]
        },
        {
          "content": "```solidity\n117:     function setMaxFeePercent(uint256 maxFeePercent_) external onlyManager  // <= FOUND\n\n```\n",
          "loc": [
            "[117](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L117-L117)"
          ]
        },
        {
          "content": "```solidity\n141:     function setExternalFeePercent( // <= FOUND\n142:         uint256 subjectFeePercent_,\n143:         uint256 referralFeePercent_,\n144:         uint256 holdersFeePercent_\n145:     ) external onlyManager \n\n```\n",
          "loc": [
            "[141](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L141-L141)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Unbounded loop may run out of gas",
      "description": "Unbounded loops in smart contracts pose a risk because they iterate over an unknown number of elements, potentially consuming all available gas for a transaction. This can result in unintended transaction failures. Gas consumption increases linearly with the number of iterations, and if it surpasses the gas limit, the transaction reverts, wasting the gas spent. To mitigate this, developers should either set a maximum limit on loop iterations.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n302:     function transferAllCurvesTokens(address to) external { // <= FOUND\n303:         if (to == address(this)) revert ContractCannotReceiveTransfer();\n304:         address[] storage subjects = ownedCurvesTokenSubjects[msg.sender];\n305:         for (uint256 i = 0; i < subjects.length; i++) { // <= FOUND\n306:             uint256 amount = curvesTokenBalance[subjects[i]][msg.sender];\n307:             if (amount > 0) {\n308:                 _transfer(subjects[i], msg.sender, to, amount);\n309:             }\n310:         }\n311:     }\n\n```\n",
          "loc": [
            "[302](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L302-L305)"
          ]
        },
        {
          "content": "```solidity\n328:     function _addOwnedCurvesTokenSubject(address owner_, address curvesTokenSubject) internal { // <= FOUND\n329:         address[] storage subjects = ownedCurvesTokenSubjects[owner_];\n330:         for (uint256 i = 0; i < subjects.length; i++) { // <= FOUND\n331:             if (subjects[i] == curvesTokenSubject) {\n332:                 return;\n333:             }\n334:         }\n335:         subjects.push(curvesTokenSubject);\n336:     }\n\n```\n",
          "loc": [
            "[328](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L328-L330)"
          ]
        },
        {
          "content": "```solidity\n52:     function getUserTokensAndClaimable(address user) public view returns (UserClaimData[] memory) { // <= FOUND\n53:         address[] memory tokens = getUserTokens(user);\n54:         UserClaimData[] memory result = new UserClaimData[](tokens.length);\n55:         for (uint256 i = 0; i < tokens.length; i++) { // <= FOUND\n56:             address token = tokens[i];\n57:             uint256 claimable = getClaimableFees(token, user);\n58:             result[i] = UserClaimData(claimable, token);\n59:         }\n60:         return result;\n61:     }\n\n```\n",
          "loc": [
            "[52](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L52-L55)"
          ]
        },
        {
          "content": "```solidity\n103:     function batchClaiming(address[] calldata tokenList) external { // <= FOUND\n104:         uint256 totalClaimable = 0;\n105:         for (uint256 i = 0; i < tokenList.length; i++) { // <= FOUND\n106:             address token = tokenList[i];\n107:             updateFeeCredit(token, msg.sender);\n108:             uint256 claimable = getClaimableFees(token, msg.sender);\n109:             if (claimable > 0) {\n110:                 tokensData[token].unclaimedFees[msg.sender] = 0;\n111:                 totalClaimable += claimable;\n112:                 emit FeesClaimed(token, msg.sender, claimable);\n113:             }\n114:         }\n115:         if (totalClaimable == 0) revert NoFeesToClaim();\n116:         payable(msg.sender).transfer(totalClaimable);\n117:     }\n\n```\n",
          "loc": [
            "[103](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L103-L105)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Mapping arrays can grow in size without a way to shrink them",
      "description": "It's a good practice to maintain control over the size of array mappings in Solidity, especially if they are dynamically updated. If a contract includes a mechanism to push items into an array, it should ideally also provide a mechanism to remove items. This is because Solidity arrays don't automatically shrink when items are deleted - their length needs to be manually adjusted.\n\nIgnoring this can lead to bloated and inefficient contracts. For instance, iterating over a large array can cause your contract to hit the block gas limit. Additionally, if entries are only marked for deletion but never actually removed, you may end up dealing with stale or irrelevant data, which can cause logical errors.\n\nTherefore, implementing a method to 'pop' items from mapping arrays helps manage contract's state, improve efficiency and prevent potential issues related to gas limits or stale data. Always ensure to handle potential underflow conditions when popping elements from the mapping array.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n29:     mapping(address => address[]) internal userTokens; // <= FOUND\n\n```\n",
          "loc": [
            "[29](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L29-L29)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider implementing two-step procedure for updating protocol addresses",
      "description": "Implementing a two-step procedure for updating protocol addresses adds an extra layer of security. In such a system, the first step initiates the change, and the second step, after a predefined delay, confirms and finalizes it. This delay allows stakeholders or monitoring tools to observe and react to unintended or malicious changes. If an unauthorized change is detected, corrective actions can be taken before the change is finalized. To achieve this, introduce a \"proposed address\" state variable and a \"delay period\". Upon an update request, set the \"proposed address\". After the delay, if not contested, the main protocol address can be updated.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner { // <= FOUND\n114:         feeRedistributor = FeeSplitter(payable(feeRedistributor_));\n115:     }\n\n```\n",
          "loc": [
            "[113](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L113-L113)"
          ]
        },
        {
          "content": "```solidity\n162:     function setERC20Factory(address factory_) external onlyOwner { // <= FOUND\n163:         curvesERC20Factory = factory_;\n164:     }\n\n```\n",
          "loc": [
            "[162](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L162-L162)"
          ]
        },
        {
          "content": "```solidity\n23:     function setManager(address manager_, bool value) public onlyOwner { // <= FOUND\n24:         managers[manager_] = value;\n25:     }\n\n```\n",
          "loc": [
            "[23](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L23-L23)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use Unchecked for Divisions on Constant or Immutable Values",
      "description": "When performing divisions in Solidity, the operation costs gas and includes a check for division by zero. However, if you are dividing by a constant or an immutable value that is guaranteed to be non-zero, this check becomes unnecessary, consuming extra gas without adding safety.\n\n**Resolution**: Utilize the `unchecked` block for divisions involving constant or immutable values that are assuredly non-zero. This bypasses the additional safety checks, optimizing gas usage. Ensure thorough testing and code reviews are conducted to verify the non-zero condition of the denominator, preventing any potential division by zero errors and maintaining contract safety.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n68:             data.unclaimedFees[account] += owed / PRECISION; // <= FOUND\n\n```\n",
          "loc": [
            "[68](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L68-L68)"
          ]
        },
        {
          "content": "```solidity\n77:         return (owed / PRECISION) + data.unclaimedFees[account]; // <= FOUND\n\n```\n",
          "loc": [
            "[77](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L77-L77)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Constructors missing validation",
      "description": "In Solidity, when values are being assigned in constructors to unsigned or integer variables, it's crucial to ensure the provided values adhere to the protocol's specific operational boundaries as laid out in the project specifications and documentation. If the constructors lack appropriate validation checks, there's a risk of setting state variables with values that could cause unexpected and potentially detrimental behavior within the contract's operations, violating the intended logic of the protocol. This can compromise the contract's security and impact the maintainability and reliability of the system. In order to avoid such issues, it is recommended to incorporate rigorous validation checks in constructors. These checks should align with the project's defined rules and constraints, making use of Solidity's built-in require function to enforce these conditions. If the validation checks fail, the require function will cause the transaction to revert, ensuring the integrity and adherence to the protocol's expected behavior.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n108:     constructor(address curvesERC20Factory_, address feeRedistributor_) Security() {\n109:         curvesERC20Factory = curvesERC20Factory_; // <= FOUND ' = curvesERC20Factory_;'\n110:         feeRedistributor = FeeSplitter(payable(feeRedistributor_));\n111:     }\n\n```\n",
          "loc": [
            "[108](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L108-L109)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Functions calling contracts/addresses with transfer hooks are missing reentrancy guards",
      "description": "While adherence to the check-effects-interaction pattern is commendable, the absence of a reentrancy guard in functions, especially where transfer hooks might be present, can expose the protocol users to risks of read-only reentrancies. Such reentrancy vulnerabilities can be exploited to execute malicious actions even without altering the contract state. Without a reentrancy guard, the only potential mitigation would be to blocklist the entire protocol - an extreme and disruptive measure. Therefore, incorporating a reentrancy guard into these functions is vital to bolster security, as it helps protect against both traditional reentrancy attacks and read-only reentrancies, ensuring robust and safe protocol operations.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n465:     function withdraw(address curvesTokenSubject, uint256 amount) public { // <= FOUND\n466:         if (amount > curvesTokenBalance[curvesTokenSubject][msg.sender]) revert InsufficientBalance();\n467: \n468:         address externalToken = externalCurvesTokens[curvesTokenSubject].token;\n469:         if (externalToken == address(0)) {\n470:             if (\n471:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==\n472:                 keccak256(abi.encodePacked(\"\")) ||\n473:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==\n474:                 keccak256(abi.encodePacked(\"\"))\n475:             ) {\n476:                 externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME;\n477:                 externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL;\n478:             }\n479:             _deployERC20(\n480:                 curvesTokenSubject,\n481:                 externalCurvesTokens[curvesTokenSubject].name,\n482:                 externalCurvesTokens[curvesTokenSubject].symbol\n483:             );\n484:             externalToken = externalCurvesTokens[curvesTokenSubject].token;\n485:         }\n486:         _transfer(curvesTokenSubject, msg.sender, address(this), amount); // <= FOUND\n487:         CurvesERC20(externalToken).mint(msg.sender, amount * 1 ether);\n488:     }\n\n```\n",
          "loc": [
            "[465](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L465-L486)"
          ]
        },
        {
          "content": "```solidity\n490:     function deposit(address curvesTokenSubject, uint256 amount) public { // <= FOUND\n491:         if (amount % 1 ether != 0) revert NonIntegerDepositAmount();\n492: \n493:         address externalToken = externalCurvesTokens[curvesTokenSubject].token;\n494:         uint256 tokenAmount = amount / 1 ether;\n495: \n496:         if (externalToken == address(0)) revert TokenAbsentForCurvesTokenSubject();\n497:         if (amount > CurvesERC20(externalToken).balanceOf(msg.sender)) revert InsufficientBalance();\n498:         if (tokenAmount > curvesTokenBalance[curvesTokenSubject][address(this)]) revert InsufficientBalance();\n499: \n500:         CurvesERC20(externalToken).burn(msg.sender, amount);\n501:         _transfer(curvesTokenSubject, address(this), msg.sender, tokenAmount); // <= FOUND\n502:     }\n\n```\n",
          "loc": [
            "[490](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L490-L501)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Code injection via token name",
      "description": "Code injection via token names primarily poses a threat to frontends interacting with smart contracts, especially in scenarios where these frontends display token information fetched from the blockchain. This vulnerability arises when contracts store or transmit token names, symbols, or other string metadata that a malicious token contract might manipulate. If the frontend fails to sanitize this data properly, it could execute harmful scripts or display misleading information, leading to security breaches like phishing attacks or data theft.\n\n**Resolution:**\nTo mitigate this risk, frontend applications should always treat token metadata (names, symbols, etc.) obtained from smart contracts as untrusted data. Implementing rigorous sanitization and validation routines on the frontend can prevent the execution of any embedded scripts or malicious code. This includes encoding or escaping strings before rendering them in the browser, using content security policies (CSP), and avoiding direct DOM manipulation with untrusted data. Regularly updating and auditing the frontend code for vulnerabilities related to handling external data is also crucial for maintaining robust security against potential code injection threats.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n338:     function _deployERC20(\n339:         address curvesTokenSubject,\n340:         string memory name,\n341:         string memory symbol\n342:     ) internal returns (address) {\n343:         \n344:         if (keccak256(bytes(symbol)) == keccak256(bytes(DEFAULT_SYMBOL))) {\n345:             _curvesTokenCounter += 1;\n346:             name = string(abi.encodePacked(name, \" \", Strings.toString(_curvesTokenCounter)));\n347:             symbol = string(abi.encodePacked(symbol, Strings.toString(_curvesTokenCounter)));\n348:         }\n349: \n350:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();\n351: \n352:         address tokenContract = CurvesERC20Factory(curvesERC20Factory).deploy(name, symbol, address(this));\n353: \n354:         externalCurvesTokens[curvesTokenSubject].token = tokenContract;\n355:         externalCurvesTokens[curvesTokenSubject].name = name; // <= FOUND\n356:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;\n357:         externalCurvesToSubject[tokenContract] = curvesTokenSubject;\n358:         symbolToSubject[symbol] = curvesTokenSubject;\n359: \n360:         emit TokenDeployed(curvesTokenSubject, tokenContract, name, symbol);\n361:         return address(tokenContract);\n362:     }\n\n```\n",
          "loc": [
            "[355](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L355-L355)"
          ]
        },
        {
          "content": "```solidity\n428:     function setNameAndSymbol(\n429:         address curvesTokenSubject,\n430:         string memory name,\n431:         string memory symbol\n432:     ) external onlyTokenSubject(curvesTokenSubject) {\n433:         if (externalCurvesTokens[curvesTokenSubject].token != address(0)) revert ERC20TokenAlreadyMinted();\n434:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();\n435:         externalCurvesTokens[curvesTokenSubject].name = name; // <= FOUND\n436:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;\n437:     }\n\n```\n",
          "loc": [
            "[435](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L435-L435)"
          ]
        },
        {
          "content": "```solidity\n439:     function mint(address curvesTokenSubject) external onlyTokenSubject(curvesTokenSubject) {\n440:         if (\n441:             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) == // <= FOUND\n442:             keccak256(abi.encodePacked(\"\")) ||\n443:             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==\n444:             keccak256(abi.encodePacked(\"\"))\n445:         ) {\n446:             externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME; // <= FOUND\n447:             externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL;\n448:         }\n449:         _mint(\n450:             curvesTokenSubject,\n451:             externalCurvesTokens[curvesTokenSubject].name, // <= FOUND\n452:             externalCurvesTokens[curvesTokenSubject].symbol\n453:         );\n454:     }\n\n```\n",
          "loc": [
            "[441](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L441-L451)"
          ]
        },
        {
          "content": "```solidity\n465:     function withdraw(address curvesTokenSubject, uint256 amount) public {\n466:         if (amount > curvesTokenBalance[curvesTokenSubject][msg.sender]) revert InsufficientBalance();\n467: \n468:         address externalToken = externalCurvesTokens[curvesTokenSubject].token;\n469:         if (externalToken == address(0)) {\n470:             if (\n471:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) == // <= FOUND\n472:                 keccak256(abi.encodePacked(\"\")) ||\n473:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==\n474:                 keccak256(abi.encodePacked(\"\"))\n475:             ) {\n476:                 externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME; // <= FOUND\n477:                 externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL;\n478:             }\n479:             _deployERC20(\n480:                 curvesTokenSubject,\n481:                 externalCurvesTokens[curvesTokenSubject].name, // <= FOUND\n482:                 externalCurvesTokens[curvesTokenSubject].symbol\n483:             );\n484:             externalToken = externalCurvesTokens[curvesTokenSubject].token;\n485:         }\n486:         _transfer(curvesTokenSubject, msg.sender, address(this), amount);\n487:         CurvesERC20(externalToken).mint(msg.sender, amount * 1 ether);\n488:     }\n\n```\n",
          "loc": [
            "[471](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L471-L481)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Upgradeable contract uses non-upgradeable version of the OpenZeppelin libraries/contracts",
      "description": "Using the upgradeable counterpart of the OpenZeppelin (OZ) library in Solidity is beneficial for creating contracts that can be updated in the future. OpenZeppelin's upgradeable contracts library is designed with proxy patterns in mind, which allow the logic of contracts to be upgraded while preserving the contract's state and address. This can be crucial for long-lived contracts where future requirements or improvements may not be fully known at the time of deployment. The upgradeable OZ contracts also include protection against a class of vulnerabilities related to initialization of storage variables in upgradeable contracts. Hence, it's a good idea to use them when developing contracts that may need to be upgraded in the future, as they provide a solid foundation for secure and upgradeable smart contracts.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n7: import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // <= FOUND 'openzeppelin'\n\n```\n",
          "loc": [
            "[7](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L7-L7)"
          ]
        },
        {
          "content": "```solidity\n5: import \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\"; // <= FOUND 'openzeppelin'\n\n```\n",
          "loc": [
            "[5](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L5-L5)"
          ]
        },
        {
          "content": "```solidity\n5: import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; // <= FOUND 'openzeppelin'\n\n```\n",
          "loc": [
            "[5](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L5-L5)"
          ]
        },
        {
          "content": "```solidity\n4: import \"@openzeppelin/contracts/access/Ownable.sol\"; // <= FOUND 'openzeppelin'\n\n```\n",
          "loc": [
            "[4](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n4: import \"@openzeppelin/contracts/utils/Strings.sol\"; // <= FOUND 'openzeppelin'\n\n```\n",
          "loc": [
            "[4](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L4-L4)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Solidity version 0.8.20 won't work on all chains due to PUSH0",
      "description": "Solidity version 0.8.20 uses the new Shanghai EVM which introduces the PUSH0 opcode, this may not be implemented on all chains and L2 thus reducing the portability and compatability of the code. Consider using a earlier solidity version.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n2: pragma solidity ^0.8.7; // <= FOUND\n\n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L2-L2)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Unsafe use of transfer()/transferFrom() with IERC20",
      "description": "SafeTransfer should be used in place of Transfer for Solidity contracts to ensure robust security and error handling. Unlike the basic Transfer function, SafeTransfer incorporates safeguards against potential smart contract vulnerabilities, such as reentrancy attacks and unexpected token loss. By automatically validating the recipient's ability to receive tokens and reverting transactions in case of failures, ",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n465:     function withdraw(address curvesTokenSubject, uint256 amount) public { // <= FOUND\n466:         if (amount > curvesTokenBalance[curvesTokenSubject][msg.sender]) revert InsufficientBalance();\n467: \n468:         address externalToken = externalCurvesTokens[curvesTokenSubject].token;\n469:         if (externalToken == address(0)) {\n470:             if (\n471:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==\n472:                 keccak256(abi.encodePacked(\"\")) ||\n473:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==\n474:                 keccak256(abi.encodePacked(\"\"))\n475:             ) {\n476:                 externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME;\n477:                 externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL;\n478:             }\n479:             _deployERC20(\n480:                 curvesTokenSubject,\n481:                 externalCurvesTokens[curvesTokenSubject].name,\n482:                 externalCurvesTokens[curvesTokenSubject].symbol\n483:             );\n484:             externalToken = externalCurvesTokens[curvesTokenSubject].token;\n485:         }\n486:         _transfer(curvesTokenSubject, msg.sender, address(this), amount); // <= FOUND\n487:         CurvesERC20(externalToken).mint(msg.sender, amount * 1 ether);\n488:     }\n\n```\n",
          "loc": [
            "[465](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L465-L486)"
          ]
        },
        {
          "content": "```solidity\n490:     function deposit(address curvesTokenSubject, uint256 amount) public { // <= FOUND\n491:         if (amount % 1 ether != 0) revert NonIntegerDepositAmount();\n492: \n493:         address externalToken = externalCurvesTokens[curvesTokenSubject].token;\n494:         uint256 tokenAmount = amount / 1 ether;\n495: \n496:         if (externalToken == address(0)) revert TokenAbsentForCurvesTokenSubject();\n497:         if (amount > CurvesERC20(externalToken).balanceOf(msg.sender)) revert InsufficientBalance();\n498:         if (tokenAmount > curvesTokenBalance[curvesTokenSubject][address(this)]) revert InsufficientBalance();\n499: \n500:         CurvesERC20(externalToken).burn(msg.sender, amount);\n501:         _transfer(curvesTokenSubject, address(this), msg.sender, tokenAmount); // <= FOUND\n502:     }\n\n```\n",
          "loc": [
            "[490](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L490-L501)"
          ]
        },
        {
          "content": "```solidity\n80:     function claimFees(address token) external { // <= FOUND\n81:         updateFeeCredit(token, msg.sender);\n82:         uint256 claimable = getClaimableFees(token, msg.sender);\n83:         if (claimable == 0) revert NoFeesToClaim();\n84:         tokensData[token].unclaimedFees[msg.sender] = 0;\n85:         payable(msg.sender).transfer(claimable); // <= FOUND\n86:         emit FeesClaimed(token, msg.sender, claimable);\n87:     }\n\n```\n",
          "loc": [
            "[80](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L80-L85)"
          ]
        },
        {
          "content": "```solidity\n103:     function batchClaiming(address[] calldata tokenList) external { // <= FOUND\n104:         uint256 totalClaimable = 0;\n105:         for (uint256 i = 0; i < tokenList.length; i++) {\n106:             address token = tokenList[i];\n107:             updateFeeCredit(token, msg.sender);\n108:             uint256 claimable = getClaimableFees(token, msg.sender);\n109:             if (claimable > 0) {\n110:                 tokensData[token].unclaimedFees[msg.sender] = 0;\n111:                 totalClaimable += claimable;\n112:                 emit FeesClaimed(token, msg.sender, claimable);\n113:             }\n114:         }\n115:         if (totalClaimable == 0) revert NoFeesToClaim();\n116:         payable(msg.sender).transfer(totalClaimable); // <= FOUND\n117:     }\n\n```\n",
          "loc": [
            "[103](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L103-L116)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Floating pragma should be avoided",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n2: pragma solidity ^0.8.7; // <= FOUND\n\n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L2-L2)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Instances should be declared in a separate file",
      "description": "It is general standard to declare interfaces on files separate from regular contract declarations",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n13: interface CurvesErrors  // <= FOUND\n\n```\n",
          "loc": [
            "[13](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L13-L13)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Events regarding state variable changes should emit the previous state variable value",
      "description": "Modify such events to contain the previous value of the state variable as demonstrated in the example below",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n92: event WhitelistUpdated(address indexed presale, bytes32 indexed root);\n\n```\n",
          "loc": [
            "[92](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L92-L92)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "In functions which accept an address as a parameter, there should be a zero address check to prevent bugs",
      "description": "In smart contract development, especially with Solidity, it's crucial to validate inputs to functions. When a function accepts an Ethereum address as a parameter, implementing a zero address check (i.e., ensuring the address is not `0x0`) is a best practice to prevent potential bugs and vulnerabilities. The zero address (`0x0`) is a default value and generally indicates an uninitialized or invalid state. Passing the zero address to certain functions can lead to unintended behaviors, like funds getting locked permanently or transactions failing silently. By checking for and rejecting the zero address, developers can ensure that the function operates as intended and interacts only with valid Ethereum addresses. This check enhances the contract's robustness and security.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner \n\n```\n",
          "loc": [
            "[113](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L113-L113)"
          ]
        },
        {
          "content": "```solidity\n155:     function setReferralFeeDestination(\n156:         address curvesTokenSubject,\n157:         address referralFeeDestination_\n158:     ) public onlyTokenSubject(curvesTokenSubject) \n\n```\n",
          "loc": [
            "[155](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L155-L155)"
          ]
        },
        {
          "content": "```solidity\n162:     function setERC20Factory(address factory_) external onlyOwner \n\n```\n",
          "loc": [
            "[162](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L162-L162)"
          ]
        },
        {
          "content": "```solidity\n189:     function getBuyPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) \n\n```\n",
          "loc": [
            "[189](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L189-L189)"
          ]
        },
        {
          "content": "```solidity\n193:     function getSellPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) \n\n```\n",
          "loc": [
            "[193](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L193-L193)"
          ]
        },
        {
          "content": "```solidity\n197:     function getBuyPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) \n\n```\n",
          "loc": [
            "[197](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L197-L197)"
          ]
        },
        {
          "content": "```solidity\n204:     function getSellPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) \n\n```\n",
          "loc": [
            "[204](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L204-L204)"
          ]
        },
        {
          "content": "```solidity\n211:     function buyCurvesToken(address curvesTokenSubject, uint256 amount) public payable \n\n```\n",
          "loc": [
            "[211](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L211-L211)"
          ]
        },
        {
          "content": "```solidity\n263:     function _buyCurvesToken(address curvesTokenSubject, uint256 amount) internal \n\n```\n",
          "loc": [
            "[263](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L263-L263)"
          ]
        },
        {
          "content": "```solidity\n282:     function sellCurvesToken(address curvesTokenSubject, uint256 amount) public \n\n```\n",
          "loc": [
            "[282](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L282-L282)"
          ]
        },
        {
          "content": "```solidity\n296:     function transferCurvesToken(address curvesTokenSubject, address to, uint256 amount) external \n\n```\n",
          "loc": [
            "[296](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L296-L296)"
          ]
        },
        {
          "content": "```solidity\n302:     function transferAllCurvesTokens(address to) external \n\n```\n",
          "loc": [
            "[302](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L302-L302)"
          ]
        },
        {
          "content": "```solidity\n313:     function _transfer(address curvesTokenSubject, address from, address to, uint256 amount) internal \n\n```\n",
          "loc": [
            "[313](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L313-L313)"
          ]
        },
        {
          "content": "```solidity\n328:     function _addOwnedCurvesTokenSubject(address owner_, address curvesTokenSubject) internal \n\n```\n",
          "loc": [
            "[328](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L328-L328)"
          ]
        },
        {
          "content": "```solidity\n364:     function buyCurvesTokenWithName(\n365:         address curvesTokenSubject,\n366:         uint256 amount,\n367:         string memory name,\n368:         string memory symbol\n369:     ) public payable \n\n```\n",
          "loc": [
            "[364](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L364-L364)"
          ]
        },
        {
          "content": "```solidity\n377:     function buyCurvesTokenForPresale(\n378:         address curvesTokenSubject,\n379:         uint256 amount,\n380:         uint256 startTime,\n381:         bytes32 merkleRoot,\n382:         uint256 maxBuy\n383:     ) public payable onlyTokenSubject(curvesTokenSubject) \n\n```\n",
          "loc": [
            "[377](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L377-L377)"
          ]
        },
        {
          "content": "```solidity\n404:     function buyCurvesTokenWhitelisted(\n405:         address curvesTokenSubject,\n406:         uint256 amount,\n407:         bytes32[] memory proof\n408:     ) public payable \n\n```\n",
          "loc": [
            "[404](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L404-L404)"
          ]
        },
        {
          "content": "```solidity\n422:     function verifyMerkle(address curvesTokenSubject, address caller, bytes32[] memory proof) public view \n\n```\n",
          "loc": [
            "[422](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L422-L422)"
          ]
        },
        {
          "content": "```solidity\n439:     function mint(address curvesTokenSubject) external onlyTokenSubject(curvesTokenSubject) \n\n```\n",
          "loc": [
            "[439](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L439-L439)"
          ]
        },
        {
          "content": "```solidity\n39:     function balanceOf(address token, address account) public view returns (uint256) \n\n```\n",
          "loc": [
            "[39](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L39-L39)"
          ]
        },
        {
          "content": "```solidity\n43:     function totalSupply(address token) public view returns (uint256) \n\n```\n",
          "loc": [
            "[43](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L43-L43)"
          ]
        },
        {
          "content": "```solidity\n48:     function getUserTokens(address user) public view returns (address[] memory) \n\n```\n",
          "loc": [
            "[48](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L48-L48)"
          ]
        },
        {
          "content": "```solidity\n52:     function getUserTokensAndClaimable(address user) public view returns (UserClaimData[] memory) \n\n```\n",
          "loc": [
            "[52](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L52-L52)"
          ]
        },
        {
          "content": "```solidity\n63:     function updateFeeCredit(address token, address account) internal \n\n```\n",
          "loc": [
            "[63](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L63-L63)"
          ]
        },
        {
          "content": "```solidity\n73:     function getClaimableFees(address token, address account) public view returns (uint256) \n\n```\n",
          "loc": [
            "[73](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L73-L73)"
          ]
        },
        {
          "content": "```solidity\n80:     function claimFees(address token) external \n\n```\n",
          "loc": [
            "[80](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L80-L80)"
          ]
        },
        {
          "content": "```solidity\n89:     function addFees(address token) public payable onlyManager \n\n```\n",
          "loc": [
            "[89](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L89-L89)"
          ]
        },
        {
          "content": "```solidity\n96:     function onBalanceChange(address token, address account) public onlyManager \n\n```\n",
          "loc": [
            "[96](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L96-L96)"
          ]
        },
        {
          "content": "```solidity\n103:     function batchClaiming(address[] calldata tokenList) external \n\n```\n",
          "loc": [
            "[103](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L103-L103)"
          ]
        },
        {
          "content": "```solidity\n23:     function setManager(address manager_, bool value) public onlyOwner \n\n```\n",
          "loc": [
            "[23](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L23-L23)"
          ]
        },
        {
          "content": "```solidity\n27:     function transferOwnership(address owner_) public onlyOwner \n\n```\n",
          "loc": [
            "[27](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L27-L27)"
          ]
        },
        {
          "content": "```solidity\n12:     function mint(address to, uint256 amount) public onlyOwner \n\n```\n",
          "loc": [
            "[12](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L12-L12)"
          ]
        },
        {
          "content": "```solidity\n16:     function burn(address from, uint256 amount) public onlyOwner \n\n```\n",
          "loc": [
            "[16](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L16-L16)"
          ]
        },
        {
          "content": "```solidity\n7:     function deploy(string memory name, string memory symbol, address owner) public returns (address) \n\n```\n",
          "loc": [
            "[7](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20Factory.sol#L7-L7)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use safeTransferOwnership instead of transferOwnership",
      "description": "SafeTransferOwnership should be used in place of transferOwner in Solidity contracts to enhance security and error handling. Unlike the basic transferOwner function, SafeTransferOwnership incorporates checks to validate the new owner's address and ensures that the transfer is executed only after receiving the new owner's confirmation. This additional layer of protection prevents accidental ownership transfers and mitigates the risk of locking a contract due to an invalid or unintended address assignment.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n27:     function transferOwnership(address owner_) public onlyOwner  // <= FOUND\n\n```\n",
          "loc": [
            "[27](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L27-L27)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Default int values are manually set",
      "description": "In instances where a new variable is defined, there is no need to set it to it's default value.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n47:     \n48:     uint256 private _curvesTokenCounter = 0; // <= FOUND\n\n```\n",
          "loc": [
            "[47](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L47-L48)"
          ]
        },
        {
          "content": "```solidity\n104:         uint256 totalClaimable = 0; // <= FOUND\n\n```\n",
          "loc": [
            "[104](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L104-L104)"
          ]
        },
        {
          "content": "```solidity\n305:         for (uint256 i = 0; i < subjects.length; i++) { // <= FOUND\n\n```\n",
          "loc": [
            "[305](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L305-L305)"
          ]
        },
        {
          "content": "```solidity\n55:         for (uint256 i = 0; i < tokens.length; i++) { // <= FOUND\n\n```\n",
          "loc": [
            "[55](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L55-L55)"
          ]
        },
        {
          "content": "```solidity\n105:         for (uint256 i = 0; i < tokenList.length; i++) { // <= FOUND\n\n```\n",
          "loc": [
            "[105](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L105-L105)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Ownable2Step should be used in place of Ownable",
      "description": "Ownable2Step further prevents risks posed by centralised privileges as there is a smaller likelihood of the owner being wrongfully changed",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n7: contract CurvesERC20 is ERC20, Ownable  // <= FOUND\n\n```\n",
          "loc": [
            "[7](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L7-L7)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Revert statements within external and public functions can be used to perform DOS attacks",
      "description": "In Solidity, 'revert' statements are used to undo changes and throw an exception when certain conditions are not met. However, in public and external functions, improper use of `revert` can be exploited for Denial of Service (DoS) attacks. An attacker can intentionally trigger these 'revert' conditions, causing legitimate transactions to consistently fail. For example, if a function relies on specific conditions from user input or contract state, an attacker could manipulate these to continually force reverts, blocking the function's execution. Therefore, it's crucial to design contract logic to handle exceptions properly and avoid scenarios where `revert` can be predictably triggered by malicious actors. This includes careful input validation and considering alternative design patterns that are less susceptible to such abuses.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n117:     function setMaxFeePercent(uint256 maxFeePercent_) external onlyManager {\n118:         if (\n119:             feesEconomics.protocolFeePercent +\n120:                 feesEconomics.subjectFeePercent +\n121:                 feesEconomics.referralFeePercent +\n122:                 feesEconomics.holdersFeePercent >\n123:             maxFeePercent_\n124:         ) revert InvalidFeeDefinition(); // <= FOUND\n125:         feesEconomics.maxFeePercent = maxFeePercent_;\n126:     }\n\n```\n",
          "loc": [
            "[124](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L124-L124)"
          ]
        },
        {
          "content": "```solidity\n128:     function setProtocolFeePercent(uint256 protocolFeePercent_, address protocolFeeDestination_) external onlyOwner {\n129:         if (\n130:             protocolFeePercent_ +\n131:                 feesEconomics.subjectFeePercent +\n132:                 feesEconomics.referralFeePercent +\n133:                 feesEconomics.holdersFeePercent >\n134:             feesEconomics.maxFeePercent ||\n135:             protocolFeeDestination_ == address(0)\n136:         ) revert InvalidFeeDefinition(); // <= FOUND\n137:         feesEconomics.protocolFeePercent = protocolFeePercent_;\n138:         feesEconomics.protocolFeeDestination = protocolFeeDestination_;\n139:     }\n\n```\n",
          "loc": [
            "[136](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L136-L136)"
          ]
        },
        {
          "content": "```solidity\n141:     function setExternalFeePercent(\n142:         uint256 subjectFeePercent_,\n143:         uint256 referralFeePercent_,\n144:         uint256 holdersFeePercent_\n145:     ) external onlyManager {\n146:         if (\n147:             feesEconomics.protocolFeePercent + subjectFeePercent_ + referralFeePercent_ + holdersFeePercent_ >\n148:             feesEconomics.maxFeePercent\n149:         ) revert InvalidFeeDefinition(); // <= FOUND\n150:         feesEconomics.subjectFeePercent = subjectFeePercent_;\n151:         feesEconomics.referralFeePercent = referralFeePercent_;\n152:         feesEconomics.holdersFeePercent = holdersFeePercent_;\n153:     }\n\n```\n",
          "loc": [
            "[149](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L149-L149)"
          ]
        },
        {
          "content": "```solidity\n296:     function transferCurvesToken(address curvesTokenSubject, address to, uint256 amount) external {\n297:         if (to == address(this)) revert ContractCannotReceiveTransfer(); // <= FOUND\n298:         _transfer(curvesTokenSubject, msg.sender, to, amount);\n299:     }\n\n```\n",
          "loc": [
            "[297](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L297-L297)"
          ]
        },
        {
          "content": "```solidity\n302:     function transferAllCurvesTokens(address to) external {\n303:         if (to == address(this)) revert ContractCannotReceiveTransfer(); // <= FOUND\n304:         address[] storage subjects = ownedCurvesTokenSubjects[msg.sender];\n305:         for (uint256 i = 0; i < subjects.length; i++) {\n306:             uint256 amount = curvesTokenBalance[subjects[i]][msg.sender];\n307:             if (amount > 0) {\n308:                 _transfer(subjects[i], msg.sender, to, amount);\n309:             }\n310:         }\n311:     }\n\n```\n",
          "loc": [
            "[303](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L303-L303)"
          ]
        },
        {
          "content": "```solidity\n394:     function setWhitelist(bytes32 merkleRoot) external {\n395:         uint256 supply = curvesTokenSupply[msg.sender];\n396:         if (supply > 1) revert CurveAlreadyExists(); // <= FOUND\n397: \n398:         if (presalesMeta[msg.sender].merkleRoot != merkleRoot) {\n399:             presalesMeta[msg.sender].merkleRoot = merkleRoot;\n400:             emit WhitelistUpdated(msg.sender, merkleRoot);\n401:         }\n402:     }\n\n```\n",
          "loc": [
            "[396](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L396-L396)"
          ]
        },
        {
          "content": "```solidity\n428:     function setNameAndSymbol(\n429:         address curvesTokenSubject,\n430:         string memory name,\n431:         string memory symbol\n432:     ) external onlyTokenSubject(curvesTokenSubject) {\n433:         if (externalCurvesTokens[curvesTokenSubject].token != address(0)) revert ERC20TokenAlreadyMinted(); // <= FOUND\n434:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata(); // <= FOUND\n435:         externalCurvesTokens[curvesTokenSubject].name = name;\n436:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;\n437:     }\n\n```\n",
          "loc": [
            "[433](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L433-L434)"
          ]
        },
        {
          "content": "```solidity\n80:     function claimFees(address token) external {\n81:         updateFeeCredit(token, msg.sender);\n82:         uint256 claimable = getClaimableFees(token, msg.sender);\n83:         if (claimable == 0) revert NoFeesToClaim(); // <= FOUND\n84:         tokensData[token].unclaimedFees[msg.sender] = 0;\n85:         payable(msg.sender).transfer(claimable);\n86:         emit FeesClaimed(token, msg.sender, claimable);\n87:     }\n\n```\n",
          "loc": [
            "[83](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L83-L83)"
          ]
        },
        {
          "content": "```solidity\n103:     function batchClaiming(address[] calldata tokenList) external {\n104:         uint256 totalClaimable = 0;\n105:         for (uint256 i = 0; i < tokenList.length; i++) {\n106:             address token = tokenList[i];\n107:             updateFeeCredit(token, msg.sender);\n108:             uint256 claimable = getClaimableFees(token, msg.sender);\n109:             if (claimable > 0) {\n110:                 tokensData[token].unclaimedFees[msg.sender] = 0;\n111:                 totalClaimable += claimable;\n112:                 emit FeesClaimed(token, msg.sender, claimable);\n113:             }\n114:         }\n115:         if (totalClaimable == 0) revert NoFeesToClaim(); // <= FOUND\n116:         payable(msg.sender).transfer(totalClaimable);\n117:     }\n\n```\n",
          "loc": [
            "[115](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L115-L115)"
          ]
        },
        {
          "content": "```solidity\n211:     function buyCurvesToken(address curvesTokenSubject, uint256 amount) public payable {\n212:         uint256 startTime = presalesMeta[curvesTokenSubject].startTime;\n213:         if (startTime != 0 && startTime >= block.timestamp) revert SaleNotOpen(); // <= FOUND\n214: \n215:         _buyCurvesToken(curvesTokenSubject, amount);\n216:     }\n\n```\n",
          "loc": [
            "[213](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L213-L213)"
          ]
        },
        {
          "content": "```solidity\n282:     function sellCurvesToken(address curvesTokenSubject, uint256 amount) public {\n283:         uint256 supply = curvesTokenSupply[curvesTokenSubject];\n284:         if (supply <= amount) revert LastTokenCannotBeSold(); // <= FOUND\n285:         if (curvesTokenBalance[curvesTokenSubject][msg.sender] < amount) revert InsufficientBalance(); // <= FOUND\n286: \n287:         uint256 price = getPrice(supply - amount, amount);\n288: \n289:         curvesTokenBalance[curvesTokenSubject][msg.sender] -= amount;\n290:         curvesTokenSupply[curvesTokenSubject] = supply - amount;\n291: \n292:         _transferFees(curvesTokenSubject, false, price, amount, supply);\n293:     }\n\n```\n",
          "loc": [
            "[284](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L284-L285)"
          ]
        },
        {
          "content": "```solidity\n364:     function buyCurvesTokenWithName(\n365:         address curvesTokenSubject,\n366:         uint256 amount,\n367:         string memory name,\n368:         string memory symbol\n369:     ) public payable {\n370:         uint256 supply = curvesTokenSupply[curvesTokenSubject];\n371:         if (supply != 0) revert CurveAlreadyExists(); // <= FOUND\n372: \n373:         _buyCurvesToken(curvesTokenSubject, amount);\n374:         _mint(curvesTokenSubject, name, symbol);\n375:     }\n\n```\n",
          "loc": [
            "[371](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L371-L371)"
          ]
        },
        {
          "content": "```solidity\n377:     function buyCurvesTokenForPresale(\n378:         address curvesTokenSubject,\n379:         uint256 amount,\n380:         uint256 startTime,\n381:         bytes32 merkleRoot,\n382:         uint256 maxBuy\n383:     ) public payable onlyTokenSubject(curvesTokenSubject) {\n384:         if (startTime <= block.timestamp) revert InvalidPresaleStartTime(); // <= FOUND\n385:         uint256 supply = curvesTokenSupply[curvesTokenSubject];\n386:         if (supply != 0) revert CurveAlreadyExists(); // <= FOUND\n387:         presalesMeta[curvesTokenSubject].startTime = startTime;\n388:         presalesMeta[curvesTokenSubject].merkleRoot = merkleRoot;\n389:         presalesMeta[curvesTokenSubject].maxBuy = (maxBuy == 0 ? type(uint256).max : maxBuy);\n390: \n391:         _buyCurvesToken(curvesTokenSubject, amount);\n392:     }\n\n```\n",
          "loc": [
            "[384](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L384-L386)"
          ]
        },
        {
          "content": "```solidity\n404:     function buyCurvesTokenWhitelisted(\n405:         address curvesTokenSubject,\n406:         uint256 amount,\n407:         bytes32[] memory proof\n408:     ) public payable {\n409:         if (\n410:             presalesMeta[curvesTokenSubject].startTime == 0 ||\n411:             presalesMeta[curvesTokenSubject].startTime <= block.timestamp\n412:         ) revert PresaleUnavailable(); // <= FOUND\n413: \n414:         presalesBuys[curvesTokenSubject][msg.sender] += amount;\n415:         uint256 tokenBought = presalesBuys[curvesTokenSubject][msg.sender];\n416:         if (tokenBought > presalesMeta[curvesTokenSubject].maxBuy) revert ExceededMaxBuyAmount(); // <= FOUND\n417: \n418:         verifyMerkle(curvesTokenSubject, msg.sender, proof);\n419:         _buyCurvesToken(curvesTokenSubject, amount);\n420:     }\n\n```\n",
          "loc": [
            "[412](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L412-L416)"
          ]
        },
        {
          "content": "```solidity\n422:     function verifyMerkle(address curvesTokenSubject, address caller, bytes32[] memory proof) public view {\n423:         \n424:         bytes32 leaf = keccak256(abi.encodePacked(caller));\n425:         if (!MerkleProof.verify(proof, presalesMeta[curvesTokenSubject].merkleRoot, leaf)) revert UnverifiedProof(); // <= FOUND\n426:     }\n\n```\n",
          "loc": [
            "[425](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L425-L425)"
          ]
        },
        {
          "content": "```solidity\n465:     function withdraw(address curvesTokenSubject, uint256 amount) public {\n466:         if (amount > curvesTokenBalance[curvesTokenSubject][msg.sender]) revert InsufficientBalance(); // <= FOUND\n467: \n468:         address externalToken = externalCurvesTokens[curvesTokenSubject].token;\n469:         if (externalToken == address(0)) {\n470:             if (\n471:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==\n472:                 keccak256(abi.encodePacked(\"\")) ||\n473:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==\n474:                 keccak256(abi.encodePacked(\"\"))\n475:             ) {\n476:                 externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME;\n477:                 externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL;\n478:             }\n479:             _deployERC20(\n480:                 curvesTokenSubject,\n481:                 externalCurvesTokens[curvesTokenSubject].name,\n482:                 externalCurvesTokens[curvesTokenSubject].symbol\n483:             );\n484:             externalToken = externalCurvesTokens[curvesTokenSubject].token;\n485:         }\n486:         _transfer(curvesTokenSubject, msg.sender, address(this), amount);\n487:         CurvesERC20(externalToken).mint(msg.sender, amount * 1 ether);\n488:     }\n\n```\n",
          "loc": [
            "[466](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L466-L466)"
          ]
        },
        {
          "content": "```solidity\n490:     function deposit(address curvesTokenSubject, uint256 amount) public {\n491:         if (amount % 1 ether != 0) revert NonIntegerDepositAmount(); // <= FOUND\n492: \n493:         address externalToken = externalCurvesTokens[curvesTokenSubject].token;\n494:         uint256 tokenAmount = amount / 1 ether;\n495: \n496:         if (externalToken == address(0)) revert TokenAbsentForCurvesTokenSubject(); // <= FOUND\n497:         if (amount > CurvesERC20(externalToken).balanceOf(msg.sender)) revert InsufficientBalance(); // <= FOUND\n498:         if (tokenAmount > curvesTokenBalance[curvesTokenSubject][address(this)]) revert InsufficientBalance(); // <= FOUND\n499: \n500:         CurvesERC20(externalToken).burn(msg.sender, amount);\n501:         _transfer(curvesTokenSubject, address(this), msg.sender, tokenAmount);\n502:     }\n\n```\n",
          "loc": [
            "[491](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L491-L498)"
          ]
        },
        {
          "content": "```solidity\n504:     function sellExternalCurvesToken(address curvesTokenSubject, uint256 amount) public {\n505:         if (externalCurvesTokens[curvesTokenSubject].token == address(0)) revert TokenAbsentForCurvesTokenSubject(); // <= FOUND\n506: \n507:         deposit(curvesTokenSubject, amount);\n508:         sellCurvesToken(curvesTokenSubject, amount / 1 ether);\n509:     }\n\n```\n",
          "loc": [
            "[505](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L505-L505)"
          ]
        },
        {
          "content": "```solidity\n89:     function addFees(address token) public payable onlyManager {\n90:         uint256 totalSupply_ = totalSupply(token);\n91:         if (totalSupply_ == 0) revert NoTokenHolders(); // <= FOUND\n92:         TokenData storage data = tokensData[token];\n93:         data.cumulativeFeePerToken += (msg.value * PRECISION) / totalSupply_;\n94:     }\n\n```\n",
          "loc": [
            "[91](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L91-L91)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Functions which are either private or internal should have a preceding _ in their name",
      "description": "Add a preceding underscore to the function name, take care to refactor where there functions are called",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n63:     function updateFeeCredit(address token, address account) internal \n\n```\n",
          "loc": [
            "[63](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L63-L63)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Contract lines should not be longer than 120 characters for readability",
      "description": "Consider spreading these lines over multiple lines to aid in readability and the support of VIM users everywhere.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n44:         //@dev: this is the amount of tokens that are not locked in the contract. The locked tokens are in the ERC20 contract // <= FOUND\n\n```\n",
          "loc": [
            "[44](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L44-L44)"
          ]
        },
        {
          "content": "```solidity\n102:     //@dev: this may fail if the the list is long. Get first the list with getUserTokens to estimate and prepare the batch // <= FOUND\n\n```\n",
          "loc": [
            "[102](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L102-L102)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Setters should prevent re-setting of the same value",
      "description": "In Solidity, manipulating contract storage comes with significant gas costs. One can optimize gas usage by preventing unnecessary storage updates when the new value is the same as the existing one. If an existing value is the same as the new one, not reassigning it to the storage could potentially save substantial amounts of gas, notably 2900 gas for a 'Gsreset'. This saving may come at the expense of a cold storage load operation ('Gcoldsload'), which costs 2100 gas, or a warm storage access operation ('Gwarmaccess'), which costs 100 gas. Therefore, the gas efficiency of your contract can be significantly improved by adding a check that compares the new value with the current one before any storage update operation. If the values are the same, you can bypass the storage operation, thereby saving gas.",
      "gasSavings": 4000,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner {\n114:         feeRedistributor = FeeSplitter(payable(feeRedistributor_));\n115:     }\n\n```\n",
          "loc": [
            "[113](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L113-L113)"
          ]
        },
        {
          "content": "```solidity\n162:     function setERC20Factory(address factory_) external onlyOwner {\n163:         curvesERC20Factory = factory_;\n164:     }\n\n```\n",
          "loc": [
            "[162](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L162-L162)"
          ]
        },
        {
          "content": "```solidity\n23:     function setManager(address manager_, bool value) public onlyOwner {\n24:         managers[manager_] = value;\n25:     }\n\n```\n",
          "loc": [
            "[23](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L23-L23)"
          ]
        },
        {
          "content": "```solidity\n117:     function setMaxFeePercent(uint256 maxFeePercent_) external onlyManager {\n118:         if (\n119:             feesEconomics.protocolFeePercent +\n120:                 feesEconomics.subjectFeePercent +\n121:                 feesEconomics.referralFeePercent +\n122:                 feesEconomics.holdersFeePercent >\n123:             maxFeePercent_\n124:         ) revert InvalidFeeDefinition();\n125:         feesEconomics.maxFeePercent = maxFeePercent_;\n126:     }\n\n```\n",
          "loc": [
            "[117](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L117-L117)"
          ]
        },
        {
          "content": "```solidity\n141:     function setExternalFeePercent(\n142:         uint256 subjectFeePercent_,\n143:         uint256 referralFeePercent_,\n144:         uint256 holdersFeePercent_\n145:     ) external onlyManager {\n146:         if (\n147:             feesEconomics.protocolFeePercent + subjectFeePercent_ + referralFeePercent_ + holdersFeePercent_ >\n148:             feesEconomics.maxFeePercent\n149:         ) revert InvalidFeeDefinition();\n150:         feesEconomics.subjectFeePercent = subjectFeePercent_;\n151:         feesEconomics.referralFeePercent = referralFeePercent_;\n152:         feesEconomics.holdersFeePercent = holdersFeePercent_;\n153:     }\n\n```\n",
          "loc": [
            "[141](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L141-L141)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Specific imports should be used where possible so only used code is imported",
      "description": "In many cases only some functionality is used from an import. In such cases it makes more sense to use {} to specify what to import and thus save gas whilst improving readability",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n4: import \"@openzeppelin/contracts/utils/Strings.sol\";\n\n```\n",
          "loc": [
            "[4](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n5: import \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n```\n",
          "loc": [
            "[5](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L5-L5)"
          ]
        },
        {
          "content": "```solidity\n7: import \"./CurvesERC20.sol\";\n\n```\n",
          "loc": [
            "[7](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L7-L7)"
          ]
        },
        {
          "content": "```solidity\n8: import \"./CurvesERC20Factory.sol\";\n\n```\n",
          "loc": [
            "[8](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L8-L8)"
          ]
        },
        {
          "content": "```solidity\n10: import \"./FeeSplitter.sol\";\n\n```\n",
          "loc": [
            "[10](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L10-L10)"
          ]
        },
        {
          "content": "```solidity\n11: import \"./Security.sol\";\n\n```\n",
          "loc": [
            "[11](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L11-L11)"
          ]
        },
        {
          "content": "```solidity\n4: import \"./Curves.sol\";\n\n```\n",
          "loc": [
            "[4](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n7: import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n```\n",
          "loc": [
            "[7](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L7-L7)"
          ]
        },
        {
          "content": "```solidity\n4: import \"@openzeppelin/contracts/access/Ownable.sol\";\n\n```\n",
          "loc": [
            "[4](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n5: import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n```\n",
          "loc": [
            "[5](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L5-L5)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use newer solidity versions",
      "description": "Newer solidity versions have new functionality and are generally more gas efficient too (0.8.19) as such it makes sense to use them provided it is safe to do so",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n2: pragma solidity 0.8.7;\n\n```\n",
          "loc": [
            ""
          ]
        },
        {
          "content": "```solidity\n2: pragma solidity ^0.8.7;\n\n```\n",
          "loc": [
            ""
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Not all event definitions are utilizing indexed variables.",
      "description": "Try to index as much as three variables in event declarations as this is more gas efficient when done on value type variables (uint, address etc) however not for bytes and string variables ",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n80: event Trade( // <= FOUND\n81:         address trader,\n82:         address subject,\n83:         bool isBuy,\n84:         uint256 tokenAmount,\n85:         uint256 ethAmount,\n86:         uint256 protocolEthAmount,\n87:         uint256 subjectEthAmount,\n88:         uint256 supply\n89:     );\n\n```\n",
          "loc": [
            "[80](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L80-L80)"
          ]
        },
        {
          "content": "```solidity\n31: event FeesClaimed(address indexed token, address indexed user, uint256 amount); // <= FOUND\n\n```\n",
          "loc": [
            "[31](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L31-L31)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Functions within contracts are not ordered according to the solidity style guide",
      "description": "The following order should be used within contracts\n\nconstructor\n\nreceive function (if exists)\n\nfallback function (if exists)\n\nexternal\n\npublic\n\ninternal\n\nprivate\n\nRearrange the contract functions and contructors to fit this ordering",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n41: contract Curves is CurvesErrors, Security  // <= FOUND\n\n```\n",
          "loc": [
            "[41](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L41-L41)"
          ]
        },
        {
          "content": "```solidity\n9: contract FeeSplitter is Security  // <= FOUND\n\n```\n",
          "loc": [
            "[9](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L9-L9)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Functions which set address state variables should have zero address checks",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner {\n114:         feeRedistributor = FeeSplitter(payable(feeRedistributor_));\n115:     }\n\n```\n",
          "loc": [
            "[113](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L113-L113)"
          ]
        },
        {
          "content": "```solidity\n155:     function setReferralFeeDestination(\n156:         address curvesTokenSubject,\n157:         address referralFeeDestination_\n158:     ) public onlyTokenSubject(curvesTokenSubject) {\n159:         referralFeeDestination[curvesTokenSubject] = referralFeeDestination_;\n160:     }\n\n```\n",
          "loc": [
            "[155](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L155-L155)"
          ]
        },
        {
          "content": "```solidity\n162:     function setERC20Factory(address factory_) external onlyOwner {\n163:         curvesERC20Factory = factory_;\n164:     }\n\n```\n",
          "loc": [
            "[162](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L162-L162)"
          ]
        },
        {
          "content": "```solidity\n23:     function setManager(address manager_, bool value) public onlyOwner {\n24:         managers[manager_] = value;\n25:     }\n\n```\n",
          "loc": [
            "[23](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L23-L23)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Interface imports should be declared first",
      "description": "Amend the ordering of imports to import interfaces first followed by other imports",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n2: \n3: pragma solidity ^0.8.7;\n4: \n5: import \"./Curves.sol\"; // <= FOUND\n6: import \"./Security.sol\"; // <= FOUND\n7: \n8: import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // <= FOUND\n9: \n10: contract FeeSplitter is Security {\n11:     Curves public curves;\n12:     uint256 constant PRECISION = 1e18;\n13: \n15:     error NoFeesToClaim();\n16:     error NoTokenHolders();\n17: \n18:     struct TokenData {\n19:         uint256 cumulativeFeePerToken;\n20:         mapping(address => uint256) userFeeOffset;\n21:         mapping(address => uint256) unclaimedFees;\n22:     }\n23: \n24:     struct UserClaimData {\n25:         uint256 claimableFees;\n26:         address token;\n27:     }\n28: \n29:     mapping(address => TokenData) internal tokensData;\n30:     mapping(address => address[]) internal userTokens;\n31: \n32:     event FeesClaimed(address indexed token, address indexed user, uint256 amount);\n33: \n34:     constructor() Security() {}\n35: \n36:     function setCurves(Curves curves_) public {\n37:         curves = curves_;\n38:     }\n39: \n40:     function balanceOf(address token, address account) public view returns (uint256) {\n41:         return curves.curvesTokenBalance(token, account) * PRECISION;\n42:     }\n43: \n44:     function totalSupply(address token) public view returns (uint256) {\n45:         \n46:         return (curves.curvesTokenSupply(token) - curves.curvesTokenBalance(token, address(curves))) * PRECISION;\n47:     }\n48: \n49:     function getUserTokens(address user) public view returns (address[] memory) {\n50:         return userTokens[user];\n51:     }\n52: \n53:     function getUserTokensAndClaimable(address user) public view returns (UserClaimData[] memory) {\n54:         address[] memory tokens = getUserTokens(user);\n55:         UserClaimData[] memory result = new UserClaimData[](tokens.length);\n56:         for (uint256 i = 0; i < tokens.length; i++) {\n57:             address token = tokens[i];\n58:             uint256 claimable = getClaimableFees(token, user);\n\n```\n",
          "loc": [
            "[5](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L5-L8)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use allowlist/denylist rather than whitelist/blacklist",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n92:     event WhitelistUpdated(address indexed presale, bytes32 indexed root); // <= FOUND\n\n```\n",
          "loc": [
            "[92](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L92-L92)"
          ]
        },
        {
          "content": "```solidity\n394: \n395:     function setWhitelist(bytes32 merkleRoot) external { // <= FOUND\n\n```\n",
          "loc": [
            "[395](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L395-L395)"
          ]
        },
        {
          "content": "```solidity\n400:             emit WhitelistUpdated(msg.sender, merkleRoot); // <= FOUND\n\n```\n",
          "loc": [
            "[400](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L400-L400)"
          ]
        },
        {
          "content": "```solidity\n404: \n405:     function buyCurvesTokenWhitelisted( // <= FOUND\n406:         address curvesTokenSubject,\n407:         uint256 amount,\n408:         bytes32[] memory proof\n409:     ) public payable {\n\n```\n",
          "loc": [
            "[405](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L405-L405)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Multiple mappings can be replaced with a single struct mapping",
      "description": "Using a single struct mapping in place of multiple defined mappings in a Solidity contract can lead to improved code organization, better readability, and easier maintainability. By consolidating related data into a single struct, developers can create a more cohesive data structure that logically groups together relevant pieces of information, thus reducing redundancy and clutter. This approach simplifies the codebase, making it easier to understand, navigate, and modify. Additionally, it can result in more efficient gas usage when accessing or updating multiple related data points simultaneously. ",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n41: contract Curves is CurvesErrors, Security {\n42:     address public curvesERC20Factory;\n43:     FeeSplitter public feeRedistributor;\n44:     string public constant DEFAULT_NAME = \"Curves\";\n45:     string public constant DEFAULT_SYMBOL = \"CURVES\";\n46:     \n47:     uint256 private _curvesTokenCounter = 0;\n48: \n53:     mapping(address => ExternalTokenMeta) public externalCurvesTokens; // <= FOUND\n54:     mapping(address => address) public externalCurvesToSubject; // <= FOUND\n55:     mapping(string => address) public symbolToSubject; // <= FOUND\n56: \n57:     mapping(address => PresaleMeta) public presalesMeta; // <= FOUND\n58:     mapping(address => mapping(address => uint256)) public presalesBuys; // <= FOUND\n59: \n62:     FeesEconomics public feesEconomics;\n63:     mapping(address => address) public referralFeeDestination; // <= FOUND\n64: \n72:     mapping(address => mapping(address => uint256)) public curvesTokenBalance; // <= FOUND\n73: \n75:     mapping(address => uint256) public curvesTokenSupply; // <= FOUND\n76: \n77:     mapping(address => address[]) private ownedCurvesTokenSubjects; // <= FOUND\n78: \n149: }\n\n```\n",
          "loc": [
            "[53](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L53-L77)"
          ]
        },
        {
          "content": "```solidity\n9: contract FeeSplitter is Security {\n10:     Curves public curves;\n11:     uint256 constant PRECISION = 1e18;\n12: \n21:     mapping(address => TokenData) internal tokensData; // <= FOUND\n22:     mapping(address => address[]) internal userTokens; // <= FOUND\n23: \n52: }\n\n```\n",
          "loc": [
            "[21](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L21-L22)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Keccak hashes which never change can be made into a constant state variable",
      "description": "There is no point in using GAS to calculate a kaccak hash which never changes",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n439:     function mint(address curvesTokenSubject) external onlyTokenSubject(curvesTokenSubject) { // <= FOUND\n440:         if (\n441:             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==\n442:             keccak256(abi.encodePacked(\"\")) ||\n443:             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==\n444:             keccak256(abi.encodePacked(\"\"))\n445:         ) {\n446:             externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME;\n447:             externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL;\n448:         }\n449:         _mint(\n450:             curvesTokenSubject,\n451:             externalCurvesTokens[curvesTokenSubject].name,\n452:             externalCurvesTokens[curvesTokenSubject].symbol\n453:         );\n454:     }\n\n```\n",
          "loc": [
            "[439](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L439-L439)"
          ]
        },
        {
          "content": "```solidity\n465:     function withdraw(address curvesTokenSubject, uint256 amount) public { // <= FOUND\n466:         if (amount > curvesTokenBalance[curvesTokenSubject][msg.sender]) revert InsufficientBalance();\n467: \n468:         address externalToken = externalCurvesTokens[curvesTokenSubject].token;\n469:         if (externalToken == address(0)) {\n470:             if (\n471:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==\n472:                 keccak256(abi.encodePacked(\"\")) ||\n473:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==\n474:                 keccak256(abi.encodePacked(\"\"))\n475:             ) {\n476:                 externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME;\n477:                 externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL;\n478:             }\n479:             _deployERC20(\n480:                 curvesTokenSubject,\n481:                 externalCurvesTokens[curvesTokenSubject].name,\n482:                 externalCurvesTokens[curvesTokenSubject].symbol\n483:             );\n484:             externalToken = externalCurvesTokens[curvesTokenSubject].token;\n485:         }\n486:         _transfer(curvesTokenSubject, msg.sender, address(this), amount);\n487:         CurvesERC20(externalToken).mint(msg.sender, amount * 1 ether);\n488:     }\n\n```\n",
          "loc": [
            "[465](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L465-L465)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Constants should be on the left side of the ",
      "description": "Putting constants on the left side of a comparison operator like `==` or `<` is a best practice known as \"Yoda conditions\", which can help prevent accidental assignment instead of comparison. In some programming languages, if a variable is mistakenly put on the left with a single `=` instead of `==`, it assigns the constant's value to the variable without any compiler error. However, doing this with the constant on the left would generate an error, as constants cannot be assigned values. Although Solidity's static typing system prevents accidental assignments within conditionals, adopting this practice enhances code readability and consistency, especially when developers are working across multiple languages that support this convention.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n277:         if (curvesTokenBalance[curvesTokenSubject][msg.sender] - amount == 0)  // <= FOUND\n\n```\n",
          "loc": [
            "[277](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L277-L277)"
          ]
        },
        {
          "content": "```solidity\n66:         if (balance > 0)  // <= FOUND\n\n```\n",
          "loc": [
            "[66](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L66-L66)"
          ]
        },
        {
          "content": "```solidity\n246:             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0))  // <= FOUND\n\n```\n",
          "loc": [
            "[246](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L246-L246)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Interface names should have an I as the first character",
      "description": "Modify such instances to include a capital I as the first character in the name to signify it is an interface. This improved readability during in",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n13: interface CurvesErrors \n\n```\n",
          "loc": [
            "[13](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L13-L13)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider using named mappings",
      "description": "In Solidity version 0.8.18 and beyond mapping parameters can be named. This makes the purpose and function of a given mapping far clearer which in turn improves readability.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n6:     mapping(address => bool) public managers; // <= FOUND\n\n```\n",
          "loc": [
            "[6](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L6-L6)"
          ]
        },
        {
          "content": "```solidity\n62:     mapping(address => address) public externalCurvesToSubject; // <= FOUND\n\n```\n",
          "loc": [
            "[62](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L62-L62)"
          ]
        },
        {
          "content": "```solidity\n63:     mapping(string => address) public symbolToSubject; // <= FOUND\n\n```\n",
          "loc": [
            "[63](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L63-L63)"
          ]
        },
        {
          "content": "```solidity\n78:     mapping(address => address) public referralFeeDestination; // <= FOUND\n\n```\n",
          "loc": [
            "[78](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L78-L78)"
          ]
        },
        {
          "content": "```solidity\n66:     mapping(address => mapping(address => uint256)) public presalesBuys; // <= FOUND\n\n```\n",
          "loc": [
            "[66](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L66-L66)"
          ]
        },
        {
          "content": "```solidity\n96:     mapping(address => mapping(address => uint256)) public curvesTokenBalance; // <= FOUND\n\n```\n",
          "loc": [
            "[96](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L96-L96)"
          ]
        },
        {
          "content": "```solidity\n99:     mapping(address => uint256) public curvesTokenSupply; // <= FOUND\n\n```\n",
          "loc": [
            "[99](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L99-L99)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Loss of precision",
      "description": "Dividing by large numbers in Solidity can cause a loss of precision due to the language's inherent integer division behavior. Solidity does not support floating-point arithmetic, and as a result, division between integers yields an integer result, truncating any fractional part. When dividing by a large number, the resulting value may become significantly smaller, leading to a loss of precision, as the fractional part is discarded.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n73:     function getClaimableFees(address token, address account) public view returns (uint256) { // <= FOUND\n74:         TokenData storage data = tokensData[token];\n75:         uint256 balance = balanceOf(token, account);\n76:         uint256 owed = (data.cumulativeFeePerToken - data.userFeeOffset[account]) * balance;\n77:         return (owed / PRECISION) + data.unclaimedFees[account]; // <= FOUND\n78:     }\n\n```\n",
          "loc": [
            "[73](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L73-L77)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use a single contract or library for system wide constants",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n41: contract Curves is CurvesErrors, Security {\n42:     address public curvesERC20Factory;\n43:     FeeSplitter public feeRedistributor;\n44:     string public constant DEFAULT_NAME = \"Curves\"; // <= FOUND\n45:     string public constant DEFAULT_SYMBOL = \"CURVES\"; // <= FOUND\n46:     \n47:     uint256 private _curvesTokenCounter = 0;\n48: \n53:     mapping(address => ExternalTokenMeta) public externalCurvesTokens;\n54:     mapping(address => address) public externalCurvesToSubject;\n55:     mapping(string => address) public symbolToSubject;\n56: \n57:     mapping(address => PresaleMeta) public presalesMeta;\n58:     mapping(address => mapping(address => uint256)) public presalesBuys;\n59: \n62:     FeesEconomics public feesEconomics;\n63:     mapping(address => address) public referralFeeDestination;\n64: \n72:     mapping(address => mapping(address => uint256)) public curvesTokenBalance;\n73: \n75:     mapping(address => uint256) public curvesTokenSupply;\n76: \n77:     mapping(address => address[]) private ownedCurvesTokenSubjects;\n78: \n149: }\n\n```\n",
          "loc": [
            "[44](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L44-L45)"
          ]
        },
        {
          "content": "```solidity\n9: contract FeeSplitter is Security {\n10:     Curves public curves;\n11:     uint256 constant PRECISION = 1e18; // <= FOUND\n12: \n21:     mapping(address => TokenData) internal tokensData;\n22:     mapping(address => address[]) internal userTokens;\n23: \n52: }\n\n```\n",
          "loc": [
            "[11](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L11-L11)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider using modifiers for address control",
      "description": "Modifiers in Solidity can improve code readability and modularity by encapsulating repetitive checks, such as address validity checks, into a reusable construct. For example, an `onlyOwner` modifier can be used to replace repetitive `require(msg.sender == owner)` checks across several functions, reducing code redundancy and enhancing maintainability. To implement, define a modifier with the check, then apply the modifier to relevant functions.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n9:         msg.sender == owner; // <= FOUND\n\n```\n",
          "loc": [
            "[9](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L9-L9)"
          ]
        },
        {
          "content": "```solidity\n265:         if (!(supply > 0 || curvesTokenSubject == msg.sender)) revert UnauthorizedCurvesTokenSubject(); // <= FOUND\n\n```\n",
          "loc": [
            "[265](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L265-L265)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Off-by-one timestamp error",
      "description": "In Solidity, using `>=` or `<=` to compare against `block.timestamp` (alias `now`) may introduce off-by-one errors due to the fact that `block.timestamp` is only updated once per block and its value remains constant throughout the block's execution. If an operation happens at the exact second when `block.timestamp` changes, it could result in unexpected behavior. To avoid this, it's safer to use strict inequality operators (`>` or `<`). For instance, if a condition should only be met after a certain time, use `block.timestamp > time` rather than `block.timestamp >= time`. This way, potential off-by-one errors due to the exact timing of block mining are mitigated, leading to safer, more predictable contract behavior.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n211:     function buyCurvesToken(address curvesTokenSubject, uint256 amount) public payable { // <= FOUND\n212:         uint256 startTime = presalesMeta[curvesTokenSubject].startTime;\n213:         if (startTime != 0 && startTime >= block.timestamp) revert SaleNotOpen(); // <= FOUND\n214: \n215:         _buyCurvesToken(curvesTokenSubject, amount);\n216:     }\n\n```\n",
          "loc": [
            "[211](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L211-L213)"
          ]
        },
        {
          "content": "```solidity\n377:     function buyCurvesTokenForPresale(\n378:         address curvesTokenSubject,\n379:         uint256 amount,\n380:         uint256 startTime,\n381:         bytes32 merkleRoot,\n382:         uint256 maxBuy\n383:     ) public payable onlyTokenSubject(curvesTokenSubject) {\n384:         if (startTime <= block.timestamp) revert InvalidPresaleStartTime();\n385:         uint256 supply = curvesTokenSupply[curvesTokenSubject];\n386:         if (supply != 0) revert CurveAlreadyExists();\n387:         presalesMeta[curvesTokenSubject].startTime = startTime;\n388:         presalesMeta[curvesTokenSubject].merkleRoot = merkleRoot;\n389:         presalesMeta[curvesTokenSubject].maxBuy = (maxBuy == 0 ? type(uint256).max : maxBuy);\n390: \n391:         _buyCurvesToken(curvesTokenSubject, amount);\n392:     }\n\n```\n",
          "loc": [
            "[377](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L377-L377)"
          ]
        },
        {
          "content": "```solidity\n404:     function buyCurvesTokenWhitelisted(\n405:         address curvesTokenSubject,\n406:         uint256 amount,\n407:         bytes32[] memory proof\n408:     ) public payable {\n409:         if (\n410:             presalesMeta[curvesTokenSubject].startTime == 0 ||\n411:             presalesMeta[curvesTokenSubject].startTime <= block.timestamp\n412:         ) revert PresaleUnavailable();\n413: \n414:         presalesBuys[curvesTokenSubject][msg.sender] += amount;\n415:         uint256 tokenBought = presalesBuys[curvesTokenSubject][msg.sender];\n416:         if (tokenBought > presalesMeta[curvesTokenSubject].maxBuy) revert ExceededMaxBuyAmount();\n417: \n418:         verifyMerkle(curvesTokenSubject, msg.sender, proof);\n419:         _buyCurvesToken(curvesTokenSubject, amount);\n420:     }\n\n```\n",
          "loc": [
            "[404](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L404-L404)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Default address(0) can be returned",
      "description": "Allowing a function in Solidity to return the default address (address(0)) can be problematic as it can represent uninitialized or invalid addresses. If such an address is utilized in transfer operations or other sensitive actions, it could lead to loss of funds or unpredicted behavior. It's prudent to include checks in your functions to prevent the return of the zero address, enhancing contract security.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n7:     function deploy(string memory name, string memory symbol, address owner) public returns (address) {\n8:         CurvesERC20 tokenContract = new CurvesERC20(name, symbol, owner);\n9:         return address(tokenContract);\n10:     }\n\n```\n",
          "loc": [
            "[7](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20Factory.sol#L7-L7)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Variables should be used in place of magic numbers to improve readability",
      "description": "Magic numbers should be avoided in Solidity code to enhance readability, maintainability, and reduce the likelihood of errors. Magic numbers are hard-coded values with no clear meaning or context, which can create confusion and make the code harder to understand for developers. Using well-defined constants or variables with descriptive names instead of magic numbers not only clarifies the purpose and significance of the value but also simplifies code updates and modifications.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n181:         uint256 sum1 = supply == 0 ? 0 : ((supply - 1) * (supply) * (2 * (supply - 1) + 1)) / 6; // <= FOUND\n\n```\n",
          "loc": [
            "[181](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L181-L181)"
          ]
        },
        {
          "content": "```solidity\n182:         uint256 sum2 = supply == 0 && amount == 1 // <= FOUND\n183:             ? 0\n184:             : ((supply - 1 + amount) * (supply + amount) * (2 * (supply - 1 + amount) + 1)) / 6; // <= FOUND\n\n```\n",
          "loc": [
            "[182](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L182-L184)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Custom error has no error variables",
      "description": "In Solidity, the use of custom error messages provides a valuable method of conveying meaningful information about failures during execution. In the current implementation, the custom errors lack specifics, making it challenging to understand the root cause of a failure. It's advisable to incorporate parameters into your error messages to indicate which user action or specific value caused the exception. This not only enhances error transparency but also aids debugging and fosters a more robust and maintainable codebase. Providing such precise error context greatly helps developers identify and resolve issues faster.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n14: error NoFeesToClaim(); // <= FOUND\n\n```\n",
          "loc": [
            "[14](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L14-L14)"
          ]
        },
        {
          "content": "```solidity\n15: error NoTokenHolders(); // <= FOUND\n\n```\n",
          "loc": [
            "[15](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L15-L15)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Unused structs present",
      "description": "If these serve no purpose, they should be safely removed",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n49:     struct ExternalTokenMeta { // <= FOUND\n50:         string name;\n51:         string symbol;\n52:         address token;\n53:     }\n\n```\n",
          "loc": [
            "[49](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L49-L49)"
          ]
        },
        {
          "content": "```solidity\n55:     struct PresaleMeta { // <= FOUND\n56:         uint256 startTime;\n57:         bytes32 merkleRoot;\n58:         uint256 maxBuy;\n59:     }\n\n```\n",
          "loc": [
            "[55](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L55-L55)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Empty bytes check is missing",
      "description": "When developing smart contracts in Solidity, it's crucial to validate the inputs of your functions. This includes ensuring that the bytes parameters are not empty, especially when they represent crucial data such as addresses, identifiers, or raw data that the contract needs to process.\n\nMissing empty bytes checks can lead to unexpected behaviour in your contract. For instance, certain operations might fail, produce incorrect results, or consume unnecessary gas when performed with empty bytes. Moreover, missing input validation can potentially expose your contract to malicious activity, including exploitation of unhandled edge cases.\n\nTo mitigate these issues, always validate that bytes parameters are not empty when the logic of your contract requires it.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n377:     function buyCurvesTokenForPresale(\n378:         address curvesTokenSubject,\n379:         uint256 amount,\n380:         uint256 startTime,\n381:         bytes32 merkleRoot,\n382:         uint256 maxBuy\n383:     ) public payable onlyTokenSubject(curvesTokenSubject) {\n384:         if (startTime <= block.timestamp) revert InvalidPresaleStartTime();\n385:         uint256 supply = curvesTokenSupply[curvesTokenSubject];\n386:         if (supply != 0) revert CurveAlreadyExists();\n387:         presalesMeta[curvesTokenSubject].startTime = startTime;\n388:         presalesMeta[curvesTokenSubject].merkleRoot = merkleRoot;\n389:         presalesMeta[curvesTokenSubject].maxBuy = (maxBuy == 0 ? type(uint256).max : maxBuy);\n390: \n391:         _buyCurvesToken(curvesTokenSubject, amount);\n392:     }\n\n```\n",
          "loc": [
            "[377](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L377-L377)"
          ]
        },
        {
          "content": "```solidity\n394:     function setWhitelist(bytes32 merkleRoot) external {\n395:         uint256 supply = curvesTokenSupply[msg.sender];\n396:         if (supply > 1) revert CurveAlreadyExists();\n397: \n398:         if (presalesMeta[msg.sender].merkleRoot != merkleRoot) {\n399:             presalesMeta[msg.sender].merkleRoot = merkleRoot;\n400:             emit WhitelistUpdated(msg.sender, merkleRoot);\n401:         }\n402:     }\n\n```\n",
          "loc": [
            "[394](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L394-L394)"
          ]
        },
        {
          "content": "```solidity\n404:     function buyCurvesTokenWhitelisted(\n405:         address curvesTokenSubject,\n406:         uint256 amount,\n407:         bytes32[] memory proof\n408:     ) public payable {\n409:         if (\n410:             presalesMeta[curvesTokenSubject].startTime == 0 ||\n411:             presalesMeta[curvesTokenSubject].startTime <= block.timestamp\n412:         ) revert PresaleUnavailable();\n413: \n414:         presalesBuys[curvesTokenSubject][msg.sender] += amount;\n415:         uint256 tokenBought = presalesBuys[curvesTokenSubject][msg.sender];\n416:         if (tokenBought > presalesMeta[curvesTokenSubject].maxBuy) revert ExceededMaxBuyAmount();\n417: \n418:         verifyMerkle(curvesTokenSubject, msg.sender, proof);\n419:         _buyCurvesToken(curvesTokenSubject, amount);\n420:     }\n\n```\n",
          "loc": [
            "[404](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L404-L404)"
          ]
        },
        {
          "content": "```solidity\n422:     function verifyMerkle(address curvesTokenSubject, address caller, bytes32[] memory proof) public view {\n423:         \n424:         bytes32 leaf = keccak256(abi.encodePacked(caller));\n425:         if (!MerkleProof.verify(proof, presalesMeta[curvesTokenSubject].merkleRoot, leaf)) revert UnverifiedProof();\n426:     }\n\n```\n",
          "loc": [
            "[422](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L422-L422)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use scopes sparingly",
      "description": "In Solidity programming, the use of scoped blocks, denoted by `{}` without a preceding control structure like `if`, `for`, etc., allows for the creation of isolated scopes within a function. While this can be useful for managing memory and preventing naming conflicts, it should be used sparingly. Excessive use of these scope blocks can obscure the code's logic flow and make it more difficult to understand, impeding code maintainability. As a best practice, only employ scoped blocks when necessary for memory management or to avoid clear naming conflicts. Otherwise, aim for clarity and simplicity in your code structure for optimal readability and maintainability.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n226:         { // <= FOUND\n227:             bool referralDefined = referralFeeDestination[curvesTokenSubject] != address(0);\n228:             { // <= FOUND\n229:                 address firstDestination = isBuy ? feesEconomics.protocolFeeDestination : msg.sender;\n230:                 uint256 buyValue = referralDefined ? protocolFee : protocolFee + referralFee;\n231:                 uint256 sellValue = price - protocolFee - subjectFee - referralFee - holderFee;\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\"); // <= FOUND\n233:                 if (!success1) revert CannotSendFunds();\n234:             }\n235:             { // <= FOUND\n236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}(\"\"); // <= FOUND\n237:                 if (!success2) revert CannotSendFunds();\n238:             }\n239:             { // <= FOUND\n240:                 (bool success3, ) = referralDefined\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}(\"\") // <= FOUND\n242:                     : (true, bytes(\"\"));\n243:                 if (!success3) revert CannotSendFunds();\n244:             }\n245: \n246:             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0)) { // <= FOUND\n247:                 feeRedistributor.onBalanceChange(curvesTokenSubject, msg.sender);\n248:                 feeRedistributor.addFees{value: holderFee}(curvesTokenSubject); // <= FOUND\n249:             }\n250:         }\n\n```\n",
          "loc": [
            "[226](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L226-L248)"
          ]
        },
        {
          "content": "```solidity\n228:            { // <= FOUND\n229:                 address firstDestination = isBuy ? feesEconomics.protocolFeeDestination : msg.sender;\n230:                 uint256 buyValue = referralDefined ? protocolFee : protocolFee + referralFee;\n231:                 uint256 sellValue = price - protocolFee - subjectFee - referralFee - holderFee;\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\"); // <= FOUND\n233:                 if (!success1) revert CannotSendFunds();\n234:             }\n\n```\n",
          "loc": [
            "[228](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L228-L232)"
          ]
        },
        {
          "content": "```solidity\n235:             { // <= FOUND\n236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}(\"\"); // <= FOUND\n237:                 if (!success2) revert CannotSendFunds();\n238:             }\n\n```\n",
          "loc": [
            "[235](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L235-L236)"
          ]
        },
        {
          "content": "```solidity\n239:             { // <= FOUND\n240:                 (bool success3, ) = referralDefined\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}(\"\") // <= FOUND\n242:                     : (true, bytes(\"\"));\n243:                 if (!success3) revert CannotSendFunds();\n244:             }\n\n```\n",
          "loc": [
            "[239](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L239-L241)"
          ]
        },
        {
          "content": "```solidity\n228:             { // <= FOUND\n229:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee} // <= FOUND\n\n```\n",
          "loc": [
            "[228](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L228-L229)"
          ]
        },
        {
          "content": "```solidity\n239:             { // <= FOUND\n240:                 (bool success3, ) = referralDefined\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee} // <= FOUND\n\n```\n",
          "loc": [
            "[239](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L239-L241)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Do not use underscore at the end of variable name",
      "description": "Adopting a consistent and clear naming convention enhances code readability and maintainability. In Solidity, appending an underscore at the end of a variable name is unconventional and can lead to confusion. It is generally advisable to stick to accepted naming practices to promote ease of understanding and use.\n",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n129:         if (\n130:             protocolFeePercent_ +\n131:                 feesEconomics.subjectFeePercent +\n132:                 feesEconomics.referralFeePercent +\n133:                 feesEconomics.holdersFeePercent >\n134:             feesEconomics.maxFeePercent ||\n135:             protocolFeeDestination_ == address(0) // <= FOUND\n136:         ) revert InvalidFeeDefinition();\n\n```\n",
          "loc": [
            "[135](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L135-L135)"
          ]
        },
        {
          "content": "```solidity\n90:         uint256 totalSupply_ = totalSupply(token); // <= FOUND\n\n```\n",
          "loc": [
            "[90](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L90-L90)"
          ]
        },
        {
          "content": "```solidity\n91:         if (totalSupply_ == 0) revert NoTokenHolders(); // <= FOUND\n\n```\n",
          "loc": [
            "[91](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L91-L91)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider using SMTChecker",
      "description": "The SMTChecker is a valuable tool for Solidity developers as it helps detect potential vulnerabilities and logical errors in the contract's code. By utilizing Satisfiability Modulo Theories (SMT) solvers, it can reason about the potential states a contract can be in, and therefore, identify conditions that could lead to undesirable behavior. This automatic formal verification can catch issues that might otherwise be missed in manual code reviews or standard testing, enhancing the overall contract's security and reliability.",
      "gasSavings": 1250,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n1: // SPDX-License-Identifier: MIT\n2: pragma solidity ^0.8.7;\n3: \n4: contract Security {\n5:     address public owner;\n6:     mapping(address => bool) public managers;\n7: \n8:     modifier onlyOwner() {\n9:         msg.sender == owner;\n10:         _;\n11:     }\n12: \n13:     modifier onlyManager() {\n14:         managers[msg.sender] == true;\n15:         _;\n16:     }\n17: \n18:     constructor() {\n19:         owner = msg.sender;\n20:         managers[msg.sender] = true;\n21:     }\n22: \n23:     function setManager(address manager_, bool value) public onlyOwner {\n24:         managers[manager_] = value;\n25:     }\n26: \n27:     function transferOwnership(address owner_) public onlyOwner {\n28:         owner = owner_;\n29:     }\n30: }\n31: \n\n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L1-L1)"
          ]
        },
        {
          "content": "```solidity\n1: // SPDX-License-Identifier: MIT\n2: pragma solidity 0.8.7;\n3: \n4: import \"@openzeppelin/contracts/utils/Strings.sol\";\n5: import \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n6: \n7: import \"./CurvesERC20.sol\";\n8: import \"./CurvesERC20Factory.sol\";\n9: \n10: import \"./FeeSplitter.sol\";\n11: import \"./Security.sol\";\n12: \n13: interface CurvesErrors {\n14:     // Access-related\n15:     error UnauthorizedCurvesTokenSubject();\n16:     // Balance-related\n17:     error InsufficientPayment();\n18:     error CannotSendFunds();\n19:     error InsufficientBalance();\n20:     // ERC20-related\n21:     error InvalidERC20Metadata();\n22:     error ERC20TokenAlreadyMinted();\n23:     // State-related\n24:     error TokenAbsentForCurvesTokenSubject();\n25:     error CurveAlreadyExists();\n26:     // Transaction-related\n27:     error LastTokenCannotBeSold();\n28:     error ContractCannotReceiveTransfer();\n29:     error ExceededMaxBuyAmount();\n30:     error NonIntegerDepositAmount();\n31:     // Proof-related\n32:     error UnverifiedProof();\n33:     // Presale-related\n34:     error PresaleUnavailable();\n35:     error InvalidPresaleStartTime();\n36:     error SaleNotOpen();\n37:     // Fee related\n38:     error InvalidFeeDefinition();\n39: }\n40: \n41: contract Curves is CurvesErrors, Security {\n42:     address public curvesERC20Factory;\n43:     FeeSplitter public feeRedistributor;\n44:     string public constant DEFAULT_NAME = \"Curves\";\n45:     string public constant DEFAULT_SYMBOL = \"CURVES\";\n46:     // Counter for CURVES tokens minted\n47:     uint256 private _curvesTokenCounter = 0;\n48: \n49:     struct ExternalTokenMeta {\n50:         string name;\n51:         string symbol;\n52:         address token;\n53:     }\n54: \n55:     struct PresaleMeta {\n56:         uint256 startTime;\n57:         bytes32 merkleRoot;\n58:         uint256 maxBuy;\n59:     }\n60: \n61:     mapping(address => ExternalTokenMeta) public externalCurvesTokens;\n62:     mapping(address => address) public externalCurvesToSubject;\n63:     mapping(string => address) public symbolToSubject;\n64: \n65:     mapping(address => PresaleMeta) public presalesMeta;\n66:     mapping(address => mapping(address => uint256)) public presalesBuys;\n67: \n68:     struct FeesEconomics {\n69:         address protocolFeeDestination;\n70:         uint256 protocolFeePercent;\n71:         uint256 subjectFeePercent;\n72:         uint256 referralFeePercent;\n73:         uint256 holdersFeePercent;\n74:         uint256 maxFeePercent;\n75:     }\n76: \n77:     FeesEconomics public feesEconomics;\n78:     mapping(address => address) public referralFeeDestination;\n79: \n80:     event Trade(\n81:         address trader,\n82:         address subject,\n83:         bool isBuy,\n84:         uint256 tokenAmount,\n85:         uint256 ethAmount,\n86:         uint256 protocolEthAmount,\n87:         uint256 subjectEthAmount,\n88:         uint256 supply\n89:     );\n90: \n91:     event Transfer(address indexed curvesTokenSubject, address indexed from, address indexed to, uint256 value);\n92:     event WhitelistUpdated(address indexed presale, bytes32 indexed root);\n93:     event TokenDeployed(address indexed curvesTokenSubject, address indexed erc20token, string name, string symbol);\n94: \n95:     // TokenSubject => (Holder => Balance)\n96:     mapping(address => mapping(address => uint256)) public curvesTokenBalance;\n97: \n98:     // TokenSubject => Supply\n99:     mapping(address => uint256) public curvesTokenSupply;\n100: \n101:     mapping(address => address[]) private ownedCurvesTokenSubjects;\n102: \n103:     modifier onlyTokenSubject(address curvesTokenSubject) {\n104:         if (curvesTokenSubject != msg.sender) revert UnauthorizedCurvesTokenSubject();\n105:         _;\n106:     }\n107: \n108:     constructor(address curvesERC20Factory_, address feeRedistributor_) Security() {\n109:         curvesERC20Factory = curvesERC20Factory_;\n110:         feeRedistributor = FeeSplitter(payable(feeRedistributor_));\n111:     }\n112: \n113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner {\n114:         feeRedistributor = FeeSplitter(payable(feeRedistributor_));\n115:     }\n116: \n117:     function setMaxFeePercent(uint256 maxFeePercent_) external onlyManager {\n118:         if (\n119:             feesEconomics.protocolFeePercent +\n120:                 feesEconomics.subjectFeePercent +\n121:                 feesEconomics.referralFeePercent +\n122:                 feesEconomics.holdersFeePercent >\n123:             maxFeePercent_\n124:         ) revert InvalidFeeDefinition();\n125:         feesEconomics.maxFeePercent = maxFeePercent_;\n126:     }\n127: \n128:     function setProtocolFeePercent(uint256 protocolFeePercent_, address protocolFeeDestination_) external onlyOwner {\n129:         if (\n130:             protocolFeePercent_ +\n131:                 feesEconomics.subjectFeePercent +\n132:                 feesEconomics.referralFeePercent +\n133:                 feesEconomics.holdersFeePercent >\n134:             feesEconomics.maxFeePercent ||\n135:             protocolFeeDestination_ == address(0)\n136:         ) revert InvalidFeeDefinition();\n137:         feesEconomics.protocolFeePercent = protocolFeePercent_;\n138:         feesEconomics.protocolFeeDestination = protocolFeeDestination_;\n139:     }\n140: \n141:     function setExternalFeePercent(\n142:         uint256 subjectFeePercent_,\n143:         uint256 referralFeePercent_,\n144:         uint256 holdersFeePercent_\n145:     ) external onlyManager {\n146:         if (\n147:             feesEconomics.protocolFeePercent + subjectFeePercent_ + referralFeePercent_ + holdersFeePercent_ >\n148:             feesEconomics.maxFeePercent\n149:         ) revert InvalidFeeDefinition();\n150:         feesEconomics.subjectFeePercent = subjectFeePercent_;\n151:         feesEconomics.referralFeePercent = referralFeePercent_;\n152:         feesEconomics.holdersFeePercent = holdersFeePercent_;\n153:     }\n154: \n155:     function setReferralFeeDestination(\n156:         address curvesTokenSubject,\n157:         address referralFeeDestination_\n158:     ) public onlyTokenSubject(curvesTokenSubject) {\n159:         referralFeeDestination[curvesTokenSubject] = referralFeeDestination_;\n160:     }\n161: \n162:     function setERC20Factory(address factory_) external onlyOwner {\n163:         curvesERC20Factory = factory_;\n164:     }\n165: \n166:     function getFees(\n167:         uint256 price\n168:     )\n169:         public\n170:         view\n171:         returns (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holdersFee, uint256 totalFee)\n172:     {\n173:         protocolFee = (price * feesEconomics.protocolFeePercent) / 1 ether;\n174:         subjectFee = (price * feesEconomics.subjectFeePercent) / 1 ether;\n175:         referralFee = (price * feesEconomics.referralFeePercent) / 1 ether;\n176:         holdersFee = (price * feesEconomics.holdersFeePercent) / 1 ether;\n177:         totalFee = protocolFee + subjectFee + referralFee + holdersFee;\n178:     }\n179: \n180:     function getPrice(uint256 supply, uint256 amount) public pure returns (uint256) {\n181:         uint256 sum1 = supply == 0 ? 0 : ((supply - 1) * (supply) * (2 * (supply - 1) + 1)) / 6;\n182:         uint256 sum2 = supply == 0 && amount == 1\n183:             ? 0\n184:             : ((supply - 1 + amount) * (supply + amount) * (2 * (supply - 1 + amount) + 1)) / 6;\n185:         uint256 summation = sum2 - sum1;\n186:         return (summation * 1 ether) / 16000;\n187:     }\n188: \n189:     function getBuyPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) {\n190:         return getPrice(curvesTokenSupply[curvesTokenSubject], amount);\n191:     }\n192: \n193:     function getSellPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) {\n194:         return getPrice(curvesTokenSupply[curvesTokenSubject] - amount, amount);\n195:     }\n196: \n197:     function getBuyPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {\n198:         uint256 price = getBuyPrice(curvesTokenSubject, amount);\n199:         (, , , , uint256 totalFee) = getFees(price);\n200: \n201:         return price + totalFee;\n202:     }\n203: \n204:     function getSellPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {\n205:         uint256 price = getSellPrice(curvesTokenSubject, amount);\n206:         (, , , , uint256 totalFee) = getFees(price);\n207: \n208:         return price - totalFee;\n209:     }\n210: \n211:     function buyCurvesToken(address curvesTokenSubject, uint256 amount) public payable {\n212:         uint256 startTime = presalesMeta[curvesTokenSubject].startTime;\n213:         if (startTime != 0 && startTime >= block.timestamp) revert SaleNotOpen();\n214: \n215:         _buyCurvesToken(curvesTokenSubject, amount);\n216:     }\n217: \n218:     function _transferFees(\n219:         address curvesTokenSubject,\n220:         bool isBuy,\n221:         uint256 price,\n222:         uint256 amount,\n223:         uint256 supply\n224:     ) internal {\n225:         (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holderFee, ) = getFees(price);\n226:         {\n227:             bool referralDefined = referralFeeDestination[curvesTokenSubject] != address(0);\n228:             {\n229:                 address firstDestination = isBuy ? feesEconomics.protocolFeeDestination : msg.sender;\n230:                 uint256 buyValue = referralDefined ? protocolFee : protocolFee + referralFee;\n231:                 uint256 sellValue = price - protocolFee - subjectFee - referralFee - holderFee;\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\");\n233:                 if (!success1) revert CannotSendFunds();\n234:             }\n235:             {\n236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}(\"\");\n237:                 if (!success2) revert CannotSendFunds();\n238:             }\n239:             {\n240:                 (bool success3, ) = referralDefined\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}(\"\")\n242:                     : (true, bytes(\"\"));\n243:                 if (!success3) revert CannotSendFunds();\n244:             }\n245: \n246:             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0)) {\n247:                 feeRedistributor.onBalanceChange(curvesTokenSubject, msg.sender);\n248:                 feeRedistributor.addFees{value: holderFee}(curvesTokenSubject);\n249:             }\n250:         }\n251:         emit Trade(\n252:             msg.sender,\n253:             curvesTokenSubject,\n254:             isBuy,\n255:             amount,\n256:             price,\n257:             protocolFee,\n258:             subjectFee,\n259:             isBuy ? supply + amount : supply - amount\n260:         );\n261:     }\n262: \n263:     function _buyCurvesToken(address curvesTokenSubject, uint256 amount) internal {\n264:         uint256 supply = curvesTokenSupply[curvesTokenSubject];\n265:         if (!(supply > 0 || curvesTokenSubject == msg.sender)) revert UnauthorizedCurvesTokenSubject();\n266: \n267:         uint256 price = getPrice(supply, amount);\n268:         (, , , , uint256 totalFee) = getFees(price);\n269: \n270:         if (msg.value < price + totalFee) revert InsufficientPayment();\n271: \n272:         curvesTokenBalance[curvesTokenSubject][msg.sender] += amount;\n273:         curvesTokenSupply[curvesTokenSubject] = supply + amount;\n274:         _transferFees(curvesTokenSubject, true, price, amount, supply);\n275: \n276:         // If is the first token bought, add to the list of owned tokens\n277:         if (curvesTokenBalance[curvesTokenSubject][msg.sender] - amount == 0) {\n278:             _addOwnedCurvesTokenSubject(msg.sender, curvesTokenSubject);\n279:         }\n280:     }\n281: \n282:     function sellCurvesToken(address curvesTokenSubject, uint256 amount) public {\n283:         uint256 supply = curvesTokenSupply[curvesTokenSubject];\n284:         if (supply <= amount) revert LastTokenCannotBeSold();\n285:         if (curvesTokenBalance[curvesTokenSubject][msg.sender] < amount) revert InsufficientBalance();\n286: \n287:         uint256 price = getPrice(supply - amount, amount);\n288: \n289:         curvesTokenBalance[curvesTokenSubject][msg.sender] -= amount;\n290:         curvesTokenSupply[curvesTokenSubject] = supply - amount;\n291: \n292:         _transferFees(curvesTokenSubject, false, price, amount, supply);\n293:     }\n294: \n295:     // Transfers tokens from current owner to receiver. Can be used for gifting or distributing tokens.\n296:     function transferCurvesToken(address curvesTokenSubject, address to, uint256 amount) external {\n297:         if (to == address(this)) revert ContractCannotReceiveTransfer();\n298:         _transfer(curvesTokenSubject, msg.sender, to, amount);\n299:     }\n300: \n301:     // Transfer the total balance of all my tokens to another address. Can be used for migrating tokens.\n302:     function transferAllCurvesTokens(address to) external {\n303:         if (to == address(this)) revert ContractCannotReceiveTransfer();\n304:         address[] storage subjects = ownedCurvesTokenSubjects[msg.sender];\n305:         for (uint256 i = 0; i < subjects.length; i++) {\n306:             uint256 amount = curvesTokenBalance[subjects[i]][msg.sender];\n307:             if (amount > 0) {\n308:                 _transfer(subjects[i], msg.sender, to, amount);\n309:             }\n310:         }\n311:     }\n312: \n313:     function _transfer(address curvesTokenSubject, address from, address to, uint256 amount) internal {\n314:         if (amount > curvesTokenBalance[curvesTokenSubject][from]) revert InsufficientBalance();\n315: \n316:         // If transferring from oneself, skip adding to the list\n317:         if (from != to) {\n318:             _addOwnedCurvesTokenSubject(to, curvesTokenSubject);\n319:         }\n320: \n321:         curvesTokenBalance[curvesTokenSubject][from] = curvesTokenBalance[curvesTokenSubject][from] - amount;\n322:         curvesTokenBalance[curvesTokenSubject][to] = curvesTokenBalance[curvesTokenSubject][to] + amount;\n323: \n324:         emit Transfer(curvesTokenSubject, from, to, amount);\n325:     }\n326: \n327:     // Internal function to add a curvesTokenSubject to the list if not already present\n328:     function _addOwnedCurvesTokenSubject(address owner_, address curvesTokenSubject) internal {\n329:         address[] storage subjects = ownedCurvesTokenSubjects[owner_];\n330:         for (uint256 i = 0; i < subjects.length; i++) {\n331:             if (subjects[i] == curvesTokenSubject) {\n332:                 return;\n333:             }\n334:         }\n335:         subjects.push(curvesTokenSubject);\n336:     }\n337: \n338:     function _deployERC20(\n339:         address curvesTokenSubject,\n340:         string memory name,\n341:         string memory symbol\n342:     ) internal returns (address) {\n343:         // If the token's symbol is CURVES, append a counter value\n344:         if (keccak256(bytes(symbol)) == keccak256(bytes(DEFAULT_SYMBOL))) {\n345:             _curvesTokenCounter += 1;\n346:             name = string(abi.encodePacked(name, \" \", Strings.toString(_curvesTokenCounter)));\n347:             symbol = string(abi.encodePacked(symbol, Strings.toString(_curvesTokenCounter)));\n348:         }\n349: \n350:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();\n351: \n352:         address tokenContract = CurvesERC20Factory(curvesERC20Factory).deploy(name, symbol, address(this));\n353: \n354:         externalCurvesTokens[curvesTokenSubject].token = tokenContract;\n355:         externalCurvesTokens[curvesTokenSubject].name = name;\n356:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;\n357:         externalCurvesToSubject[tokenContract] = curvesTokenSubject;\n358:         symbolToSubject[symbol] = curvesTokenSubject;\n359: \n360:         emit TokenDeployed(curvesTokenSubject, tokenContract, name, symbol);\n361:         return address(tokenContract);\n362:     }\n363: \n364:     function buyCurvesTokenWithName(\n365:         address curvesTokenSubject,\n366:         uint256 amount,\n367:         string memory name,\n368:         string memory symbol\n369:     ) public payable {\n370:         uint256 supply = curvesTokenSupply[curvesTokenSubject];\n371:         if (supply != 0) revert CurveAlreadyExists();\n372: \n373:         _buyCurvesToken(curvesTokenSubject, amount);\n374:         _mint(curvesTokenSubject, name, symbol);\n375:     }\n376: \n377:     function buyCurvesTokenForPresale(\n378:         address curvesTokenSubject,\n379:         uint256 amount,\n380:         uint256 startTime,\n381:         bytes32 merkleRoot,\n382:         uint256 maxBuy\n383:     ) public payable onlyTokenSubject(curvesTokenSubject) {\n384:         if (startTime <= block.timestamp) revert InvalidPresaleStartTime();\n385:         uint256 supply = curvesTokenSupply[curvesTokenSubject];\n386:         if (supply != 0) revert CurveAlreadyExists();\n387:         presalesMeta[curvesTokenSubject].startTime = startTime;\n388:         presalesMeta[curvesTokenSubject].merkleRoot = merkleRoot;\n389:         presalesMeta[curvesTokenSubject].maxBuy = (maxBuy == 0 ? type(uint256).max : maxBuy);\n390: \n391:         _buyCurvesToken(curvesTokenSubject, amount);\n392:     }\n393: \n394:     function setWhitelist(bytes32 merkleRoot) external {\n395:         uint256 supply = curvesTokenSupply[msg.sender];\n396:         if (supply > 1) revert CurveAlreadyExists();\n397: \n398:         if (presalesMeta[msg.sender].merkleRoot != merkleRoot) {\n399:             presalesMeta[msg.sender].merkleRoot = merkleRoot;\n400:             emit WhitelistUpdated(msg.sender, merkleRoot);\n401:         }\n402:     }\n403: \n404:     function buyCurvesTokenWhitelisted(\n405:         address curvesTokenSubject,\n406:         uint256 amount,\n407:         bytes32[] memory proof\n408:     ) public payable {\n409:         if (\n410:             presalesMeta[curvesTokenSubject].startTime == 0 ||\n411:             presalesMeta[curvesTokenSubject].startTime <= block.timestamp\n412:         ) revert PresaleUnavailable();\n413: \n414:         presalesBuys[curvesTokenSubject][msg.sender] += amount;\n415:         uint256 tokenBought = presalesBuys[curvesTokenSubject][msg.sender];\n416:         if (tokenBought > presalesMeta[curvesTokenSubject].maxBuy) revert ExceededMaxBuyAmount();\n417: \n418:         verifyMerkle(curvesTokenSubject, msg.sender, proof);\n419:         _buyCurvesToken(curvesTokenSubject, amount);\n420:     }\n421: \n422:     function verifyMerkle(address curvesTokenSubject, address caller, bytes32[] memory proof) public view {\n423:         // Verify merkle proof\n424:         bytes32 leaf = keccak256(abi.encodePacked(caller));\n425:         if (!MerkleProof.verify(proof, presalesMeta[curvesTokenSubject].merkleRoot, leaf)) revert UnverifiedProof();\n426:     }\n427: \n428:     function setNameAndSymbol(\n429:         address curvesTokenSubject,\n430:         string memory name,\n431:         string memory symbol\n432:     ) external onlyTokenSubject(curvesTokenSubject) {\n433:         if (externalCurvesTokens[curvesTokenSubject].token != address(0)) revert ERC20TokenAlreadyMinted();\n434:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();\n435:         externalCurvesTokens[curvesTokenSubject].name = name;\n436:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;\n437:     }\n438: \n439:     function mint(address curvesTokenSubject) external onlyTokenSubject(curvesTokenSubject) {\n440:         if (\n441:             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==\n442:             keccak256(abi.encodePacked(\"\")) ||\n443:             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==\n444:             keccak256(abi.encodePacked(\"\"))\n445:         ) {\n446:             externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME;\n447:             externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL;\n448:         }\n449:         _mint(\n450:             curvesTokenSubject,\n451:             externalCurvesTokens[curvesTokenSubject].name,\n452:             externalCurvesTokens[curvesTokenSubject].symbol\n453:         );\n454:     }\n455: \n456:     function _mint(\n457:         address curvesTokenSubject,\n458:         string memory name,\n459:         string memory symbol\n460:     ) internal onlyTokenSubject(curvesTokenSubject) {\n461:         if (externalCurvesTokens[curvesTokenSubject].token != address(0)) revert ERC20TokenAlreadyMinted();\n462:         _deployERC20(curvesTokenSubject, name, symbol);\n463:     }\n464: \n465:     function withdraw(address curvesTokenSubject, uint256 amount) public {\n466:         if (amount > curvesTokenBalance[curvesTokenSubject][msg.sender]) revert InsufficientBalance();\n467: \n468:         address externalToken = externalCurvesTokens[curvesTokenSubject].token;\n469:         if (externalToken == address(0)) {\n470:             if (\n471:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==\n472:                 keccak256(abi.encodePacked(\"\")) ||\n473:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==\n474:                 keccak256(abi.encodePacked(\"\"))\n475:             ) {\n476:                 externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME;\n477:                 externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL;\n478:             }\n479:             _deployERC20(\n480:                 curvesTokenSubject,\n481:                 externalCurvesTokens[curvesTokenSubject].name,\n482:                 externalCurvesTokens[curvesTokenSubject].symbol\n483:             );\n484:             externalToken = externalCurvesTokens[curvesTokenSubject].token;\n485:         }\n486:         _transfer(curvesTokenSubject, msg.sender, address(this), amount);\n487:         CurvesERC20(externalToken).mint(msg.sender, amount * 1 ether);\n488:     }\n489: \n490:     function deposit(address curvesTokenSubject, uint256 amount) public {\n491:         if (amount % 1 ether != 0) revert NonIntegerDepositAmount();\n492: \n493:         address externalToken = externalCurvesTokens[curvesTokenSubject].token;\n494:         uint256 tokenAmount = amount / 1 ether;\n495: \n496:         if (externalToken == address(0)) revert TokenAbsentForCurvesTokenSubject();\n497:         if (amount > CurvesERC20(externalToken).balanceOf(msg.sender)) revert InsufficientBalance();\n498:         if (tokenAmount > curvesTokenBalance[curvesTokenSubject][address(this)]) revert InsufficientBalance();\n499: \n500:         CurvesERC20(externalToken).burn(msg.sender, amount);\n501:         _transfer(curvesTokenSubject, address(this), msg.sender, tokenAmount);\n502:     }\n503: \n504:     function sellExternalCurvesToken(address curvesTokenSubject, uint256 amount) public {\n505:         if (externalCurvesTokens[curvesTokenSubject].token == address(0)) revert TokenAbsentForCurvesTokenSubject();\n506: \n507:         deposit(curvesTokenSubject, amount);\n508:         sellCurvesToken(curvesTokenSubject, amount / 1 ether);\n509:     }\n510: }\n511: \n\n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L1-L1)"
          ]
        },
        {
          "content": "```solidity\n1: // SPDX-License-Identifier: MIT\n2: pragma solidity 0.8.7;\n3: \n4: import \"./CurvesERC20.sol\";\n5: \n6: contract CurvesERC20Factory {\n7:     function deploy(string memory name, string memory symbol, address owner) public returns (address) {\n8:         CurvesERC20 tokenContract = new CurvesERC20(name, symbol, owner);\n9:         return address(tokenContract);\n10:     }\n11: }\n12: \n\n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20Factory.sol#L1-L1)"
          ]
        },
        {
          "content": "```solidity\n1: // SPDX-License-Identifier: MIT\n2: pragma solidity ^0.8.7;\n3: \n4: import \"./Curves.sol\";\n5: import \"./Security.sol\";\n6: \n7: import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n8: \n9: contract FeeSplitter is Security {\n10:     Curves public curves;\n11:     uint256 constant PRECISION = 1e18;\n12: \n13:     // Custom errors\n14:     error NoFeesToClaim();\n15:     error NoTokenHolders();\n16: \n17:     struct TokenData {\n18:         uint256 cumulativeFeePerToken;\n19:         mapping(address => uint256) userFeeOffset;\n20:         mapping(address => uint256) unclaimedFees;\n21:     }\n22: \n23:     struct UserClaimData {\n24:         uint256 claimableFees;\n25:         address token;\n26:     }\n27: \n28:     mapping(address => TokenData) internal tokensData;\n29:     mapping(address => address[]) internal userTokens;\n30: \n31:     event FeesClaimed(address indexed token, address indexed user, uint256 amount);\n32: \n33:     constructor() Security() {}\n34: \n35:     function setCurves(Curves curves_) public {\n36:         curves = curves_;\n37:     }\n38: \n39:     function balanceOf(address token, address account) public view returns (uint256) {\n40:         return curves.curvesTokenBalance(token, account) * PRECISION;\n41:     }\n42: \n43:     function totalSupply(address token) public view returns (uint256) {\n44:         //@dev: this is the amount of tokens that are not locked in the contract. The locked tokens are in the ERC20 contract\n45:         return (curves.curvesTokenSupply(token) - curves.curvesTokenBalance(token, address(curves))) * PRECISION;\n46:     }\n47: \n48:     function getUserTokens(address user) public view returns (address[] memory) {\n49:         return userTokens[user];\n50:     }\n51: \n52:     function getUserTokensAndClaimable(address user) public view returns (UserClaimData[] memory) {\n53:         address[] memory tokens = getUserTokens(user);\n54:         UserClaimData[] memory result = new UserClaimData[](tokens.length);\n55:         for (uint256 i = 0; i < tokens.length; i++) {\n56:             address token = tokens[i];\n57:             uint256 claimable = getClaimableFees(token, user);\n58:             result[i] = UserClaimData(claimable, token);\n59:         }\n60:         return result;\n61:     }\n62: \n63:     function updateFeeCredit(address token, address account) internal {\n64:         TokenData storage data = tokensData[token];\n65:         uint256 balance = balanceOf(token, account);\n66:         if (balance > 0) {\n67:             uint256 owed = (data.cumulativeFeePerToken - data.userFeeOffset[account]) * balance;\n68:             data.unclaimedFees[account] += owed / PRECISION;\n69:             data.userFeeOffset[account] = data.cumulativeFeePerToken;\n70:         }\n71:     }\n72: \n73:     function getClaimableFees(address token, address account) public view returns (uint256) {\n74:         TokenData storage data = tokensData[token];\n75:         uint256 balance = balanceOf(token, account);\n76:         uint256 owed = (data.cumulativeFeePerToken - data.userFeeOffset[account]) * balance;\n77:         return (owed / PRECISION) + data.unclaimedFees[account];\n78:     }\n79: \n80:     function claimFees(address token) external {\n81:         updateFeeCredit(token, msg.sender);\n82:         uint256 claimable = getClaimableFees(token, msg.sender);\n83:         if (claimable == 0) revert NoFeesToClaim();\n84:         tokensData[token].unclaimedFees[msg.sender] = 0;\n85:         payable(msg.sender).transfer(claimable);\n86:         emit FeesClaimed(token, msg.sender, claimable);\n87:     }\n88: \n89:     function addFees(address token) public payable onlyManager {\n90:         uint256 totalSupply_ = totalSupply(token);\n91:         if (totalSupply_ == 0) revert NoTokenHolders();\n92:         TokenData storage data = tokensData[token];\n93:         data.cumulativeFeePerToken += (msg.value * PRECISION) / totalSupply_;\n94:     }\n95: \n96:     function onBalanceChange(address token, address account) public onlyManager {\n97:         TokenData storage data = tokensData[token];\n98:         data.userFeeOffset[account] = data.cumulativeFeePerToken;\n99:         if (balanceOf(token, account) > 0) userTokens[account].push(token);\n100:     }\n101: \n102:     //@dev: this may fail if the the list is long. Get first the list with getUserTokens to estimate and prepare the batch\n103:     function batchClaiming(address[] calldata tokenList) external {\n104:         uint256 totalClaimable = 0;\n105:         for (uint256 i = 0; i < tokenList.length; i++) {\n106:             address token = tokenList[i];\n107:             updateFeeCredit(token, msg.sender);\n108:             uint256 claimable = getClaimableFees(token, msg.sender);\n109:             if (claimable > 0) {\n110:                 tokensData[token].unclaimedFees[msg.sender] = 0;\n111:                 totalClaimable += claimable;\n112:                 emit FeesClaimed(token, msg.sender, claimable);\n113:             }\n114:         }\n115:         if (totalClaimable == 0) revert NoFeesToClaim();\n116:         payable(msg.sender).transfer(totalClaimable);\n117:     }\n118: \n119:     receive() external payable {}\n120: }\n121: \n\n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L1-L1)"
          ]
        },
        {
          "content": "```solidity\n1: // SPDX-License-Identifier: MIT\n2: pragma solidity 0.8.7;\n3: \n4: import \"@openzeppelin/contracts/access/Ownable.sol\";\n5: import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n6: \n7: contract CurvesERC20 is ERC20, Ownable {\n8:     constructor(string memory name_, string memory symbol_, address owner) ERC20(name_, symbol_) {\n9:         transferOwnership(owner);\n10:     }\n11: \n12:     function mint(address to, uint256 amount) public onlyOwner {\n13:         _mint(to, amount);\n14:     }\n15: \n16:     function burn(address from, uint256 amount) public onlyOwner {\n17:         _burn(from, amount);\n18:     }\n19: }\n20: \n\n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L1-L1)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Top level declarations should be separated by two blank lines",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n25:     } // <= FOUND\n26: \n27:     function transferOwnership(address owner_) public onlyOwner { // <= FOUND\n\n```\n",
          "loc": [
            "[25](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L25-L27)"
          ]
        },
        {
          "content": "```solidity\n111:     } // <= FOUND\n112: \n113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner { // <= FOUND\n\n```\n",
          "loc": [
            "[111](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L111-L113)"
          ]
        },
        {
          "content": "```solidity\n126:     } // <= FOUND\n127: \n128:     function setProtocolFeePercent(uint256 protocolFeePercent_, address protocolFeeDestination_) external onlyOwner { // <= FOUND\n\n```\n",
          "loc": [
            "[126](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L126-L128)"
          ]
        },
        {
          "content": "```solidity\n153:     } // <= FOUND\n154: \n155:     function setReferralFeeDestination( // <= FOUND\n\n```\n",
          "loc": [
            "[153](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L153-L155)"
          ]
        },
        {
          "content": "```solidity\n195:     } // <= FOUND\n196: \n197:     function getBuyPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) { // <= FOUND\n\n```\n",
          "loc": [
            "[195](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L195-L197)"
          ]
        },
        {
          "content": "```solidity\n216:     } // <= FOUND\n217: \n218:     function _transferFees( // <= FOUND\n\n```\n",
          "loc": [
            "[216](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L216-L218)"
          ]
        },
        {
          "content": "```solidity\n261:     } // <= FOUND\n262: \n263:     function _buyCurvesToken(address curvesTokenSubject, uint256 amount) internal { // <= FOUND\n\n```\n",
          "loc": [
            "[261](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L261-L263)"
          ]
        },
        {
          "content": "```solidity\n336:     } // <= FOUND\n337: \n338:     function _deployERC20( // <= FOUND\n\n```\n",
          "loc": [
            "[336](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L336-L338)"
          ]
        },
        {
          "content": "```solidity\n375:     } // <= FOUND\n376: \n377:     function buyCurvesTokenForPresale( // <= FOUND\n\n```\n",
          "loc": [
            "[375](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L375-L377)"
          ]
        },
        {
          "content": "```solidity\n402:     } // <= FOUND\n403: \n404:     function buyCurvesTokenWhitelisted( // <= FOUND\n\n```\n",
          "loc": [
            "[402](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L402-L404)"
          ]
        },
        {
          "content": "```solidity\n420:     } // <= FOUND\n421: \n422:     function verifyMerkle(address curvesTokenSubject, address caller, bytes32[] memory proof) public view { // <= FOUND\n\n```\n",
          "loc": [
            "[420](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L420-L422)"
          ]
        },
        {
          "content": "```solidity\n426:     } // <= FOUND\n427: \n428:     function setNameAndSymbol( // <= FOUND\n\n```\n",
          "loc": [
            "[426](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L426-L428)"
          ]
        },
        {
          "content": "```solidity\n41:     } // <= FOUND\n42: \n43:     function totalSupply(address token) public view returns (uint256) { // <= FOUND\n\n```\n",
          "loc": [
            "[41](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L41-L43)"
          ]
        },
        {
          "content": "```solidity\n50:     } // <= FOUND\n51: \n52:     function getUserTokensAndClaimable(address user) public view returns (UserClaimData[] memory) { // <= FOUND\n\n```\n",
          "loc": [
            "[50](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L50-L52)"
          ]
        },
        {
          "content": "```solidity\n71:     } // <= FOUND\n72: \n73:     function getClaimableFees(address token, address account) public view returns (uint256) { // <= FOUND\n\n```\n",
          "loc": [
            "[71](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L71-L73)"
          ]
        },
        {
          "content": "```solidity\n10:     } // <= FOUND\n11: \n12:     function mint(address to, uint256 amount) public onlyOwner { // <= FOUND\n\n```\n",
          "loc": [
            "[10](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L10-L12)"
          ]
        },
        {
          "content": "```solidity\n16:     } // <= FOUND\n17: \n18:     constructor() { // <= FOUND\n\n```\n",
          "loc": [
            "[16](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L16-L18)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Contracts should have full test coverage",
      "description": "Attaining 100% code coverage is not an assurance of a bug-free codebase, but it significantly improves the likelihood of identifying simple bugs and aids in maintaining a stable codebase by preventing regressions during code modifications. Additionally, to achieve complete coverage, code writers usually have to structure their code more modularly, which implies testing each component independently. This reduces the complex interdependencies between modules and layers, creating a more understandable and auditable codebase. Consequently, this practice aids in enhancing code maintainability and reduces the risk of introducing bugs during future changes.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n41: contract Curves is CurvesErrors, Security  // <= FOUND\n\n```\n",
          "loc": [
            "[41](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L41-L41)"
          ]
        },
        {
          "content": "```solidity\n9: contract FeeSplitter is Security  // <= FOUND\n\n```\n",
          "loc": [
            "[9](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L9-L9)"
          ]
        },
        {
          "content": "```solidity\n4: contract Security  // <= FOUND\n\n```\n",
          "loc": [
            "[4](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n7: contract CurvesERC20 is ERC20, Ownable  // <= FOUND\n\n```\n",
          "loc": [
            "[7](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L7-L7)"
          ]
        },
        {
          "content": "```solidity\n6: contract CurvesERC20Factory  // <= FOUND\n\n```\n",
          "loc": [
            "[6](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20Factory.sol#L6-L6)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider using SafeTransferLib.safeTransferETH() or Address.sendValue() for clearer semantic meaning",
      "description": "For improved code readability and better semantic understanding, it's recommended to use OpenZeppelin's SafeTransferLib.safeTransferETH() or Address.sendValue(). These functions explicitly describe their operation with their naming convention, increasing the comprehensibility of the code. Their usage over lower-level calls enhances the maintainability of your smart contract code by clearly indicating the purpose of the function. ",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n218:     function _transferFees(\n219:         address curvesTokenSubject,\n220:         bool isBuy,\n221:         uint256 price,\n222:         uint256 amount,\n223:         uint256 supply\n224:     ) internal {\n225:         (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holderFee, ) = getFees(price);\n226:         {\n227:             bool referralDefined = referralFeeDestination[curvesTokenSubject] != address(0);\n228:             {\n229:                 address firstDestination = isBuy ? feesEconomics.protocolFeeDestination : msg.sender;\n230:                 uint256 buyValue = referralDefined ? protocolFee : protocolFee + referralFee;\n231:                 uint256 sellValue = price - protocolFee - subjectFee - referralFee - holderFee;\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\"); // <= FOUND\n233:                 if (!success1) revert CannotSendFunds();\n234:             }\n235:             {\n236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}(\"\"); // <= FOUND\n237:                 if (!success2) revert CannotSendFunds();\n238:             }\n239:             {\n240:                 (bool success3, ) = referralDefined\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}(\"\")\n242:                     : (true, bytes(\"\"));\n243:                 if (!success3) revert CannotSendFunds();\n244:             }\n245: \n246:             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0)) {\n247:                 feeRedistributor.onBalanceChange(curvesTokenSubject, msg.sender);\n248:                 feeRedistributor.addFees{value: holderFee}(curvesTokenSubject);\n249:             }\n250:         }\n251:         emit Trade(\n252:             msg.sender,\n253:             curvesTokenSubject,\n254:             isBuy,\n255:             amount,\n256:             price,\n257:             protocolFee,\n258:             subjectFee,\n259:             isBuy ? supply + amount : supply - amount\n260:         );\n261:     }\n\n```\n",
          "loc": [
            "[218](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L218-L236)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Whitespace in expressions",
      "description": "Avoid unnecessary whitespace in contract lines such as ' ;' and ', )' ",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n225:         (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holderFee, ) = getFees(price); // <= FOUND\n\n```\n",
          "loc": [
            "[225](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L225-L225)"
          ]
        },
        {
          "content": "```solidity\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\"); // <= FOUND\n\n```\n",
          "loc": [
            "[232](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L232-L232)"
          ]
        },
        {
          "content": "```solidity\n236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}(\"\"); // <= FOUND\n\n```\n",
          "loc": [
            "[236](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L236-L236)"
          ]
        },
        {
          "content": "```solidity\n240:                 (bool success3, ) = referralDefined // <= FOUND\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}(\"\")\n\n```\n",
          "loc": [
            "[240](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L240-L240)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider using named function calls",
      "description": "Named function calls in Solidity greatly improve code readability by explicitly mapping arguments to their respective parameter names. This clarity becomes critical when dealing with functions that have numerous or complex parameters, reducing potential errors due to misordered arguments. Therefore, adopting named function calls contributes to more maintainable and less error-prone code.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n199:         (, , , , uint256 totalFee) = getFees(price); // <= FOUND\n\n```\n",
          "loc": [
            "[199](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L199-L199)"
          ]
        },
        {
          "content": "```solidity\n225:         (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holderFee, ) = getFees(price); // <= FOUND\n\n```\n",
          "loc": [
            "[225](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L225-L225)"
          ]
        },
        {
          "content": "```solidity\n190:         return getPrice(curvesTokenSupply[curvesTokenSubject], amount); // <= FOUND\n\n```\n",
          "loc": [
            "[190](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L190-L190)"
          ]
        },
        {
          "content": "```solidity\n194:         return getPrice(curvesTokenSupply[curvesTokenSubject] - amount, amount); // <= FOUND\n\n```\n",
          "loc": [
            "[194](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L194-L194)"
          ]
        },
        {
          "content": "```solidity\n267: \n268:         uint256 price = getPrice(supply, amount); // <= FOUND\n\n```\n",
          "loc": [
            "[267](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L267-L268)"
          ]
        },
        {
          "content": "```solidity\n287: \n288:         uint256 price = getPrice(supply - amount, amount); // <= FOUND\n\n```\n",
          "loc": [
            "[287](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L287-L288)"
          ]
        },
        {
          "content": "```solidity\n198:         uint256 price = getBuyPrice(curvesTokenSubject, amount); // <= FOUND\n\n```\n",
          "loc": [
            "[198](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L198-L198)"
          ]
        },
        {
          "content": "```solidity\n205:         uint256 price = getSellPrice(curvesTokenSubject, amount); // <= FOUND\n\n```\n",
          "loc": [
            "[205](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L205-L205)"
          ]
        },
        {
          "content": "```solidity\n215: \n216:         _buyCurvesToken(curvesTokenSubject, amount); // <= FOUND\n\n```\n",
          "loc": [
            "[215](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L215-L216)"
          ]
        },
        {
          "content": "```solidity\n215:         _buyCurvesToken(curvesTokenSubject, amount); // <= FOUND\n\n```\n",
          "loc": [
            "[215](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L215-L215)"
          ]
        },
        {
          "content": "```solidity\n274:         _transferFees(curvesTokenSubject, true, price, amount, supply); // <= FOUND\n\n```\n",
          "loc": [
            "[274](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L274-L274)"
          ]
        },
        {
          "content": "```solidity\n292: \n293:         _transferFees(curvesTokenSubject, false, price, amount, supply); // <= FOUND\n\n```\n",
          "loc": [
            "[292](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L292-L293)"
          ]
        },
        {
          "content": "```solidity\n508:         sellCurvesToken(curvesTokenSubject, amount / 1 ether); // <= FOUND\n\n```\n",
          "loc": [
            "[508](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L508-L508)"
          ]
        },
        {
          "content": "```solidity\n318:             _addOwnedCurvesTokenSubject(to, curvesTokenSubject); // <= FOUND\n\n```\n",
          "loc": [
            "[318](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L318-L318)"
          ]
        },
        {
          "content": "```solidity\n462:         _deployERC20(curvesTokenSubject, name, symbol); // <= FOUND\n\n```\n",
          "loc": [
            "[462](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L462-L462)"
          ]
        },
        {
          "content": "```solidity\n374:         _mint(curvesTokenSubject, name, symbol); // <= FOUND\n\n```\n",
          "loc": [
            "[374](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L374-L374)"
          ]
        },
        {
          "content": "```solidity\n13:         _mint(to, amount); // <= FOUND\n\n```\n",
          "loc": [
            "[13](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L13-L13)"
          ]
        },
        {
          "content": "```solidity\n507: \n508:         deposit(curvesTokenSubject, amount); // <= FOUND\n\n```\n",
          "loc": [
            "[507](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L507-L508)"
          ]
        },
        {
          "content": "```solidity\n65:         uint256 balance = balanceOf(token, account); // <= FOUND\n\n```\n",
          "loc": [
            "[65](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L65-L65)"
          ]
        },
        {
          "content": "```solidity\n57:             uint256 claimable = getClaimableFees(token, user); // <= FOUND\n\n```\n",
          "loc": [
            "[57](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L57-L57)"
          ]
        },
        {
          "content": "```solidity\n17:         _burn(from, amount); // <= FOUND\n\n```\n",
          "loc": [
            "[17](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L17-L17)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Lack of space near the operator",
      "description": "Lack of space near operators in code can lead to reduced readability, making it more challenging to distinguish between different elements and understand the logic quickly. As a resolution, always include spaces around operators to ensure a clear visual separation, which promotes better maintainability and comprehension of the code.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n118:         if (\n119:             feesEconomics.protocolFeePercent + // <= FOUND\n120:                 feesEconomics.subjectFeePercent + // <= FOUND\n121:                 feesEconomics.referralFeePercent + // <= FOUND\n122:                 feesEconomics.holdersFeePercent >\n123:             maxFeePercent_\n124:         ) revert InvalidFeeDefinition(); // <= FOUND\n\n```\n",
          "loc": [
            "[118](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L118-L124)"
          ]
        },
        {
          "content": "```solidity\n129:         if (\n130:             protocolFeePercent_ + // <= FOUND\n131:                 feesEconomics.subjectFeePercent + // <= FOUND\n132:                 feesEconomics.referralFeePercent + // <= FOUND\n133:                 feesEconomics.holdersFeePercent >\n134:             feesEconomics.maxFeePercent ||\n135:             protocolFeeDestination_ == address(0)\n136:         ) revert InvalidFeeDefinition(); // <= FOUND\n\n```\n",
          "loc": [
            "[129](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L129-L136)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Lack Of Brace Spacing",
      "description": "Lack of brace spacing in coding refers to the absence of spaces around braces, which can hinder code readability. In Solidity, as in many programming languages, spacing can enhance the visual distinction between different parts of the code, making it easier to follow. A lack of spacing can lead to a dense, confusing appearance. The resolution to this issue is to follow a consistent style guide that defines rules for brace spacing. By including spaces around braces, such as `{ statement }` instead of `{statement}`, developers can ensure that the code is more legible and maintainable, especially in larger codebases.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\"); // <= FOUND\n\n```\n",
          "loc": [
            "[232](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L232-L232)"
          ]
        },
        {
          "content": "```solidity\n236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}(\"\"); // <= FOUND\n\n```\n",
          "loc": [
            "[236](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L236-L236)"
          ]
        },
        {
          "content": "```solidity\n240:                 (bool success3, ) = referralDefined\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}(\"\") // <= FOUND\n\n```\n",
          "loc": [
            "[240](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L240-L241)"
          ]
        },
        {
          "content": "```solidity\n248:                 feeRedistributor.addFees{value: holderFee}(curvesTokenSubject); // <= FOUND\n\n```\n",
          "loc": [
            "[248](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L248-L248)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "No access control on receive/payable fallback",
      "description": "Without access control on receive/payable fallback functions in a contract, anyone can send Ether (ETH) to the contract's address. If there's no way to withdraw those funds defined within the contract, any Ether sent, whether intentionally or by mistake, will be permanently stuck. This could lead to unintended loss of funds. Implementing proper access control ensures that only authorized addresses can interact with these functions. Resolution could involve adding access control mechanisms, like Ownable or specific permission requirements, or creating a withdrawal function accessible only to the contract's owner, thus preventing unintentional loss of funds.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n119:     receive() external payable {} // <= FOUND\n\n```\n",
          "loc": [
            "[119](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L119-L119)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "If statement control structures do not comply with best practices",
      "description": "If statements which include a single line do not need to have curly brackets, however according to the Solidiity style guide the line of code executed upon the if statement condition being met should still be on the next line, not on the same line as the if statement declaration.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n104:         if (curvesTokenSubject != msg.sender) revert UnauthorizedCurvesTokenSubject(); // <= FOUND\n\n```\n",
          "loc": [
            "[104](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L104-L104)"
          ]
        },
        {
          "content": "```solidity\n118:         if ( // <= FOUND\n119:             feesEconomics.protocolFeePercent +\n120:                 feesEconomics.subjectFeePercent +\n121:                 feesEconomics.referralFeePercent +\n122:                 feesEconomics.holdersFeePercent >\n123:             maxFeePercent_\n124:         ) revert InvalidFeeDefinition(); // <= FOUND\n\n```\n",
          "loc": [
            "[118](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L118-L124)"
          ]
        },
        {
          "content": "```solidity\n129:         if ( // <= FOUND\n130:             protocolFeePercent_ +\n131:                 feesEconomics.subjectFeePercent +\n132:                 feesEconomics.referralFeePercent +\n133:                 feesEconomics.holdersFeePercent >\n134:             feesEconomics.maxFeePercent ||\n135:             protocolFeeDestination_ == address(0)\n136:         ) revert InvalidFeeDefinition(); // <= FOUND\n\n```\n",
          "loc": [
            "[129](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L129-L136)"
          ]
        },
        {
          "content": "```solidity\n146:         if ( // <= FOUND\n147:             feesEconomics.protocolFeePercent + subjectFeePercent_ + referralFeePercent_ + holdersFeePercent_ >\n148:             feesEconomics.maxFeePercent\n149:         ) revert InvalidFeeDefinition(); // <= FOUND\n\n```\n",
          "loc": [
            "[146](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L146-L149)"
          ]
        },
        {
          "content": "```solidity\n213:         if (startTime != 0 && startTime >= block.timestamp) revert SaleNotOpen(); // <= FOUND\n\n```\n",
          "loc": [
            "[213](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L213-L213)"
          ]
        },
        {
          "content": "```solidity\n233:                 if (!success1) revert CannotSendFunds(); // <= FOUND\n\n```\n",
          "loc": [
            "[233](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L233-L233)"
          ]
        },
        {
          "content": "```solidity\n237:                 if (!success2) revert CannotSendFunds(); // <= FOUND\n\n```\n",
          "loc": [
            "[237](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L237-L237)"
          ]
        },
        {
          "content": "```solidity\n243:                 if (!success3) revert CannotSendFunds(); // <= FOUND\n\n```\n",
          "loc": [
            "[243](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L243-L243)"
          ]
        },
        {
          "content": "```solidity\n265:         if (!(supply > 0 || curvesTokenSubject == msg.sender)) revert UnauthorizedCurvesTokenSubject(); // <= FOUND\n\n```\n",
          "loc": [
            "[265](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L265-L265)"
          ]
        },
        {
          "content": "```solidity\n270: \n271:         if (msg.value < price + totalFee) revert InsufficientPayment(); // <= FOUND\n\n```\n",
          "loc": [
            "[270](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L270-L271)"
          ]
        },
        {
          "content": "```solidity\n284:         if (supply <= amount) revert LastTokenCannotBeSold(); // <= FOUND\n\n```\n",
          "loc": [
            "[284](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L284-L284)"
          ]
        },
        {
          "content": "```solidity\n285:         if (curvesTokenBalance[curvesTokenSubject][msg.sender] < amount) revert InsufficientBalance(); // <= FOUND\n\n```\n",
          "loc": [
            "[285](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L285-L285)"
          ]
        },
        {
          "content": "```solidity\n297:         if (to == address(this)) revert ContractCannotReceiveTransfer(); // <= FOUND\n\n```\n",
          "loc": [
            "[297](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L297-L297)"
          ]
        },
        {
          "content": "```solidity\n314:         if (amount > curvesTokenBalance[curvesTokenSubject][from]) revert InsufficientBalance(); // <= FOUND\n\n```\n",
          "loc": [
            "[314](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L314-L314)"
          ]
        },
        {
          "content": "```solidity\n350: \n351:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata(); // <= FOUND\n\n```\n",
          "loc": [
            "[350](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L350-L351)"
          ]
        },
        {
          "content": "```solidity\n371:         if (supply != 0) revert CurveAlreadyExists(); // <= FOUND\n\n```\n",
          "loc": [
            "[371](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L371-L371)"
          ]
        },
        {
          "content": "```solidity\n384:         if (startTime <= block.timestamp) revert InvalidPresaleStartTime(); // <= FOUND\n\n```\n",
          "loc": [
            "[384](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L384-L384)"
          ]
        },
        {
          "content": "```solidity\n396:         if (supply > 1) revert CurveAlreadyExists(); // <= FOUND\n\n```\n",
          "loc": [
            "[396](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L396-L396)"
          ]
        },
        {
          "content": "```solidity\n409:         if ( // <= FOUND\n410:             presalesMeta[curvesTokenSubject].startTime == 0 ||\n411:             presalesMeta[curvesTokenSubject].startTime <= block.timestamp\n412:         ) revert PresaleUnavailable(); // <= FOUND\n\n```\n",
          "loc": [
            "[409](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L409-L412)"
          ]
        },
        {
          "content": "```solidity\n416:         if (tokenBought > presalesMeta[curvesTokenSubject].maxBuy) revert ExceededMaxBuyAmount(); // <= FOUND\n\n```\n",
          "loc": [
            "[416](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L416-L416)"
          ]
        },
        {
          "content": "```solidity\n425:         if (!MerkleProof.verify(proof, presalesMeta[curvesTokenSubject].merkleRoot, leaf)) revert UnverifiedProof(); // <= FOUND\n\n```\n",
          "loc": [
            "[425](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L425-L425)"
          ]
        },
        {
          "content": "```solidity\n433:         if (externalCurvesTokens[curvesTokenSubject].token != address(0)) revert ERC20TokenAlreadyMinted(); // <= FOUND\n\n```\n",
          "loc": [
            "[433](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L433-L433)"
          ]
        },
        {
          "content": "```solidity\n350:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata(); // <= FOUND\n\n```\n",
          "loc": [
            "[350](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L350-L350)"
          ]
        },
        {
          "content": "```solidity\n466:         if (amount > curvesTokenBalance[curvesTokenSubject][msg.sender]) revert InsufficientBalance(); // <= FOUND\n\n```\n",
          "loc": [
            "[466](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L466-L466)"
          ]
        },
        {
          "content": "```solidity\n491:         if (amount % 1 ether != 0) revert NonIntegerDepositAmount(); // <= FOUND\n\n```\n",
          "loc": [
            "[491](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L491-L491)"
          ]
        },
        {
          "content": "```solidity\n496: \n497:         if (externalToken == address(0)) revert TokenAbsentForCurvesTokenSubject(); // <= FOUND\n\n```\n",
          "loc": [
            "[496](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L496-L497)"
          ]
        },
        {
          "content": "```solidity\n497:         if (amount > CurvesERC20(externalToken).balanceOf(msg.sender)) revert InsufficientBalance(); // <= FOUND\n\n```\n",
          "loc": [
            "[497](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L497-L497)"
          ]
        },
        {
          "content": "```solidity\n498:         if (tokenAmount > curvesTokenBalance[curvesTokenSubject][address(this)]) revert InsufficientBalance(); // <= FOUND\n\n```\n",
          "loc": [
            "[498](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L498-L498)"
          ]
        },
        {
          "content": "```solidity\n505:         if (externalCurvesTokens[curvesTokenSubject].token == address(0)) revert TokenAbsentForCurvesTokenSubject(); // <= FOUND\n\n```\n",
          "loc": [
            "[505](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L505-L505)"
          ]
        },
        {
          "content": "```solidity\n83:         if (claimable == 0) revert NoFeesToClaim(); // <= FOUND\n\n```\n",
          "loc": [
            "[83](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L83-L83)"
          ]
        },
        {
          "content": "```solidity\n91:         if (totalSupply_ == 0) revert NoTokenHolders(); // <= FOUND\n\n```\n",
          "loc": [
            "[91](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L91-L91)"
          ]
        },
        {
          "content": "```solidity\n99:         if (balanceOf(token, account) > 0) userTokens[account].push(token); // <= FOUND\n\n```\n",
          "loc": [
            "[99](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L99-L99)"
          ]
        },
        {
          "content": "```solidity\n115:         if (totalClaimable == 0) revert NoFeesToClaim(); // <= FOUND\n\n```\n",
          "loc": [
            "[115](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L115-L115)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Incorrect withdraw declaration",
      "description": "In Solidity, it's essential for clarity and interoperability to correctly specify return types in function declarations. If the `withdraw` function is expected to return a `bool` to indicate success or failure, its omission could lead to ambiguity or unexpected behavior when interacting with or calling this function from other contracts or off-chain systems. Missing return values can mislead developers and potentially lead to contract integrations built on incorrect assumptions. To resolve this, the function declaration for `withdraw` should be modified to explicitly include the `bool` return type, ensuring clarity and correctness in contract interactions.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n465:     function withdraw(address curvesTokenSubject, uint256 amount) public  // <= FOUND\n\n```\n",
          "loc": [
            "[465](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L465-L465)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider adding formal verification proofs",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n41: contract Curves is CurvesErrors, Security  // <= FOUND\n\n```\n",
          "loc": [
            "[41](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L41-L41)"
          ]
        },
        {
          "content": "```solidity\n9: contract FeeSplitter is Security  // <= FOUND\n\n```\n",
          "loc": [
            "[9](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L9-L9)"
          ]
        },
        {
          "content": "```solidity\n4: contract Security  // <= FOUND\n\n```\n",
          "loc": [
            "[4](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n7: contract CurvesERC20 is ERC20, Ownable  // <= FOUND\n\n```\n",
          "loc": [
            "[7](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L7-L7)"
          ]
        },
        {
          "content": "```solidity\n6: contract CurvesERC20Factory  // <= FOUND\n\n```\n",
          "loc": [
            "[6](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20Factory.sol#L6-L6)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use string.concat() on strings instead of abi.encodePacked() for clearer semantic meaning",
      "description": "From Solidity 0.8.12 onwards, developers can utilize `string.concat()` to concatenate strings without additional padding. Opting for `string.concat()` over `abi.encodePacked()` offers clearer semantic interpretation of the code's intent, enhancing readability. This shift minimizes ambiguity, reducing the potential for misinterpretation by reviewers or future developers. Thus, for string concatenation tasks, it's recommended to transition to `string.concat()` for transparent, straightforward code that communicates its purpose distinctly.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n338:     function _deployERC20(\n339:         address curvesTokenSubject,\n340:         string memory name,\n341:         string memory symbol\n342:     ) internal returns (address) {\n343:         \n344:         if (keccak256(bytes(symbol)) == keccak256(bytes(DEFAULT_SYMBOL))) {\n345:             _curvesTokenCounter += 1;\n346:             name = string(abi.encodePacked(name, \" \", Strings.toString(_curvesTokenCounter))); // <= FOUND\n347:             symbol = string(abi.encodePacked(symbol, Strings.toString(_curvesTokenCounter))); // <= FOUND\n348:         }\n349: \n350:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();\n351: \n352:         address tokenContract = CurvesERC20Factory(curvesERC20Factory).deploy(name, symbol, address(this));\n353: \n354:         externalCurvesTokens[curvesTokenSubject].token = tokenContract;\n355:         externalCurvesTokens[curvesTokenSubject].name = name;\n356:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;\n357:         externalCurvesToSubject[tokenContract] = curvesTokenSubject;\n358:         symbolToSubject[symbol] = curvesTokenSubject;\n359: \n360:         emit TokenDeployed(curvesTokenSubject, tokenContract, name, symbol);\n361:         return address(tokenContract);\n362:     }\n\n```\n",
          "loc": [
            "[338](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L338-L347)"
          ]
        },
        {
          "content": "```solidity\n439:     function mint(address curvesTokenSubject) external onlyTokenSubject(curvesTokenSubject) { // <= FOUND\n440:         if (\n441:             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==\n442:             keccak256(abi.encodePacked(\"\")) ||\n443:             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==\n444:             keccak256(abi.encodePacked(\"\"))\n445:         ) {\n446:             externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME;\n447:             externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL;\n448:         }\n449:         _mint(\n450:             curvesTokenSubject,\n451:             externalCurvesTokens[curvesTokenSubject].name,\n452:             externalCurvesTokens[curvesTokenSubject].symbol\n453:         );\n454:     }\n\n```\n",
          "loc": [
            "[439](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L439-L439)"
          ]
        },
        {
          "content": "```solidity\n465:     function withdraw(address curvesTokenSubject, uint256 amount) public { // <= FOUND\n466:         if (amount > curvesTokenBalance[curvesTokenSubject][msg.sender]) revert InsufficientBalance();\n467: \n468:         address externalToken = externalCurvesTokens[curvesTokenSubject].token;\n469:         if (externalToken == address(0)) {\n470:             if (\n471:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==\n472:                 keccak256(abi.encodePacked(\"\")) ||\n473:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==\n474:                 keccak256(abi.encodePacked(\"\"))\n475:             ) {\n476:                 externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME;\n477:                 externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL;\n478:             }\n479:             _deployERC20(\n480:                 curvesTokenSubject,\n481:                 externalCurvesTokens[curvesTokenSubject].name,\n482:                 externalCurvesTokens[curvesTokenSubject].symbol\n483:             );\n484:             externalToken = externalCurvesTokens[curvesTokenSubject].token;\n485:         }\n486:         _transfer(curvesTokenSubject, msg.sender, address(this), amount);\n487:         CurvesERC20(externalToken).mint(msg.sender, amount * 1 ether);\n488:     }\n\n```\n",
          "loc": [
            "[465](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L465-L465)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider bounding input array length",
      "description": "Unbounded array inputs in functions can lead to unintentional excessive gas consumption, potentially causing a transaction to revert after expending substantial gas. To enhance user experience and prevent such scenarios, consider implementing a `require()` statement that limits the array length to a defined maximum. This constraint ensures that transactions won't proceed if they're likely to hit gas limits due to array size, saving users from unnecessary gas costs and offering a more predictable interaction with the contract.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n305:        for (uint256 i = 0; i < subjects.length; i++) { // <= FOUND\n306:             uint256 amount = curvesTokenBalance[subjects[i]][msg.sender];\n307:             if (amount > 0) {\n308:                 _transfer(subjects[i], msg.sender, to, amount);\n309:             }\n310:         }\n\n```\n",
          "loc": [
            "[305](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L305-L305)"
          ]
        },
        {
          "content": "```solidity\n330:        for (uint256 i = 0; i < subjects.length; i++) { // <= FOUND\n331:             if (subjects[i] == curvesTokenSubject) {\n332:                 return;\n333:             }\n334:         }\n\n```\n",
          "loc": [
            "[330](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L330-L330)"
          ]
        },
        {
          "content": "```solidity\n55:        for (uint256 i = 0; i < tokens.length; i++) { // <= FOUND\n56:             address token = tokens[i];\n57:             uint256 claimable = getClaimableFees(token, user);\n58:             result[i] = UserClaimData(claimable, token);\n59:         }\n\n```\n",
          "loc": [
            "[55](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L55-L55)"
          ]
        },
        {
          "content": "```solidity\n105:        for (uint256 i = 0; i < tokenList.length; i++) { // <= FOUND\n106:             address token = tokenList[i];\n107:             updateFeeCredit(token, msg.sender);\n108:             uint256 claimable = getClaimableFees(token, msg.sender);\n109:             if (claimable > 0) {\n110:                 tokensData[token].unclaimedFees[msg.sender] = 0;\n111:                 totalClaimable += claimable;\n112:                 emit FeesClaimed(token, msg.sender, claimable);\n113:             }\n114:         }\n\n```\n",
          "loc": [
            "[105](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L105-L105)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Avoid mutating function parameters",
      "description": "Function parameters in Solidity are passed by value, meaning they are essentially local copies. Mutating them can lead to confusion and errors because the changes don't persist outside the function. By keeping function parameters immutable, you ensure clarity in code behavior, preventing unintended side-effects. If you need to modify a value based on a parameter, use a local variable inside the function, leaving the original parameter unaltered. By adhering to this practice, you maintain a clear distinction between input data and the internal processing logic, improving code readability and reducing the potential for bugs.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n338:     function _deployERC20(\n339:         address curvesTokenSubject,\n340:         string memory name,\n341:         string memory symbol\n342:     ) internal returns (address) {\n343:         \n344:         if (keccak256(bytes(symbol)) == keccak256(bytes(DEFAULT_SYMBOL))) {\n345:             _curvesTokenCounter += 1;\n346:             name = string(abi.encodePacked(name, \" \", Strings.toString(_curvesTokenCounter))); // <= FOUND\n347:             symbol = string(abi.encodePacked(symbol, Strings.toString(_curvesTokenCounter))); // <= FOUND\n348:         }\n349: \n350:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();\n351: \n352:         address tokenContract = CurvesERC20Factory(curvesERC20Factory).deploy(name, symbol, address(this));\n353: \n354:         externalCurvesTokens[curvesTokenSubject].token = tokenContract;\n355:         externalCurvesTokens[curvesTokenSubject].name = name;\n356:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;\n357:         externalCurvesToSubject[tokenContract] = curvesTokenSubject;\n358:         symbolToSubject[symbol] = curvesTokenSubject;\n359: \n360:         emit TokenDeployed(curvesTokenSubject, tokenContract, name, symbol);\n361:         return address(tokenContract);\n362:     }\n\n```\n",
          "loc": [
            "[338](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L338-L347)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "It is best practice to use linear inheritance",
      "description": "In Solidity, complex inheritance structures can obfuscate code understanding, introducing potential security risks. Multiple inheritance, especially with overlapping function names or state variables, can cause unintentional overrides or ambiguous behavior. Resolution: Strive for linear and simple inheritance chains. Avoid diamond or circular inheritance patterns. Clearly document the purpose and relationships of base contracts, ensuring that overrides are intentional. Tools like Remix or Hardhat can visualize inheritance chains, assisting in verification. Keeping inheritance streamlined aids in better code readability, reduces potential errors, and ensures smoother audits and upgrades.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n41: contract Curves is CurvesErrors, Security  // <= FOUND\n\n```\n",
          "loc": [
            "[41](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L41-L41)"
          ]
        },
        {
          "content": "```solidity\n7: contract CurvesERC20 is ERC20, Ownable  // <= FOUND\n\n```\n",
          "loc": [
            "[7](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L7-L7)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Contracts with only unimplemented functions can be labeled as abstract",
      "description": "In Solidity, a contract that's not meant to be deployed on its own but is intended to be inherited by other contracts should be marked `abstract`. This ensures that developers recognize the contract's incomplete or intended-to-be-extended nature. If a contract has unimplemented functions or is designed with the intention that another contract should extend its functionality, it should be explicitly labeled as `abstract`. This helps prevent inadvertent deployments and clearly communicates the contract's purpose to other developers. Resolution: Review the contract, and if it's not supposed to function standalone, mark it as `abstract` to make the intention clear.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n6: contract CurvesERC20Factory \n\n```\n",
          "loc": [
            "[6](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20Factory.sol#L6-L6)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "A event should be emitted if a non immutable state variable is set in a constructor",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n108:     constructor(address curvesERC20Factory_, address feeRedistributor_) Security() {\n109:         curvesERC20Factory = curvesERC20Factory_; // <= FOUND\n110:         feeRedistributor = FeeSplitter(payable(feeRedistributor_)); // <= FOUND\n111:     }\n\n```\n",
          "loc": [
            "[108](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L108-L110)"
          ]
        },
        {
          "content": "```solidity\n18:     constructor() {\n19:         owner = msg.sender; // <= FOUND\n20:         managers[msg.sender] = true;\n21:     }\n\n```\n",
          "loc": [
            "[18](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L18-L19)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Create methods are suspicious of the reorg attack",
      "description": "\"Create\" methods, which deploy contracts via \" = new <contract>\", are at risk from re-org attacks since the derived contract address is solely based on the Factory's nonce. Re-orgs, chain reorganizations, can occur across all EVM chains. The vulnerability amplifies when deploying contracts on EVM-compatible L2 solutions like Arbitrum and Polygon, which are notably susceptible to re-org attacks. Ethereum, a primary deployment target, has already experienced re-org events.\n\nTo bolster security against re-org threats, developers are advised to use the `create2` method for contract deployments instead of the basic `create`. By using `create2` with a salt that includes `msg.sender`, the contract's address derivation becomes more predictable and less prone to unexpected changes due to re-orgs. This strategy not only provides a more consistent deployment pattern but also minimizes risks associated with potential blockchain reorganizations.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n7:     function deploy(string memory name, string memory symbol, address owner) public returns (address) {\n8:         CurvesERC20 tokenContract = new CurvesERC20(name, symbol, owner); // <= FOUND\n9:         return address(tokenContract);\n10:     }\n\n```\n",
          "loc": [
            "[8](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20Factory.sol#L8-L8)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Contracts use both += 1 and ++ (-- and -= 1)",
      "description": "For consistency consider only using one of these incrementing methods.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n41: contract Curves is CurvesErrors, Security {\n42:     address public curvesERC20Factory;\n43:     FeeSplitter public feeRedistributor;\n44:     string public constant DEFAULT_NAME = \"Curves\";\n45:     string public constant DEFAULT_SYMBOL = \"CURVES\";\n46:     \n47:     uint256 private _curvesTokenCounter = 0;\n48: \n49:     struct ExternalTokenMeta {\n50:         string name;\n51:         string symbol;\n52:         address token;\n53:     }\n54: \n55:     struct PresaleMeta {\n56:         uint256 startTime;\n57:         bytes32 merkleRoot;\n58:         uint256 maxBuy;\n59:     }\n60: \n61:     mapping(address => ExternalTokenMeta) public externalCurvesTokens;\n62:     mapping(address => address) public externalCurvesToSubject;\n63:     mapping(string => address) public symbolToSubject;\n64: \n65:     mapping(address => PresaleMeta) public presalesMeta;\n66:     mapping(address => mapping(address => uint256)) public presalesBuys;\n67: \n68:     struct FeesEconomics {\n69:         address protocolFeeDestination;\n70:         uint256 protocolFeePercent;\n71:         uint256 subjectFeePercent;\n72:         uint256 referralFeePercent;\n73:         uint256 holdersFeePercent;\n74:         uint256 maxFeePercent;\n75:     }\n76: \n77:     FeesEconomics public feesEconomics;\n78:     mapping(address => address) public referralFeeDestination;\n79: \n80:     event Trade(\n81:         address trader,\n82:         address subject,\n83:         bool isBuy,\n84:         uint256 tokenAmount,\n85:         uint256 ethAmount,\n86:         uint256 protocolEthAmount,\n87:         uint256 subjectEthAmount,\n88:         uint256 supply\n89:     );\n90: \n91:     event Transfer(address indexed curvesTokenSubject, address indexed from, address indexed to, uint256 value);\n92:     event WhitelistUpdated(address indexed presale, bytes32 indexed root);\n93:     event TokenDeployed(address indexed curvesTokenSubject, address indexed erc20token, string name, string symbol);\n94: \n96:     mapping(address => mapping(address => uint256)) public curvesTokenBalance;\n97: \n99:     mapping(address => uint256) public curvesTokenSupply;\n100: \n101:     mapping(address => address[]) private ownedCurvesTokenSubjects;\n102: \n103:     modifier onlyTokenSubject(address curvesTokenSubject) {\n104:         if (curvesTokenSubject != msg.sender) revert UnauthorizedCurvesTokenSubject();\n105:         _;\n106:     }\n107: \n108:     constructor(address curvesERC20Factory_, address feeRedistributor_) Security() {\n109:         curvesERC20Factory = curvesERC20Factory_;\n110:         feeRedistributor = FeeSplitter(payable(feeRedistributor_));\n111:     }\n112: \n113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner {\n114:         feeRedistributor = FeeSplitter(payable(feeRedistributor_));\n115:     }\n116: \n117:     function setMaxFeePercent(uint256 maxFeePercent_) external onlyManager {\n118:         if (\n119:             feesEconomics.protocolFeePercent +\n120:                 feesEconomics.subjectFeePercent +\n121:                 feesEconomics.referralFeePercent +\n122:                 feesEconomics.holdersFeePercent >\n123:             maxFeePercent_\n124:         ) revert InvalidFeeDefinition();\n125:         feesEconomics.maxFeePercent = maxFeePercent_;\n126:     }\n127: \n128:     function setProtocolFeePercent(uint256 protocolFeePercent_, address protocolFeeDestination_) external onlyOwner {\n129:         if (\n130:             protocolFeePercent_ +\n131:                 feesEconomics.subjectFeePercent +\n132:                 feesEconomics.referralFeePercent +\n133:                 feesEconomics.holdersFeePercent >\n134:             feesEconomics.maxFeePercent ||\n135:             protocolFeeDestination_ == address(0)\n136:         ) revert InvalidFeeDefinition();\n137:         feesEconomics.protocolFeePercent = protocolFeePercent_;\n138:         feesEconomics.protocolFeeDestination = protocolFeeDestination_;\n139:     }\n140: \n141:     function setExternalFeePercent(\n142:         uint256 subjectFeePercent_,\n143:         uint256 referralFeePercent_,\n144:         uint256 holdersFeePercent_\n145:     ) external onlyManager {\n146:         if (\n147:             feesEconomics.protocolFeePercent + subjectFeePercent_ + referralFeePercent_ + holdersFeePercent_ >\n148:             feesEconomics.maxFeePercent\n149:         ) revert InvalidFeeDefinition();\n150:         feesEconomics.subjectFeePercent = subjectFeePercent_;\n151:         feesEconomics.referralFeePercent = referralFeePercent_;\n152:         feesEconomics.holdersFeePercent = holdersFeePercent_;\n153:     }\n154: \n155:     function setReferralFeeDestination(\n156:         address curvesTokenSubject,\n157:         address referralFeeDestination_\n158:     ) public onlyTokenSubject(curvesTokenSubject) {\n159:         referralFeeDestination[curvesTokenSubject] = referralFeeDestination_;\n160:     }\n161: \n162:     function setERC20Factory(address factory_) external onlyOwner {\n163:         curvesERC20Factory = factory_;\n164:     }\n165: \n166:     function getFees(\n167:         uint256 price\n168:     )\n169:         public\n170:         view\n171:         returns (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holdersFee, uint256 totalFee)\n172:     {\n173:         protocolFee = (price * feesEconomics.protocolFeePercent) / 1 ether;\n174:         subjectFee = (price * feesEconomics.subjectFeePercent) / 1 ether;\n175:         referralFee = (price * feesEconomics.referralFeePercent) / 1 ether;\n176:         holdersFee = (price * feesEconomics.holdersFeePercent) / 1 ether;\n177:         totalFee = protocolFee + subjectFee + referralFee + holdersFee;\n178:     }\n179: \n180:     function getPrice(uint256 supply, uint256 amount) public pure returns (uint256) {\n181:         uint256 sum1 = supply == 0 ? 0 : ((supply - 1) * (supply) * (2 * (supply - 1) + 1)) / 6;\n182:         uint256 sum2 = supply == 0 && amount == 1\n183:             ? 0\n184:             : ((supply - 1 + amount) * (supply + amount) * (2 * (supply - 1 + amount) + 1)) / 6;\n185:         uint256 summation = sum2 - sum1;\n186:         return (summation * 1 ether) / 16000;\n187:     }\n188: \n189:     function getBuyPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) {\n190:         return getPrice(curvesTokenSupply[curvesTokenSubject], amount);\n191:     }\n192: \n193:     function getSellPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) {\n194:         return getPrice(curvesTokenSupply[curvesTokenSubject] - amount, amount);\n195:     }\n196: \n197:     function getBuyPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {\n198:         uint256 price = getBuyPrice(curvesTokenSubject, amount);\n199:         (, , , , uint256 totalFee) = getFees(price);\n200: \n201:         return price + totalFee;\n202:     }\n203: \n204:     function getSellPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) {\n205:         uint256 price = getSellPrice(curvesTokenSubject, amount);\n206:         (, , , , uint256 totalFee) = getFees(price);\n207: \n208:         return price - totalFee;\n209:     }\n210: \n211:     function buyCurvesToken(address curvesTokenSubject, uint256 amount) public payable {\n212:         uint256 startTime = presalesMeta[curvesTokenSubject].startTime;\n213:         if (startTime != 0 && startTime >= block.timestamp) revert SaleNotOpen();\n214: \n215:         _buyCurvesToken(curvesTokenSubject, amount);\n216:     }\n217: \n218:     function _transferFees(\n219:         address curvesTokenSubject,\n220:         bool isBuy,\n221:         uint256 price,\n222:         uint256 amount,\n223:         uint256 supply\n224:     ) internal {\n225:         (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holderFee, ) = getFees(price);\n226:         {\n227:             bool referralDefined = referralFeeDestination[curvesTokenSubject] != address(0);\n228:             {\n229:                 address firstDestination = isBuy ? feesEconomics.protocolFeeDestination : msg.sender;\n230:                 uint256 buyValue = referralDefined ? protocolFee : protocolFee + referralFee;\n231:                 uint256 sellValue = price - protocolFee - subjectFee - referralFee - holderFee;\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\");\n233:                 if (!success1) revert CannotSendFunds();\n234:             }\n235:             {\n236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}(\"\");\n237:                 if (!success2) revert CannotSendFunds();\n238:             }\n239:             {\n240:                 (bool success3, ) = referralDefined\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}(\"\")\n242:                     : (true, bytes(\"\"));\n243:                 if (!success3) revert CannotSendFunds();\n244:             }\n245: \n246:             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0)) {\n247:                 feeRedistributor.onBalanceChange(curvesTokenSubject, msg.sender);\n248:                 feeRedistributor.addFees{value: holderFee}(curvesTokenSubject);\n249:             }\n250:         }\n251:         emit Trade(\n252:             msg.sender,\n253:             curvesTokenSubject,\n254:             isBuy,\n255:             amount,\n256:             price,\n257:             protocolFee,\n258:             subjectFee,\n259:             isBuy ? supply + amount : supply - amount\n260:         );\n261:     }\n262: \n263:     function _buyCurvesToken(address curvesTokenSubject, uint256 amount) internal {\n264:         uint256 supply = curvesTokenSupply[curvesTokenSubject];\n265:         if (!(supply > 0 || curvesTokenSubject == msg.sender)) revert UnauthorizedCurvesTokenSubject();\n266: \n267:         uint256 price = getPrice(supply, amount);\n268:         (, , , , uint256 totalFee) = getFees(price);\n269: \n270:         if (msg.value < price + totalFee) revert InsufficientPayment();\n271: \n272:         curvesTokenBalance[curvesTokenSubject][msg.sender] += amount;\n273:         curvesTokenSupply[curvesTokenSubject] = supply + amount;\n274:         _transferFees(curvesTokenSubject, true, price, amount, supply);\n275: \n276:         \n277:         if (curvesTokenBalance[curvesTokenSubject][msg.sender] - amount == 0) {\n278:             _addOwnedCurvesTokenSubject(msg.sender, curvesTokenSubject);\n279:         }\n280:     }\n281: \n282:     function sellCurvesToken(address curvesTokenSubject, uint256 amount) public {\n283:         uint256 supply = curvesTokenSupply[curvesTokenSubject];\n284:         if (supply <= amount) revert LastTokenCannotBeSold();\n285:         if (curvesTokenBalance[curvesTokenSubject][msg.sender] < amount) revert InsufficientBalance();\n286: \n287:         uint256 price = getPrice(supply - amount, amount);\n288: \n289:         curvesTokenBalance[curvesTokenSubject][msg.sender] -= amount;\n290:         curvesTokenSupply[curvesTokenSubject] = supply - amount;\n291: \n292:         _transferFees(curvesTokenSubject, false, price, amount, supply);\n293:     }\n294: \n296:     function transferCurvesToken(address curvesTokenSubject, address to, uint256 amount) external {\n297:         if (to == address(this)) revert ContractCannotReceiveTransfer();\n298:         _transfer(curvesTokenSubject, msg.sender, to, amount);\n299:     }\n300: \n302:     function transferAllCurvesTokens(address to) external {\n303:         if (to == address(this)) revert ContractCannotReceiveTransfer();\n304:         address[] storage subjects = ownedCurvesTokenSubjects[msg.sender];\n305:         for (uint256 i = 0; i < subjects.length; i++) { // <= FOUND\n306:             uint256 amount = curvesTokenBalance[subjects[i]][msg.sender];\n307:             if (amount > 0) {\n308:                 _transfer(subjects[i], msg.sender, to, amount);\n309:             }\n310:         }\n311:     }\n312: \n313:     function _transfer(address curvesTokenSubject, address from, address to, uint256 amount) internal {\n314:         if (amount > curvesTokenBalance[curvesTokenSubject][from]) revert InsufficientBalance();\n315: \n316:         \n317:         if (from != to) {\n318:             _addOwnedCurvesTokenSubject(to, curvesTokenSubject);\n319:         }\n320: \n321:         curvesTokenBalance[curvesTokenSubject][from] = curvesTokenBalance[curvesTokenSubject][from] - amount;\n322:         curvesTokenBalance[curvesTokenSubject][to] = curvesTokenBalance[curvesTokenSubject][to] + amount;\n323: \n324:         emit Transfer(curvesTokenSubject, from, to, amount);\n325:     }\n326: \n328:     function _addOwnedCurvesTokenSubject(address owner_, address curvesTokenSubject) internal {\n329:         address[] storage subjects = ownedCurvesTokenSubjects[owner_];\n330:         for (uint256 i = 0; i < subjects.length; i++) { // <= FOUND\n331:             if (subjects[i] == curvesTokenSubject) {\n332:                 return;\n333:             }\n334:         }\n335:         subjects.push(curvesTokenSubject);\n336:     }\n337: \n338:     function _deployERC20(\n339:         address curvesTokenSubject,\n340:         string memory name,\n341:         string memory symbol\n342:     ) internal returns (address) {\n343:         \n344:         if (keccak256(bytes(symbol)) == keccak256(bytes(DEFAULT_SYMBOL))) {\n345:             _curvesTokenCounter += 1; // <= FOUND\n346:             name = string(abi.encodePacked(name, \" \", Strings.toString(_curvesTokenCounter)));\n347:             symbol = string(abi.encodePacked(symbol, Strings.toString(_curvesTokenCounter)));\n348:         }\n349: \n350:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();\n351: \n352:         address tokenContract = CurvesERC20Factory(curvesERC20Factory).deploy(name, symbol, address(this));\n353: \n354:         externalCurvesTokens[curvesTokenSubject].token = tokenContract;\n355:         externalCurvesTokens[curvesTokenSubject].name = name;\n356:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;\n357:         externalCurvesToSubject[tokenContract] = curvesTokenSubject;\n358:         symbolToSubject[symbol] = curvesTokenSubject;\n359: \n360:         emit TokenDeployed(curvesTokenSubject, tokenContract, name, symbol);\n361:         return address(tokenContract);\n362:     }\n363: \n364:     function buyCurvesTokenWithName(\n365:         address curvesTokenSubject,\n366:         uint256 amount,\n367:         string memory name,\n368:         string memory symbol\n369:     ) public payable {\n370:         uint256 supply = curvesTokenSupply[curvesTokenSubject];\n371:         if (supply != 0) revert CurveAlreadyExists();\n372: \n373:         _buyCurvesToken(curvesTokenSubject, amount);\n374:         _mint(curvesTokenSubject, name, symbol);\n375:     }\n376: \n377:     function buyCurvesTokenForPresale(\n378:         address curvesTokenSubject,\n379:         uint256 amount,\n380:         uint256 startTime,\n381:         bytes32 merkleRoot,\n382:         uint256 maxBuy\n383:     ) public payable onlyTokenSubject(curvesTokenSubject) {\n384:         if (startTime <= block.timestamp) revert InvalidPresaleStartTime();\n385:         uint256 supply = curvesTokenSupply[curvesTokenSubject];\n386:         if (supply != 0) revert CurveAlreadyExists();\n387:         presalesMeta[curvesTokenSubject].startTime = startTime;\n388:         presalesMeta[curvesTokenSubject].merkleRoot = merkleRoot;\n389:         presalesMeta[curvesTokenSubject].maxBuy = (maxBuy == 0 ? type(uint256).max : maxBuy);\n390: \n391:         _buyCurvesToken(curvesTokenSubject, amount);\n392:     }\n393: \n394:     function setWhitelist(bytes32 merkleRoot) external {\n395:         uint256 supply = curvesTokenSupply[msg.sender];\n396:         if (supply > 1) revert CurveAlreadyExists();\n397: \n398:         if (presalesMeta[msg.sender].merkleRoot != merkleRoot) {\n399:             presalesMeta[msg.sender].merkleRoot = merkleRoot;\n\n```\n",
          "loc": [
            "[41](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L41-L345)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Using constants directly, rather than caching the value, saves gas",
      "description": "In smart contract development, especially within Ethereum, gas optimization is crucial. Utilizing constants directly, instead of assigning them to a variable (caching) before use, can save gas as reading from a constant is cheaper than reading from storage or a variable. Constants in Solidity are replaced by their actual value in the EVM bytecode, eliminating the need for a SLOAD operation, which costs more gas. Hence, if a value will not change throughout the contract's life, defining it as a constant and using it directly in expressions/functions can be a gas-efficient practice. ",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n439:     function mint(address curvesTokenSubject) external onlyTokenSubject(curvesTokenSubject) {\n440:         if (\n441:             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==\n442:             keccak256(abi.encodePacked(\"\")) ||\n443:             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==\n444:             keccak256(abi.encodePacked(\"\"))\n445:         ) {\n446:             externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME; // <= FOUND\n447:             externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL; // <= FOUND\n448:         }\n449:         _mint(\n450:             curvesTokenSubject,\n451:             externalCurvesTokens[curvesTokenSubject].name,\n452:             externalCurvesTokens[curvesTokenSubject].symbol\n453:         );\n454:     }\n\n```\n",
          "loc": [
            "[439](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L439-L447)"
          ]
        },
        {
          "content": "```solidity\n465:     function withdraw(address curvesTokenSubject, uint256 amount) public {\n466:         if (amount > curvesTokenBalance[curvesTokenSubject][msg.sender]) revert InsufficientBalance();\n467: \n468:         address externalToken = externalCurvesTokens[curvesTokenSubject].token;\n469:         if (externalToken == address(0)) {\n470:             if (\n471:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==\n472:                 keccak256(abi.encodePacked(\"\")) ||\n473:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==\n474:                 keccak256(abi.encodePacked(\"\"))\n475:             ) {\n476:                 externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME; // <= FOUND\n477:                 externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL; // <= FOUND\n478:             }\n479:             _deployERC20(\n480:                 curvesTokenSubject,\n481:                 externalCurvesTokens[curvesTokenSubject].name,\n482:                 externalCurvesTokens[curvesTokenSubject].symbol\n483:             );\n484:             externalToken = externalCurvesTokens[curvesTokenSubject].token;\n485:         }\n486:         _transfer(curvesTokenSubject, msg.sender, address(this), amount);\n487:         CurvesERC20(externalToken).mint(msg.sender, amount * 1 ether);\n488:     }\n\n```\n",
          "loc": [
            "[465](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L465-L477)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Public variable declarations should have NatSpec descriptions",
      "description": "Public variable declarations in smart contracts should ideally be accompanied by NatSpec comments to enhance code readability and provide clear documentation. NatSpec (Natural Language Specification) is a standard for writing comments in Ethereum smart contracts that can generate user-friendly documentation, improving the transparency of the contract's functionality. This is particularly crucial for public variables, as they are accessible externally, and understanding their role and impact is vital for both developers and users interacting with the contract",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n42:     address public curvesERC20Factory; // <= FOUND\n43:     FeeSplitter public feeRedistributor; // <= FOUND\n44:     string public constant DEFAULT_NAME = \"Curves\"; // <= FOUND\n\n```\n",
          "loc": [
            "[42](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L42-L44)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use += for mappings",
      "description": "Using `+=` for mappings simplifies code and can potentially save gas. When you need to increment a value within a mapping, writing `mappingA[xyz] = mappingA[xyz] + 1;` can be made more concise with `mappingA[xyz] += 1;`.\n\n**Resolution**: To enhance code clarity and potentially reduce gas costs, replace explicit addition assignments with the `+=` operator when dealing with mappings. This not only shortens the code but also makes it easier to read and understand. Employ tools like linters or static analysis to systematically identify and correct such instances, ensuring optimized and cleaner code throughout your smart contract.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n322:         curvesTokenBalance[curvesTokenSubject][to] = curvesTokenBalance[curvesTokenSubject][to] + amount; // <= FOUND\n\n```\n",
          "loc": [
            "[322](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L322-L322)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use -= for mappings",
      "description": "Using -= for mappings instead of explicitly subtracting a value ensures cleaner code and potential gas savings. When manipulating numerical values within a mapping, it's more gas-efficient and clearer to use compound assignment operators like -=. For instance, instead of writing mappingA[xyz] = mappingA[xyz] - 1;, you can simply use mappingA[xyz] -= 1;.\n\nResolution: Replace explicit subtraction assignments with the -= operator for mappings. This not only makes the code more concise and readable but also potentially reduces gas costs. Utilize linters or static analysis tools to identify instances where the code can be optimized in this manner, ensuring consistency and efficiency across the codebase.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n321: \n322:         curvesTokenBalance[curvesTokenSubject][from] = curvesTokenBalance[curvesTokenSubject][from] - amount; // <= FOUND\n\n```\n",
          "loc": [
            "[321](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L321-L322)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use the Modern Upgradeable Contract Paradigm",
      "description": "Modern smart contract development often employs upgradeable contract structures, utilizing proxy patterns like OpenZeppelin’s Upgradeable Contracts. This paradigm separates logic and state, allowing developers to amend and enhance the contract's functionality without altering its state or the deployed contract address. Transitioning to this approach enhances long-term maintainability.\n\n**Resolution**: Adopt a well-established proxy pattern for upgradeability, ensuring proper initialization and employing transparent proxies to mitigate potential risks. Embrace comprehensive testing and audit practices, particularly when updating contract logic, to ensure state consistency and security are preserved across upgrades. This ensures your contract remains robust and adaptable to future requirements.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n41: contract Curves is CurvesErrors, Security \n\n```\n",
          "loc": [
            "[41](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L41-L41)"
          ]
        },
        {
          "content": "```solidity\n9: contract FeeSplitter is Security \n\n```\n",
          "loc": [
            "[9](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L9-L9)"
          ]
        },
        {
          "content": "```solidity\n4: contract Security \n\n```\n",
          "loc": [
            "[4](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n7: contract CurvesERC20 is ERC20, Ownable \n\n```\n",
          "loc": [
            "[7](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L7-L7)"
          ]
        },
        {
          "content": "```solidity\n6: contract CurvesERC20Factory \n\n```\n",
          "loc": [
            "[6](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20Factory.sol#L6-L6)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Upgrade openzeppelin to the Latest Version - 5.0.0",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n4: import \"@openzeppelin/contracts/utils/Strings.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[4](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n5: import \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[5](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L5-L5)"
          ]
        },
        {
          "content": "```solidity\n7: import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[7](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L7-L7)"
          ]
        },
        {
          "content": "```solidity\n4: import \"@openzeppelin/contracts/access/Ownable.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[4](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n5: import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[5](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L5-L5)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use transfer libraries instead of low level calls",
      "description": "Using transfer libraries like OpenZeppelin's Address.sendValue is preferred over low-level calls for transferring Ether in Solidity. These libraries provide clearer, more semantically meaningful methods compared to low-level call() functions. They encapsulate best practices for error handling and gas management, enhancing the security and readability of your code. Low-level calls lack these built-in safety checks and can be more error-prone, especially when dealing with Ether transfers.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\"); // <= FOUND\n\n```\n",
          "loc": [
            "[232](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L232-L232)"
          ]
        },
        {
          "content": "```solidity\n236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}(\"\"); // <= FOUND\n\n```\n",
          "loc": [
            "[236](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L236-L236)"
          ]
        },
        {
          "content": "```solidity\n240:                 (bool success3, ) = referralDefined\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}(\"\") // <= FOUND\n\n```\n",
          "loc": [
            "[240](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L240-L241)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use a struct to encapsulate multiple function parameters",
      "description": "Using a struct to encapsulate multiple parameters in Solidity functions can significantly enhance code readability and maintainability. Instead of passing a long list of arguments, which can be error-prone and hard to manage, a struct allows grouping related data into a single, coherent entity. This approach simplifies function signatures and makes the code more organized. It also enhances code clarity, as developers can easily understand the relationship between the parameters. Moreover, it aids in future code modifications and expansions, as adding or modifying a parameter only requires changes in the struct definition, rather than in every function that uses these parameters.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n218:     function _transferFees(\n219:         address curvesTokenSubject, // <= FOUND\n220:         bool isBuy, // <= FOUND\n221:         uint256 price, // <= FOUND\n222:         uint256 amount, // <= FOUND\n223:         uint256 supply\n224:     ) internal \n\n```\n",
          "loc": [
            "[219](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L219-L222)"
          ]
        },
        {
          "content": "```solidity\n377:     function buyCurvesTokenForPresale(\n378:         address curvesTokenSubject, // <= FOUND\n379:         uint256 amount, // <= FOUND\n380:         uint256 startTime, // <= FOUND\n381:         bytes32 merkleRoot, // <= FOUND\n382:         uint256 maxBuy\n383:     ) public payable onlyTokenSubject(curvesTokenSubject) \n\n```\n",
          "loc": [
            "[378](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L378-L381)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Returning a struct instead of returning many variables is better",
      "description": "Returning a struct from a Solidity function instead of multiple variables offers several benefits, enhancing code clarity and efficiency. Structs allow for the grouping of related data into a single entity, making the function's return values more organized and easier to manage. This approach significantly improves readability, as it encapsulates the data logically, helping developers quickly understand the returned information's structure. Additionally, it simplifies function interfaces, reducing the potential for errors when handling multiple return values. By using structs, you can also easily extend or modify the returned data without altering the function signature, facilitating smoother updates and maintenance of your smart contract code.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n166:     function getFees(\n167:         uint256 price\n168:     )\n169:         public\n170:         view\n171:         returns (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holdersFee, uint256 totalFee) // <= FOUND\n172:     \n\n```\n",
          "loc": [
            "[171](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L171-L171)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Using delete instead of setting mapping to 0 saves gas",
      "description": "",
      "gasSavings": 10,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n84:         tokensData[token].unclaimedFees[msg.sender] = 0; // <= FOUND\n\n```\n",
          "loc": [
            "[84](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L84-L84)"
          ]
        },
        {
          "content": "```solidity\n110:                 tokensData[token].unclaimedFees[msg.sender] = 0; // <= FOUND\n\n```\n",
          "loc": [
            "[110](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L110-L110)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider using ERC20Capped",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n439:     function mint(address curvesTokenSubject) external onlyTokenSubject(curvesTokenSubject) { // <= FOUND\n440:         if (\n441:             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==\n442:             keccak256(abi.encodePacked(\"\")) ||\n443:             keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==\n444:             keccak256(abi.encodePacked(\"\"))\n445:         ) {\n446:             externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME;\n447:             externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL;\n448:         }\n449:         _mint( // <= FOUND\n450:             curvesTokenSubject,\n451:             externalCurvesTokens[curvesTokenSubject].name,\n452:             externalCurvesTokens[curvesTokenSubject].symbol\n453:         );\n454:     }\n\n```\n",
          "loc": [
            "[439](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L439-L449)"
          ]
        },
        {
          "content": "```solidity\n456:     function _mint( // <= FOUND\n457:         address curvesTokenSubject,\n458:         string memory name,\n459:         string memory symbol\n460:     ) internal onlyTokenSubject(curvesTokenSubject) {\n461:         if (externalCurvesTokens[curvesTokenSubject].token != address(0)) revert ERC20TokenAlreadyMinted();\n462:         _deployERC20(curvesTokenSubject, name, symbol);\n463:     }\n\n```\n",
          "loc": [
            "[456](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L456-L456)"
          ]
        },
        {
          "content": "```solidity\n12:     function mint(address to, uint256 amount) public onlyOwner { // <= FOUND\n13:         _mint(to, amount); // <= FOUND\n14:     }\n\n```\n",
          "loc": [
            "[12](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L12-L13)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider using a format prettier or forge fmt",
      "description": "Some comments use // X and others //X Amend comments to use only use // X or //X consistently such style inconsistencies can be resolved by running the project through a format prettier or by using forge fmt.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n44: //@dev: this is the amount of tokens that are not locked in the contract. The locked tokens are in the ERC20 contract\n\n```\n",
          "loc": [
            "[44](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L44-L44)"
          ]
        },
        {
          "content": "```solidity\n102: //@dev: this may fail if the the list is long. Get first the list with getUserTokens to estimate and prepare the batch\n\n```\n",
          "loc": [
            "[102](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L102-L102)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "package.json name variable should only consist of lowercase letters and underscores",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n1: {\n2:   \"name\": \"@curves/contracts\", // <= FOUND\n3:   \"private\": true,\n4:   \"packageManager\": \"yarn@4.0.0-rc.51\",\n5:   \"version\": \"0.0.0\",\n6:   \"scripts\": {\n7:     \"compile\": \"npx hardhat compile\",\n8:     \"deploy:local\": \"npx cross-env EXECUTE_PROGRAMMATICALLY=true yarn hardhat run scripts/deploy-local.ts --network localhost\",\n9:     \"dev\": \"npx hardhat node\",\n10:     \"entr-warning\": \"echo You need to install `entr` to run this command\",\n11:     \"generate:abi\": \"rm -fr ./contracts/abi/* && cp -R ./artifacts/contracts/**/*.json ./contracts/abi/ && cp -R ./artifacts/contracts/**/**/*.json ./contracts/abi/ && rm ./contracts/abi/*dbg*\",\n12:     \"generate:typechain\": \"rm -rf ./contracts/types && typechain --target ethers-v5 --out-dir ./contracts/types ./contracts/abi/**/*.json\",\n13:     \"lint\": \"npx eslint . --ext .js,.ts\",\n14:     \"lint:fix\": \"npx eslint . --ext .js,.ts,.json --fix\",\n15:     \"test\": \"npx hardhat test\",\n16:     \"test:coverage\": \"npx hardhat coverage\",\n17:     \"test:watch\": \"yarn entr-warning && find contracts test -iname '*.sol' -o -iname '*.spec.*' -o -iname '*.test.*' | entr -cnr npx hardhat test\",\n18:     \"tsc:watch\": \"tsc --watch\"\n19:   },\n20:   \"devDependencies\": {\n21:     \"@ethereumjs/vm\": \"^5.5.2\",\n22:     \"@ethersproject/abi\": \"^5.4.3\",\n23:     \"@ethersproject/bytes\": \"^5.4.3\",\n24:     \"@ethersproject/contracts\": \"^5.4.3\",\n25:     \"@ethersproject/providers\": \"^5.4.3\",\n26:     \"@ethersproject/strings\": \"^5.4.3\",\n27:     \"@ethersproject/units\": \"^5.4.3\",\n28:     \"@nomiclabs/hardhat-ethers\": \"^2.0.2\",\n29:     \"@nomiclabs/hardhat-etherscan\": \"3.1.7\",\n30:     \"@nomiclabs/hardhat-waffle\": \"2.0.1\",\n31:     \"@openzeppelin/contracts\": \"4.9.3\",\n32:     \"@openzeppelin/hardhat-upgrades\": \"^1.7.0-rc.0\",\n33:     \"@typechain/ethers-v5\": \"9.0.0\",\n34:     \"@typechain/hardhat\": \"4.0.0\",\n35:     \"@types/chai\": \"4.3.0\",\n36:     \"@types/mocha\": \"9.0.0\",\n37:     \"@types/node\": \"17.0.8\",\n38:     \"@typescript-eslint/eslint-plugin\": \"^5.33.1\",\n39:     \"@typescript-eslint/parser\": \"^5.33.1\",\n40:     \"chai\": \"^4.3.6\",\n41:     \"chai-bignumber\": \"^3.0.0\",\n42:     \"dotenv\": \"12.0.3\",\n43:     \"eslint\": \"^8.13.0\",\n44:     \"eslint-config-prettier\": \"^8.5.0\",\n45:     \"eslint-config-standard\": \"^17.0.0\",\n46:     \"eslint-import-resolver-typescript\": \"^3.5.0\",\n47:     \"eslint-plugin-import\": \"^2.26.0\",\n48:     \"eslint-plugin-node\": \"^11.1.0\",\n49:     \"eslint-plugin-prettier\": \"^5.0.0\",\n50:     \"eslint-plugin-promise\": \"^6.0.0\",\n51:     \"eslint-plugin-simple-import-sort\": \"7.0.0\",\n\n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-01-curves/blob/main/package.json#L1-L2)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "package.json version should start at 0.1.0 or 1.0.0 not 0.0.1 or 0.0.0",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n1: {\n2:   \"name\": \"@curves/contracts\",\n3:   \"private\": true,\n4:   \"packageManager\": \"yarn@4.0.0-rc.51\",\n5:   \"version\": \"0.0.0\", // <= FOUND\n6:   \"scripts\": {\n7:     \"compile\": \"npx hardhat compile\",\n8:     \"deploy:local\": \"npx cross-env EXECUTE_PROGRAMMATICALLY=true yarn hardhat run scripts/deploy-local.ts --network localhost\",\n9:     \"dev\": \"npx hardhat node\",\n10:     \"entr-warning\": \"echo You need to install `entr` to run this command\",\n11:     \"generate:abi\": \"rm -fr ./contracts/abi/* && cp -R ./artifacts/contracts/**/*.json ./contracts/abi/ && cp -R ./artifacts/contracts/**/**/*.json ./contracts/abi/ && rm ./contracts/abi/*dbg*\",\n12:     \"generate:typechain\": \"rm -rf ./contracts/types && typechain --target ethers-v5 --out-dir ./contracts/types ./contracts/abi/**/*.json\",\n13:     \"lint\": \"npx eslint . --ext .js,.ts\",\n14:     \"lint:fix\": \"npx eslint . --ext .js,.ts,.json --fix\",\n15:     \"test\": \"npx hardhat test\",\n16:     \"test:coverage\": \"npx hardhat coverage\",\n17:     \"test:watch\": \"yarn entr-warning && find contracts test -iname '*.sol' -o -iname '*.spec.*' -o -iname '*.test.*' | entr -cnr npx hardhat test\",\n18:     \"tsc:watch\": \"tsc --watch\"\n19:   },\n20:   \"devDependencies\": {\n21:     \"@ethereumjs/vm\": \"^5.5.2\",\n22:     \"@ethersproject/abi\": \"^5.4.3\",\n23:     \"@ethersproject/bytes\": \"^5.4.3\",\n24:     \"@ethersproject/contracts\": \"^5.4.3\",\n25:     \"@ethersproject/providers\": \"^5.4.3\",\n26:     \"@ethersproject/strings\": \"^5.4.3\",\n27:     \"@ethersproject/units\": \"^5.4.3\",\n28:     \"@nomiclabs/hardhat-ethers\": \"^2.0.2\",\n29:     \"@nomiclabs/hardhat-etherscan\": \"3.1.7\",\n30:     \"@nomiclabs/hardhat-waffle\": \"2.0.1\",\n31:     \"@openzeppelin/contracts\": \"4.9.3\",\n32:     \"@openzeppelin/hardhat-upgrades\": \"^1.7.0-rc.0\",\n33:     \"@typechain/ethers-v5\": \"9.0.0\",\n34:     \"@typechain/hardhat\": \"4.0.0\",\n35:     \"@types/chai\": \"4.3.0\",\n36:     \"@types/mocha\": \"9.0.0\",\n37:     \"@types/node\": \"17.0.8\",\n38:     \"@typescript-eslint/eslint-plugin\": \"^5.33.1\",\n39:     \"@typescript-eslint/parser\": \"^5.33.1\",\n40:     \"chai\": \"^4.3.6\",\n41:     \"chai-bignumber\": \"^3.0.0\",\n42:     \"dotenv\": \"12.0.3\",\n43:     \"eslint\": \"^8.13.0\",\n44:     \"eslint-config-prettier\": \"^8.5.0\",\n45:     \"eslint-config-standard\": \"^17.0.0\",\n46:     \"eslint-import-resolver-typescript\": \"^3.5.0\",\n47:     \"eslint-plugin-import\": \"^2.26.0\",\n48:     \"eslint-plugin-node\": \"^11.1.0\",\n49:     \"eslint-plugin-prettier\": \"^5.0.0\",\n50:     \"eslint-plugin-promise\": \"^6.0.0\",\n51:     \"eslint-plugin-simple-import-sort\": \"7.0.0\",\n52:     \"eslint-plugin-sort-keys-fix\": \"1.1.2\",\n53:     \"eslint-plugin-typescript-sort-keys\": \"2.1.0\",\n54:     \"ethereum-waffle\": \"^3.4.4\",\n\n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-01-curves/blob/main/package.json#L1-L5)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Avoid declaring variables with the names of defined functions within the project",
      "description": "Having such variables can create confusion in both developers and in users of the project. Consider renaming these variables to improve code clarity.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n90:         uint256 totalSupply_ = totalSupply(token); // <= FOUND\n\n```\n",
          "loc": [
            "[90](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L90-L90)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "All verbatim blocks are considered identical by deduplicator and can incorrectly be unified",
      "description": "The Solidity Team reported a bug on October 24, 2023, affecting Yul code using the verbatim builtin, specifically in the Block Deduplicator optimizer step. This bug, present since Solidity version 0.8.5, caused incorrect deduplication of verbatim assembly items surrounded by identical opcodes, considering them identical regardless of their data. The bug was confined to pure Yul compilation with optimization enabled and was unlikely to be exploited as an attack vector. The conditions triggering the bug were very specific, and its occurrence was deemed to have a low likelihood. The bug was rated with an overall low score due to these factors. ",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n2: pragma solidity 0.8.7; // <= FOUND\n\n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L2-L2)"
          ]
        },
        {
          "content": "```solidity\n2: pragma solidity ^0.8.7; // <= FOUND\n\n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L2-L2)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Public variable declarations should have NatSpec descriptions",
      "description": "Public variable declarations in smart contracts should ideally be accompanied by NatSpec comments to enhance code readability and provide clear documentation. NatSpec (Natural Language Specification) is a standard for writing comments in Ethereum smart contracts that can generate user-friendly documentation, improving the transparency of the contract's functionality. This is particularly crucial for public variables, as they are accessible externally, and understanding their role and impact is vital for both developers and users interacting with the contract",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n42:     address public curvesERC20Factory; // <= FOUND\n43:     FeeSplitter public feeRedistributor; // <= FOUND\n44:     string public constant DEFAULT_NAME = \"Curves\"; // <= FOUND\n\n```\n",
          "loc": [
            "[42](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L42-L44)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @author is missing from contract",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n41: contract Curves is CurvesErrors, Security \n\n```\n",
          "loc": [
            "[41](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L41-L41)"
          ]
        },
        {
          "content": "```solidity\n9: contract FeeSplitter is Security \n\n```\n",
          "loc": [
            "[9](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L9-L9)"
          ]
        },
        {
          "content": "```solidity\n4: contract Security \n\n```\n",
          "loc": [
            "[4](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n7: contract CurvesERC20 is ERC20, Ownable \n\n```\n",
          "loc": [
            "[7](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L7-L7)"
          ]
        },
        {
          "content": "```solidity\n6: contract CurvesERC20Factory \n\n```\n",
          "loc": [
            "[6](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20Factory.sol#L6-L6)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @notice is missing from contract",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n41: contract Curves is CurvesErrors, Security \n\n```\n",
          "loc": [
            "[41](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L41-L41)"
          ]
        },
        {
          "content": "```solidity\n9: contract FeeSplitter is Security \n\n```\n",
          "loc": [
            "[9](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L9-L9)"
          ]
        },
        {
          "content": "```solidity\n4: contract Security \n\n```\n",
          "loc": [
            "[4](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n7: contract CurvesERC20 is ERC20, Ownable \n\n```\n",
          "loc": [
            "[7](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L7-L7)"
          ]
        },
        {
          "content": "```solidity\n6: contract CurvesERC20Factory \n\n```\n",
          "loc": [
            "[6](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20Factory.sol#L6-L6)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @dev is missing from contract",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n41: contract Curves is CurvesErrors, Security \n\n```\n",
          "loc": [
            "[41](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L41-L41)"
          ]
        },
        {
          "content": "```solidity\n9: contract FeeSplitter is Security \n\n```\n",
          "loc": [
            "[9](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L9-L9)"
          ]
        },
        {
          "content": "```solidity\n4: contract Security \n\n```\n",
          "loc": [
            "[4](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n7: contract CurvesERC20 is ERC20, Ownable \n\n```\n",
          "loc": [
            "[7](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L7-L7)"
          ]
        },
        {
          "content": "```solidity\n6: contract CurvesERC20Factory \n\n```\n",
          "loc": [
            "[6](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20Factory.sol#L6-L6)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @title is missing from contract",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n41: contract Curves is CurvesErrors, Security \n\n```\n",
          "loc": [
            "[41](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L41-L41)"
          ]
        },
        {
          "content": "```solidity\n9: contract FeeSplitter is Security \n\n```\n",
          "loc": [
            "[9](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L9-L9)"
          ]
        },
        {
          "content": "```solidity\n4: contract Security \n\n```\n",
          "loc": [
            "[4](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n7: contract CurvesERC20 is ERC20, Ownable \n\n```\n",
          "loc": [
            "[7](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L7-L7)"
          ]
        },
        {
          "content": "```solidity\n6: contract CurvesERC20Factory \n\n```\n",
          "loc": [
            "[6](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20Factory.sol#L6-L6)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @author is missing from interface",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n13: interface CurvesErrors \n\n```\n",
          "loc": [
            "[13](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L13-L13)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @title is missing from interface",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n13: interface CurvesErrors \n\n```\n",
          "loc": [
            "[13](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L13-L13)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @dev is missing from interface",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n13: interface CurvesErrors \n\n```\n",
          "loc": [
            "[13](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L13-L13)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @notice is missing from interface",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n13: interface CurvesErrors \n\n```\n",
          "loc": [
            "[13](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L13-L13)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Event declarations should have NatSpec descriptions",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n80:     event Trade( // <= FOUND\n81:         address trader,\n82:         address subject,\n83:         bool isBuy,\n84:         uint256 tokenAmount,\n\n```\n",
          "loc": [
            "[80](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L80-L80)"
          ]
        },
        {
          "content": "```solidity\n91: \n92:     event Transfer(address indexed curvesTokenSubject, address indexed from, address indexed to, uint256 value); // <= FOUND\n93:     event WhitelistUpdated(address indexed presale, bytes32 indexed root); // <= FOUND\n94:     event TokenDeployed(address indexed curvesTokenSubject, address indexed erc20token, string name, string symbol); // <= FOUND\n95: \n\n```\n",
          "loc": [
            "[91](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L91-L94)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Event declarations should have @dev NatSpec comments",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n80:     event Trade( // <= FOUND\n81:         address trader,\n82:         address subject,\n83:         bool isBuy,\n84:         uint256 tokenAmount,\n\n```\n",
          "loc": [
            "[80](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L80-L80)"
          ]
        },
        {
          "content": "```solidity\n91: \n92:     event Transfer(address indexed curvesTokenSubject, address indexed from, address indexed to, uint256 value); // <= FOUND\n93:     event WhitelistUpdated(address indexed presale, bytes32 indexed root); // <= FOUND\n94:     event TokenDeployed(address indexed curvesTokenSubject, address indexed erc20token, string name, string symbol); // <= FOUND\n95: \n\n```\n",
          "loc": [
            "[91](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L91-L94)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Event declarations should have @notice NatSpec comments",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n80:     event Trade( // <= FOUND\n81:         address trader,\n82:         address subject,\n83:         bool isBuy,\n84:         uint256 tokenAmount,\n\n```\n",
          "loc": [
            "[80](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L80-L80)"
          ]
        },
        {
          "content": "```solidity\n91: \n92:     event Transfer(address indexed curvesTokenSubject, address indexed from, address indexed to, uint256 value); // <= FOUND\n93:     event WhitelistUpdated(address indexed presale, bytes32 indexed root); // <= FOUND\n94:     event TokenDeployed(address indexed curvesTokenSubject, address indexed erc20token, string name, string symbol); // <= FOUND\n95: \n\n```\n",
          "loc": [
            "[91](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L91-L94)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Event declarations should have @params NatSpec comments",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n80:     event Trade( // <= FOUND\n81:         address trader,\n82:         address subject,\n83:         bool isBuy,\n84:         uint256 tokenAmount,\n\n```\n",
          "loc": [
            "[80](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L80-L80)"
          ]
        },
        {
          "content": "```solidity\n91: \n92:     event Transfer(address indexed curvesTokenSubject, address indexed from, address indexed to, uint256 value); // <= FOUND\n93:     event WhitelistUpdated(address indexed presale, bytes32 indexed root); // <= FOUND\n94:     event TokenDeployed(address indexed curvesTokenSubject, address indexed erc20token, string name, string symbol); // <= FOUND\n95: \n\n```\n",
          "loc": [
            "[91](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L91-L94)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @params comments are missing from modifier",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n103:     modifier onlyTokenSubject(address curvesTokenSubject) \n\n```\n",
          "loc": [
            "[103](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L103-L103)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @dev comments are missing from modifier",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n103:     modifier onlyTokenSubject(address curvesTokenSubject) \n\n```\n",
          "loc": [
            "[103](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L103-L103)"
          ]
        },
        {
          "content": "```solidity\n8:     modifier onlyOwner() \n\n```\n",
          "loc": [
            "[8](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L8-L8)"
          ]
        },
        {
          "content": "```solidity\n13:     modifier onlyManager() \n\n```\n",
          "loc": [
            "[13](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L13-L13)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @notice comments are missing from modifier",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n103:     modifier onlyTokenSubject(address curvesTokenSubject) \n\n```\n",
          "loc": [
            "[103](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L103-L103)"
          ]
        },
        {
          "content": "```solidity\n8:     modifier onlyOwner() \n\n```\n",
          "loc": [
            "[8](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L8-L8)"
          ]
        },
        {
          "content": "```solidity\n13:     modifier onlyManager() \n\n```\n",
          "loc": [
            "[13](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L13-L13)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @params comments are missing from struct",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n49:     struct ExternalTokenMeta {\n50:         string name;\n51:         string symbol;\n52:         address token;\n53:     }\n\n```\n",
          "loc": [
            "[49](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L49-L49)"
          ]
        },
        {
          "content": "```solidity\n55:     struct PresaleMeta {\n56:         uint256 startTime;\n57:         bytes32 merkleRoot;\n58:         uint256 maxBuy;\n59:     }\n\n```\n",
          "loc": [
            "[55](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L55-L55)"
          ]
        },
        {
          "content": "```solidity\n68:     struct FeesEconomics {\n69:         address protocolFeeDestination;\n70:         uint256 protocolFeePercent;\n71:         uint256 subjectFeePercent;\n72:         uint256 referralFeePercent;\n73:         uint256 holdersFeePercent;\n74:         uint256 maxFeePercent;\n75:     }\n\n```\n",
          "loc": [
            "[68](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L68-L68)"
          ]
        },
        {
          "content": "```solidity\n17:     struct TokenData {\n18:         uint256 cumulativeFeePerToken;\n19:         mapping(address => uint256) userFeeOffset;\n20:         mapping(address => uint256) unclaimedFees;\n21:     }\n\n```\n",
          "loc": [
            "[17](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L17-L17)"
          ]
        },
        {
          "content": "```solidity\n23:     struct UserClaimData {\n24:         uint256 claimableFees;\n25:         address token;\n26:     }\n\n```\n",
          "loc": [
            "[23](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L23-L23)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @dev comments are missing from struct",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n49:     struct ExternalTokenMeta {\n50:         string name;\n51:         string symbol;\n52:         address token;\n53:     }\n\n```\n",
          "loc": [
            "[49](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L49-L49)"
          ]
        },
        {
          "content": "```solidity\n55:     struct PresaleMeta {\n56:         uint256 startTime;\n57:         bytes32 merkleRoot;\n58:         uint256 maxBuy;\n59:     }\n\n```\n",
          "loc": [
            "[55](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L55-L55)"
          ]
        },
        {
          "content": "```solidity\n68:     struct FeesEconomics {\n69:         address protocolFeeDestination;\n70:         uint256 protocolFeePercent;\n71:         uint256 subjectFeePercent;\n72:         uint256 referralFeePercent;\n73:         uint256 holdersFeePercent;\n74:         uint256 maxFeePercent;\n75:     }\n\n```\n",
          "loc": [
            "[68](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L68-L68)"
          ]
        },
        {
          "content": "```solidity\n17:     struct TokenData {\n18:         uint256 cumulativeFeePerToken;\n19:         mapping(address => uint256) userFeeOffset;\n20:         mapping(address => uint256) unclaimedFees;\n21:     }\n\n```\n",
          "loc": [
            "[17](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L17-L17)"
          ]
        },
        {
          "content": "```solidity\n23:     struct UserClaimData {\n24:         uint256 claimableFees;\n25:         address token;\n26:     }\n\n```\n",
          "loc": [
            "[23](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L23-L23)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @notice comments are missing from struct",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n49:     struct ExternalTokenMeta {\n50:         string name;\n51:         string symbol;\n52:         address token;\n53:     }\n\n```\n",
          "loc": [
            "[49](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L49-L49)"
          ]
        },
        {
          "content": "```solidity\n55:     struct PresaleMeta {\n56:         uint256 startTime;\n57:         bytes32 merkleRoot;\n58:         uint256 maxBuy;\n59:     }\n\n```\n",
          "loc": [
            "[55](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L55-L55)"
          ]
        },
        {
          "content": "```solidity\n68:     struct FeesEconomics {\n69:         address protocolFeeDestination;\n70:         uint256 protocolFeePercent;\n71:         uint256 subjectFeePercent;\n72:         uint256 referralFeePercent;\n73:         uint256 holdersFeePercent;\n74:         uint256 maxFeePercent;\n75:     }\n\n```\n",
          "loc": [
            "[68](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L68-L68)"
          ]
        },
        {
          "content": "```solidity\n17:     struct TokenData {\n18:         uint256 cumulativeFeePerToken;\n19:         mapping(address => uint256) userFeeOffset;\n20:         mapping(address => uint256) unclaimedFees;\n21:     }\n\n```\n",
          "loc": [
            "[17](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L17-L17)"
          ]
        },
        {
          "content": "```solidity\n23:     struct UserClaimData {\n24:         uint256 claimableFees;\n25:         address token;\n26:     }\n\n```\n",
          "loc": [
            "[23](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L23-L23)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @params comments are missing from function",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner \n\n```\n",
          "loc": [
            "[113](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L113-L113)"
          ]
        },
        {
          "content": "```solidity\n117:     function setMaxFeePercent(uint256 maxFeePercent_) external onlyManager \n\n```\n",
          "loc": [
            "[117](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L117-L117)"
          ]
        },
        {
          "content": "```solidity\n128:     function setProtocolFeePercent(uint256 protocolFeePercent_, address protocolFeeDestination_) external onlyOwner \n\n```\n",
          "loc": [
            "[128](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L128-L128)"
          ]
        },
        {
          "content": "```solidity\n141:     function setExternalFeePercent(\n142:         uint256 subjectFeePercent_,\n143:         uint256 referralFeePercent_,\n144:         uint256 holdersFeePercent_\n145:     ) external onlyManager \n\n```\n",
          "loc": [
            "[141](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L141-L141)"
          ]
        },
        {
          "content": "```solidity\n155:     function setReferralFeeDestination(\n156:         address curvesTokenSubject,\n157:         address referralFeeDestination_\n158:     ) public onlyTokenSubject(curvesTokenSubject) \n\n```\n",
          "loc": [
            "[155](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L155-L155)"
          ]
        },
        {
          "content": "```solidity\n162:     function setERC20Factory(address factory_) external onlyOwner \n\n```\n",
          "loc": [
            "[162](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L162-L162)"
          ]
        },
        {
          "content": "```solidity\n166:     function getFees(\n167:         uint256 price\n168:     )\n169:         public\n170:         view\n171:         returns (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holdersFee, uint256 totalFee)\n172:     \n\n```\n",
          "loc": [
            "[166](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L166-L166)"
          ]
        },
        {
          "content": "```solidity\n180:     function getPrice(uint256 supply, uint256 amount) public pure returns (uint256) \n\n```\n",
          "loc": [
            "[180](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L180-L180)"
          ]
        },
        {
          "content": "```solidity\n189:     function getBuyPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) \n\n```\n",
          "loc": [
            "[189](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L189-L189)"
          ]
        },
        {
          "content": "```solidity\n193:     function getSellPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) \n\n```\n",
          "loc": [
            "[193](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L193-L193)"
          ]
        },
        {
          "content": "```solidity\n197:     function getBuyPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) \n\n```\n",
          "loc": [
            "[197](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L197-L197)"
          ]
        },
        {
          "content": "```solidity\n204:     function getSellPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) \n\n```\n",
          "loc": [
            "[204](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L204-L204)"
          ]
        },
        {
          "content": "```solidity\n211:     function buyCurvesToken(address curvesTokenSubject, uint256 amount) public payable \n\n```\n",
          "loc": [
            "[211](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L211-L211)"
          ]
        },
        {
          "content": "```solidity\n218:     function _transferFees(\n219:         address curvesTokenSubject,\n220:         bool isBuy,\n221:         uint256 price,\n222:         uint256 amount,\n223:         uint256 supply\n224:     ) internal \n\n```\n",
          "loc": [
            "[218](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L218-L218)"
          ]
        },
        {
          "content": "```solidity\n263:     function _buyCurvesToken(address curvesTokenSubject, uint256 amount) internal \n\n```\n",
          "loc": [
            "[263](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L263-L263)"
          ]
        },
        {
          "content": "```solidity\n282:     function sellCurvesToken(address curvesTokenSubject, uint256 amount) public \n\n```\n",
          "loc": [
            "[282](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L282-L282)"
          ]
        },
        {
          "content": "```solidity\n296:     function transferCurvesToken(address curvesTokenSubject, address to, uint256 amount) external \n\n```\n",
          "loc": [
            "[296](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L296-L296)"
          ]
        },
        {
          "content": "```solidity\n302:     function transferAllCurvesTokens(address to) external \n\n```\n",
          "loc": [
            "[302](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L302-L302)"
          ]
        },
        {
          "content": "```solidity\n313:     function _transfer(address curvesTokenSubject, address from, address to, uint256 amount) internal \n\n```\n",
          "loc": [
            "[313](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L313-L313)"
          ]
        },
        {
          "content": "```solidity\n328:     function _addOwnedCurvesTokenSubject(address owner_, address curvesTokenSubject) internal \n\n```\n",
          "loc": [
            "[328](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L328-L328)"
          ]
        },
        {
          "content": "```solidity\n338:     function _deployERC20(\n339:         address curvesTokenSubject,\n340:         string memory name,\n341:         string memory symbol\n342:     ) internal returns (address) \n\n```\n",
          "loc": [
            "[338](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L338-L338)"
          ]
        },
        {
          "content": "```solidity\n364:     function buyCurvesTokenWithName(\n365:         address curvesTokenSubject,\n366:         uint256 amount,\n367:         string memory name,\n368:         string memory symbol\n369:     ) public payable \n\n```\n",
          "loc": [
            "[364](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L364-L364)"
          ]
        },
        {
          "content": "```solidity\n377:     function buyCurvesTokenForPresale(\n378:         address curvesTokenSubject,\n379:         uint256 amount,\n380:         uint256 startTime,\n381:         bytes32 merkleRoot,\n382:         uint256 maxBuy\n383:     ) public payable onlyTokenSubject(curvesTokenSubject) \n\n```\n",
          "loc": [
            "[377](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L377-L377)"
          ]
        },
        {
          "content": "```solidity\n394:     function setWhitelist(bytes32 merkleRoot) external \n\n```\n",
          "loc": [
            "[394](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L394-L394)"
          ]
        },
        {
          "content": "```solidity\n404:     function buyCurvesTokenWhitelisted(\n405:         address curvesTokenSubject,\n406:         uint256 amount,\n407:         bytes32[] memory proof\n408:     ) public payable \n\n```\n",
          "loc": [
            "[404](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L404-L404)"
          ]
        },
        {
          "content": "```solidity\n422:     function verifyMerkle(address curvesTokenSubject, address caller, bytes32[] memory proof) public view \n\n```\n",
          "loc": [
            "[422](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L422-L422)"
          ]
        },
        {
          "content": "```solidity\n428:     function setNameAndSymbol(\n429:         address curvesTokenSubject,\n430:         string memory name,\n431:         string memory symbol\n432:     ) external onlyTokenSubject(curvesTokenSubject) \n\n```\n",
          "loc": [
            "[428](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L428-L428)"
          ]
        },
        {
          "content": "```solidity\n439:     function mint(address curvesTokenSubject) external onlyTokenSubject(curvesTokenSubject) \n\n```\n",
          "loc": [
            "[439](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L439-L439)"
          ]
        },
        {
          "content": "```solidity\n456:     function _mint(\n457:         address curvesTokenSubject,\n458:         string memory name,\n459:         string memory symbol\n460:     ) internal onlyTokenSubject(curvesTokenSubject) \n\n```\n",
          "loc": [
            "[456](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L456-L456)"
          ]
        },
        {
          "content": "```solidity\n465:     function withdraw(address curvesTokenSubject, uint256 amount) public \n\n```\n",
          "loc": [
            "[465](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L465-L465)"
          ]
        },
        {
          "content": "```solidity\n490:     function deposit(address curvesTokenSubject, uint256 amount) public \n\n```\n",
          "loc": [
            "[490](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L490-L490)"
          ]
        },
        {
          "content": "```solidity\n504:     function sellExternalCurvesToken(address curvesTokenSubject, uint256 amount) public \n\n```\n",
          "loc": [
            "[504](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L504-L504)"
          ]
        },
        {
          "content": "```solidity\n35:     function setCurves(Curves curves_) public \n\n```\n",
          "loc": [
            "[35](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L35-L35)"
          ]
        },
        {
          "content": "```solidity\n39:     function balanceOf(address token, address account) public view returns (uint256) \n\n```\n",
          "loc": [
            "[39](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L39-L39)"
          ]
        },
        {
          "content": "```solidity\n43:     function totalSupply(address token) public view returns (uint256) \n\n```\n",
          "loc": [
            "[43](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L43-L43)"
          ]
        },
        {
          "content": "```solidity\n48:     function getUserTokens(address user) public view returns (address[] memory) \n\n```\n",
          "loc": [
            "[48](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L48-L48)"
          ]
        },
        {
          "content": "```solidity\n52:     function getUserTokensAndClaimable(address user) public view returns (UserClaimData[] memory) \n\n```\n",
          "loc": [
            "[52](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L52-L52)"
          ]
        },
        {
          "content": "```solidity\n63:     function updateFeeCredit(address token, address account) internal \n\n```\n",
          "loc": [
            "[63](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L63-L63)"
          ]
        },
        {
          "content": "```solidity\n73:     function getClaimableFees(address token, address account) public view returns (uint256) \n\n```\n",
          "loc": [
            "[73](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L73-L73)"
          ]
        },
        {
          "content": "```solidity\n80:     function claimFees(address token) external \n\n```\n",
          "loc": [
            "[80](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L80-L80)"
          ]
        },
        {
          "content": "```solidity\n89:     function addFees(address token) public payable onlyManager \n\n```\n",
          "loc": [
            "[89](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L89-L89)"
          ]
        },
        {
          "content": "```solidity\n96:     function onBalanceChange(address token, address account) public onlyManager \n\n```\n",
          "loc": [
            "[96](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L96-L96)"
          ]
        },
        {
          "content": "```solidity\n103:     function batchClaiming(address[] calldata tokenList) external \n\n```\n",
          "loc": [
            "[103](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L103-L103)"
          ]
        },
        {
          "content": "```solidity\n23:     function setManager(address manager_, bool value) public onlyOwner \n\n```\n",
          "loc": [
            "[23](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L23-L23)"
          ]
        },
        {
          "content": "```solidity\n27:     function transferOwnership(address owner_) public onlyOwner \n\n```\n",
          "loc": [
            "[27](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L27-L27)"
          ]
        },
        {
          "content": "```solidity\n12:     function mint(address to, uint256 amount) public onlyOwner \n\n```\n",
          "loc": [
            "[12](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L12-L12)"
          ]
        },
        {
          "content": "```solidity\n16:     function burn(address from, uint256 amount) public onlyOwner \n\n```\n",
          "loc": [
            "[16](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L16-L16)"
          ]
        },
        {
          "content": "```solidity\n7:     function deploy(string memory name, string memory symbol, address owner) public returns (address) \n\n```\n",
          "loc": [
            "[7](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20Factory.sol#L7-L7)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @dev comments are missing from function",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner \n\n```\n",
          "loc": [
            "[113](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L113-L113)"
          ]
        },
        {
          "content": "```solidity\n117:     function setMaxFeePercent(uint256 maxFeePercent_) external onlyManager \n\n```\n",
          "loc": [
            "[117](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L117-L117)"
          ]
        },
        {
          "content": "```solidity\n128:     function setProtocolFeePercent(uint256 protocolFeePercent_, address protocolFeeDestination_) external onlyOwner \n\n```\n",
          "loc": [
            "[128](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L128-L128)"
          ]
        },
        {
          "content": "```solidity\n141:     function setExternalFeePercent(\n142:         uint256 subjectFeePercent_,\n143:         uint256 referralFeePercent_,\n144:         uint256 holdersFeePercent_\n145:     ) external onlyManager \n\n```\n",
          "loc": [
            "[141](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L141-L141)"
          ]
        },
        {
          "content": "```solidity\n155:     function setReferralFeeDestination(\n156:         address curvesTokenSubject,\n157:         address referralFeeDestination_\n158:     ) public onlyTokenSubject(curvesTokenSubject) \n\n```\n",
          "loc": [
            "[155](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L155-L155)"
          ]
        },
        {
          "content": "```solidity\n162:     function setERC20Factory(address factory_) external onlyOwner \n\n```\n",
          "loc": [
            "[162](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L162-L162)"
          ]
        },
        {
          "content": "```solidity\n166:     function getFees(\n167:         uint256 price\n168:     )\n169:         public\n170:         view\n171:         returns (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holdersFee, uint256 totalFee)\n172:     \n\n```\n",
          "loc": [
            "[166](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L166-L166)"
          ]
        },
        {
          "content": "```solidity\n180:     function getPrice(uint256 supply, uint256 amount) public pure returns (uint256) \n\n```\n",
          "loc": [
            "[180](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L180-L180)"
          ]
        },
        {
          "content": "```solidity\n189:     function getBuyPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) \n\n```\n",
          "loc": [
            "[189](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L189-L189)"
          ]
        },
        {
          "content": "```solidity\n193:     function getSellPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) \n\n```\n",
          "loc": [
            "[193](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L193-L193)"
          ]
        },
        {
          "content": "```solidity\n197:     function getBuyPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) \n\n```\n",
          "loc": [
            "[197](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L197-L197)"
          ]
        },
        {
          "content": "```solidity\n204:     function getSellPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) \n\n```\n",
          "loc": [
            "[204](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L204-L204)"
          ]
        },
        {
          "content": "```solidity\n211:     function buyCurvesToken(address curvesTokenSubject, uint256 amount) public payable \n\n```\n",
          "loc": [
            "[211](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L211-L211)"
          ]
        },
        {
          "content": "```solidity\n218:     function _transferFees(\n219:         address curvesTokenSubject,\n220:         bool isBuy,\n221:         uint256 price,\n222:         uint256 amount,\n223:         uint256 supply\n224:     ) internal \n\n```\n",
          "loc": [
            "[218](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L218-L218)"
          ]
        },
        {
          "content": "```solidity\n263:     function _buyCurvesToken(address curvesTokenSubject, uint256 amount) internal \n\n```\n",
          "loc": [
            "[263](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L263-L263)"
          ]
        },
        {
          "content": "```solidity\n282:     function sellCurvesToken(address curvesTokenSubject, uint256 amount) public \n\n```\n",
          "loc": [
            "[282](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L282-L282)"
          ]
        },
        {
          "content": "```solidity\n296:     function transferCurvesToken(address curvesTokenSubject, address to, uint256 amount) external \n\n```\n",
          "loc": [
            "[296](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L296-L296)"
          ]
        },
        {
          "content": "```solidity\n302:     function transferAllCurvesTokens(address to) external \n\n```\n",
          "loc": [
            "[302](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L302-L302)"
          ]
        },
        {
          "content": "```solidity\n313:     function _transfer(address curvesTokenSubject, address from, address to, uint256 amount) internal \n\n```\n",
          "loc": [
            "[313](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L313-L313)"
          ]
        },
        {
          "content": "```solidity\n328:     function _addOwnedCurvesTokenSubject(address owner_, address curvesTokenSubject) internal \n\n```\n",
          "loc": [
            "[328](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L328-L328)"
          ]
        },
        {
          "content": "```solidity\n338:     function _deployERC20(\n339:         address curvesTokenSubject,\n340:         string memory name,\n341:         string memory symbol\n342:     ) internal returns (address) \n\n```\n",
          "loc": [
            "[338](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L338-L338)"
          ]
        },
        {
          "content": "```solidity\n364:     function buyCurvesTokenWithName(\n365:         address curvesTokenSubject,\n366:         uint256 amount,\n367:         string memory name,\n368:         string memory symbol\n369:     ) public payable \n\n```\n",
          "loc": [
            "[364](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L364-L364)"
          ]
        },
        {
          "content": "```solidity\n377:     function buyCurvesTokenForPresale(\n378:         address curvesTokenSubject,\n379:         uint256 amount,\n380:         uint256 startTime,\n381:         bytes32 merkleRoot,\n382:         uint256 maxBuy\n383:     ) public payable onlyTokenSubject(curvesTokenSubject) \n\n```\n",
          "loc": [
            "[377](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L377-L377)"
          ]
        },
        {
          "content": "```solidity\n394:     function setWhitelist(bytes32 merkleRoot) external \n\n```\n",
          "loc": [
            "[394](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L394-L394)"
          ]
        },
        {
          "content": "```solidity\n404:     function buyCurvesTokenWhitelisted(\n405:         address curvesTokenSubject,\n406:         uint256 amount,\n407:         bytes32[] memory proof\n408:     ) public payable \n\n```\n",
          "loc": [
            "[404](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L404-L404)"
          ]
        },
        {
          "content": "```solidity\n422:     function verifyMerkle(address curvesTokenSubject, address caller, bytes32[] memory proof) public view \n\n```\n",
          "loc": [
            "[422](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L422-L422)"
          ]
        },
        {
          "content": "```solidity\n428:     function setNameAndSymbol(\n429:         address curvesTokenSubject,\n430:         string memory name,\n431:         string memory symbol\n432:     ) external onlyTokenSubject(curvesTokenSubject) \n\n```\n",
          "loc": [
            "[428](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L428-L428)"
          ]
        },
        {
          "content": "```solidity\n439:     function mint(address curvesTokenSubject) external onlyTokenSubject(curvesTokenSubject) \n\n```\n",
          "loc": [
            "[439](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L439-L439)"
          ]
        },
        {
          "content": "```solidity\n456:     function _mint(\n457:         address curvesTokenSubject,\n458:         string memory name,\n459:         string memory symbol\n460:     ) internal onlyTokenSubject(curvesTokenSubject) \n\n```\n",
          "loc": [
            "[456](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L456-L456)"
          ]
        },
        {
          "content": "```solidity\n465:     function withdraw(address curvesTokenSubject, uint256 amount) public \n\n```\n",
          "loc": [
            "[465](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L465-L465)"
          ]
        },
        {
          "content": "```solidity\n490:     function deposit(address curvesTokenSubject, uint256 amount) public \n\n```\n",
          "loc": [
            "[490](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L490-L490)"
          ]
        },
        {
          "content": "```solidity\n504:     function sellExternalCurvesToken(address curvesTokenSubject, uint256 amount) public \n\n```\n",
          "loc": [
            "[504](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L504-L504)"
          ]
        },
        {
          "content": "```solidity\n35:     function setCurves(Curves curves_) public \n\n```\n",
          "loc": [
            "[35](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L35-L35)"
          ]
        },
        {
          "content": "```solidity\n39:     function balanceOf(address token, address account) public view returns (uint256) \n\n```\n",
          "loc": [
            "[39](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L39-L39)"
          ]
        },
        {
          "content": "```solidity\n43:     function totalSupply(address token) public view returns (uint256) \n\n```\n",
          "loc": [
            "[43](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L43-L43)"
          ]
        },
        {
          "content": "```solidity\n48:     function getUserTokens(address user) public view returns (address[] memory) \n\n```\n",
          "loc": [
            "[48](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L48-L48)"
          ]
        },
        {
          "content": "```solidity\n52:     function getUserTokensAndClaimable(address user) public view returns (UserClaimData[] memory) \n\n```\n",
          "loc": [
            "[52](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L52-L52)"
          ]
        },
        {
          "content": "```solidity\n63:     function updateFeeCredit(address token, address account) internal \n\n```\n",
          "loc": [
            "[63](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L63-L63)"
          ]
        },
        {
          "content": "```solidity\n73:     function getClaimableFees(address token, address account) public view returns (uint256) \n\n```\n",
          "loc": [
            "[73](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L73-L73)"
          ]
        },
        {
          "content": "```solidity\n80:     function claimFees(address token) external \n\n```\n",
          "loc": [
            "[80](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L80-L80)"
          ]
        },
        {
          "content": "```solidity\n89:     function addFees(address token) public payable onlyManager \n\n```\n",
          "loc": [
            "[89](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L89-L89)"
          ]
        },
        {
          "content": "```solidity\n96:     function onBalanceChange(address token, address account) public onlyManager \n\n```\n",
          "loc": [
            "[96](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L96-L96)"
          ]
        },
        {
          "content": "```solidity\n23:     function setManager(address manager_, bool value) public onlyOwner \n\n```\n",
          "loc": [
            "[23](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L23-L23)"
          ]
        },
        {
          "content": "```solidity\n27:     function transferOwnership(address owner_) public onlyOwner \n\n```\n",
          "loc": [
            "[27](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L27-L27)"
          ]
        },
        {
          "content": "```solidity\n12:     function mint(address to, uint256 amount) public onlyOwner \n\n```\n",
          "loc": [
            "[12](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L12-L12)"
          ]
        },
        {
          "content": "```solidity\n16:     function burn(address from, uint256 amount) public onlyOwner \n\n```\n",
          "loc": [
            "[16](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L16-L16)"
          ]
        },
        {
          "content": "```solidity\n7:     function deploy(string memory name, string memory symbol, address owner) public returns (address) \n\n```\n",
          "loc": [
            "[7](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20Factory.sol#L7-L7)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @notice comments are missing from function",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner \n\n```\n",
          "loc": [
            "[113](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L113-L113)"
          ]
        },
        {
          "content": "```solidity\n117:     function setMaxFeePercent(uint256 maxFeePercent_) external onlyManager \n\n```\n",
          "loc": [
            "[117](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L117-L117)"
          ]
        },
        {
          "content": "```solidity\n128:     function setProtocolFeePercent(uint256 protocolFeePercent_, address protocolFeeDestination_) external onlyOwner \n\n```\n",
          "loc": [
            "[128](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L128-L128)"
          ]
        },
        {
          "content": "```solidity\n141:     function setExternalFeePercent(\n142:         uint256 subjectFeePercent_,\n143:         uint256 referralFeePercent_,\n144:         uint256 holdersFeePercent_\n145:     ) external onlyManager \n\n```\n",
          "loc": [
            "[141](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L141-L141)"
          ]
        },
        {
          "content": "```solidity\n155:     function setReferralFeeDestination(\n156:         address curvesTokenSubject,\n157:         address referralFeeDestination_\n158:     ) public onlyTokenSubject(curvesTokenSubject) \n\n```\n",
          "loc": [
            "[155](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L155-L155)"
          ]
        },
        {
          "content": "```solidity\n162:     function setERC20Factory(address factory_) external onlyOwner \n\n```\n",
          "loc": [
            "[162](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L162-L162)"
          ]
        },
        {
          "content": "```solidity\n166:     function getFees(\n167:         uint256 price\n168:     )\n169:         public\n170:         view\n171:         returns (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holdersFee, uint256 totalFee)\n172:     \n\n```\n",
          "loc": [
            "[166](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L166-L166)"
          ]
        },
        {
          "content": "```solidity\n180:     function getPrice(uint256 supply, uint256 amount) public pure returns (uint256) \n\n```\n",
          "loc": [
            "[180](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L180-L180)"
          ]
        },
        {
          "content": "```solidity\n189:     function getBuyPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) \n\n```\n",
          "loc": [
            "[189](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L189-L189)"
          ]
        },
        {
          "content": "```solidity\n193:     function getSellPrice(address curvesTokenSubject, uint256 amount) public view returns (uint256) \n\n```\n",
          "loc": [
            "[193](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L193-L193)"
          ]
        },
        {
          "content": "```solidity\n197:     function getBuyPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) \n\n```\n",
          "loc": [
            "[197](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L197-L197)"
          ]
        },
        {
          "content": "```solidity\n204:     function getSellPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) \n\n```\n",
          "loc": [
            "[204](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L204-L204)"
          ]
        },
        {
          "content": "```solidity\n211:     function buyCurvesToken(address curvesTokenSubject, uint256 amount) public payable \n\n```\n",
          "loc": [
            "[211](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L211-L211)"
          ]
        },
        {
          "content": "```solidity\n218:     function _transferFees(\n219:         address curvesTokenSubject,\n220:         bool isBuy,\n221:         uint256 price,\n222:         uint256 amount,\n223:         uint256 supply\n224:     ) internal \n\n```\n",
          "loc": [
            "[218](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L218-L218)"
          ]
        },
        {
          "content": "```solidity\n263:     function _buyCurvesToken(address curvesTokenSubject, uint256 amount) internal \n\n```\n",
          "loc": [
            "[263](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L263-L263)"
          ]
        },
        {
          "content": "```solidity\n282:     function sellCurvesToken(address curvesTokenSubject, uint256 amount) public \n\n```\n",
          "loc": [
            "[282](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L282-L282)"
          ]
        },
        {
          "content": "```solidity\n296:     function transferCurvesToken(address curvesTokenSubject, address to, uint256 amount) external \n\n```\n",
          "loc": [
            "[296](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L296-L296)"
          ]
        },
        {
          "content": "```solidity\n302:     function transferAllCurvesTokens(address to) external \n\n```\n",
          "loc": [
            "[302](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L302-L302)"
          ]
        },
        {
          "content": "```solidity\n313:     function _transfer(address curvesTokenSubject, address from, address to, uint256 amount) internal \n\n```\n",
          "loc": [
            "[313](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L313-L313)"
          ]
        },
        {
          "content": "```solidity\n328:     function _addOwnedCurvesTokenSubject(address owner_, address curvesTokenSubject) internal \n\n```\n",
          "loc": [
            "[328](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L328-L328)"
          ]
        },
        {
          "content": "```solidity\n338:     function _deployERC20(\n339:         address curvesTokenSubject,\n340:         string memory name,\n341:         string memory symbol\n342:     ) internal returns (address) \n\n```\n",
          "loc": [
            "[338](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L338-L338)"
          ]
        },
        {
          "content": "```solidity\n364:     function buyCurvesTokenWithName(\n365:         address curvesTokenSubject,\n366:         uint256 amount,\n367:         string memory name,\n368:         string memory symbol\n369:     ) public payable \n\n```\n",
          "loc": [
            "[364](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L364-L364)"
          ]
        },
        {
          "content": "```solidity\n377:     function buyCurvesTokenForPresale(\n378:         address curvesTokenSubject,\n379:         uint256 amount,\n380:         uint256 startTime,\n381:         bytes32 merkleRoot,\n382:         uint256 maxBuy\n383:     ) public payable onlyTokenSubject(curvesTokenSubject) \n\n```\n",
          "loc": [
            "[377](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L377-L377)"
          ]
        },
        {
          "content": "```solidity\n394:     function setWhitelist(bytes32 merkleRoot) external \n\n```\n",
          "loc": [
            "[394](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L394-L394)"
          ]
        },
        {
          "content": "```solidity\n404:     function buyCurvesTokenWhitelisted(\n405:         address curvesTokenSubject,\n406:         uint256 amount,\n407:         bytes32[] memory proof\n408:     ) public payable \n\n```\n",
          "loc": [
            "[404](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L404-L404)"
          ]
        },
        {
          "content": "```solidity\n422:     function verifyMerkle(address curvesTokenSubject, address caller, bytes32[] memory proof) public view \n\n```\n",
          "loc": [
            "[422](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L422-L422)"
          ]
        },
        {
          "content": "```solidity\n428:     function setNameAndSymbol(\n429:         address curvesTokenSubject,\n430:         string memory name,\n431:         string memory symbol\n432:     ) external onlyTokenSubject(curvesTokenSubject) \n\n```\n",
          "loc": [
            "[428](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L428-L428)"
          ]
        },
        {
          "content": "```solidity\n439:     function mint(address curvesTokenSubject) external onlyTokenSubject(curvesTokenSubject) \n\n```\n",
          "loc": [
            "[439](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L439-L439)"
          ]
        },
        {
          "content": "```solidity\n456:     function _mint(\n457:         address curvesTokenSubject,\n458:         string memory name,\n459:         string memory symbol\n460:     ) internal onlyTokenSubject(curvesTokenSubject) \n\n```\n",
          "loc": [
            "[456](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L456-L456)"
          ]
        },
        {
          "content": "```solidity\n465:     function withdraw(address curvesTokenSubject, uint256 amount) public \n\n```\n",
          "loc": [
            "[465](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L465-L465)"
          ]
        },
        {
          "content": "```solidity\n490:     function deposit(address curvesTokenSubject, uint256 amount) public \n\n```\n",
          "loc": [
            "[490](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L490-L490)"
          ]
        },
        {
          "content": "```solidity\n504:     function sellExternalCurvesToken(address curvesTokenSubject, uint256 amount) public \n\n```\n",
          "loc": [
            "[504](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L504-L504)"
          ]
        },
        {
          "content": "```solidity\n35:     function setCurves(Curves curves_) public \n\n```\n",
          "loc": [
            "[35](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L35-L35)"
          ]
        },
        {
          "content": "```solidity\n39:     function balanceOf(address token, address account) public view returns (uint256) \n\n```\n",
          "loc": [
            "[39](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L39-L39)"
          ]
        },
        {
          "content": "```solidity\n43:     function totalSupply(address token) public view returns (uint256) \n\n```\n",
          "loc": [
            "[43](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L43-L43)"
          ]
        },
        {
          "content": "```solidity\n48:     function getUserTokens(address user) public view returns (address[] memory) \n\n```\n",
          "loc": [
            "[48](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L48-L48)"
          ]
        },
        {
          "content": "```solidity\n52:     function getUserTokensAndClaimable(address user) public view returns (UserClaimData[] memory) \n\n```\n",
          "loc": [
            "[52](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L52-L52)"
          ]
        },
        {
          "content": "```solidity\n63:     function updateFeeCredit(address token, address account) internal \n\n```\n",
          "loc": [
            "[63](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L63-L63)"
          ]
        },
        {
          "content": "```solidity\n73:     function getClaimableFees(address token, address account) public view returns (uint256) \n\n```\n",
          "loc": [
            "[73](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L73-L73)"
          ]
        },
        {
          "content": "```solidity\n80:     function claimFees(address token) external \n\n```\n",
          "loc": [
            "[80](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L80-L80)"
          ]
        },
        {
          "content": "```solidity\n89:     function addFees(address token) public payable onlyManager \n\n```\n",
          "loc": [
            "[89](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L89-L89)"
          ]
        },
        {
          "content": "```solidity\n96:     function onBalanceChange(address token, address account) public onlyManager \n\n```\n",
          "loc": [
            "[96](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L96-L96)"
          ]
        },
        {
          "content": "```solidity\n103:     function batchClaiming(address[] calldata tokenList) external \n\n```\n",
          "loc": [
            "[103](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L103-L103)"
          ]
        },
        {
          "content": "```solidity\n23:     function setManager(address manager_, bool value) public onlyOwner \n\n```\n",
          "loc": [
            "[23](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L23-L23)"
          ]
        },
        {
          "content": "```solidity\n27:     function transferOwnership(address owner_) public onlyOwner \n\n```\n",
          "loc": [
            "[27](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L27-L27)"
          ]
        },
        {
          "content": "```solidity\n12:     function mint(address to, uint256 amount) public onlyOwner \n\n```\n",
          "loc": [
            "[12](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L12-L12)"
          ]
        },
        {
          "content": "```solidity\n16:     function burn(address from, uint256 amount) public onlyOwner \n\n```\n",
          "loc": [
            "[16](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L16-L16)"
          ]
        },
        {
          "content": "```solidity\n7:     function deploy(string memory name, string memory symbol, address owner) public returns (address) \n\n```\n",
          "loc": [
            "[7](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20Factory.sol#L7-L7)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @dev comments are missing from constructor",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n108:     constructor(address curvesERC20Factory_, address feeRedistributor_) Security() \n\n```\n",
          "loc": [
            "[108](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L108-L108)"
          ]
        },
        {
          "content": "```solidity\n33:     constructor() Security() \n\n```\n",
          "loc": [
            "[33](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L33-L33)"
          ]
        },
        {
          "content": "```solidity\n18:     constructor() \n\n```\n",
          "loc": [
            "[18](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L18-L18)"
          ]
        },
        {
          "content": "```solidity\n8:     constructor(string memory name_, string memory symbol_, address owner) ERC20(name_, symbol_) \n\n```\n",
          "loc": [
            "[8](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L8-L8)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @notice comments are missing from constructor",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n108:     constructor(address curvesERC20Factory_, address feeRedistributor_) Security() \n\n```\n",
          "loc": [
            "[108](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L108-L108)"
          ]
        },
        {
          "content": "```solidity\n33:     constructor() Security() \n\n```\n",
          "loc": [
            "[33](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L33-L33)"
          ]
        },
        {
          "content": "```solidity\n18:     constructor() \n\n```\n",
          "loc": [
            "[18](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L18-L18)"
          ]
        },
        {
          "content": "```solidity\n8:     constructor(string memory name_, string memory symbol_, address owner) ERC20(name_, symbol_) \n\n```\n",
          "loc": [
            "[8](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L8-L8)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @params comments are missing from constructor",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n108:     constructor(address curvesERC20Factory_, address feeRedistributor_) Security() \n\n```\n",
          "loc": [
            "[108](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L108-L108)"
          ]
        },
        {
          "content": "```solidity\n8:     constructor(string memory name_, string memory symbol_, address owner) ERC20(name_, symbol_) \n\n```\n",
          "loc": [
            "[8](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L8-L8)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @notice comments are missing from receive function",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n119:     receive() external payable \n\n```\n",
          "loc": [
            "[119](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L119-L119)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @dev comments are missing from receive function",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n119:     receive() external payable \n\n```\n",
          "loc": [
            "[119](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L119-L119)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec comments are missing from scope blocks",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n226:         {\n227:             bool referralDefined = referralFeeDestination[curvesTokenSubject] != address(0);\n228:             {\n229:                 address firstDestination = isBuy ? feesEconomics.protocolFeeDestination : msg.sender;\n230:                 uint256 buyValue = referralDefined ? protocolFee : protocolFee + referralFee;\n231:                 uint256 sellValue = price - protocolFee - subjectFee - referralFee - holderFee;\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\");\n233:                 if (!success1) revert CannotSendFunds();\n234:             }\n235:             {\n236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}(\"\");\n237:                 if (!success2) revert CannotSendFunds();\n238:             }\n239:             {\n240:                 (bool success3, ) = referralDefined\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}(\"\")\n242:                     : (true, bytes(\"\"));\n243:                 if (!success3) revert CannotSendFunds();\n244:             }\n245: \n246:             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0)) {\n247:                 feeRedistributor.onBalanceChange(curvesTokenSubject, msg.sender);\n248:                 feeRedistributor.addFees{value: holderFee}(curvesTokenSubject);\n249:             }\n250:         }\n\n```\n",
          "loc": [
            "[226](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L226-L226)"
          ]
        },
        {
          "content": "```solidity\n228:            {\n229:                 address firstDestination = isBuy ? feesEconomics.protocolFeeDestination : msg.sender;\n230:                 uint256 buyValue = referralDefined ? protocolFee : protocolFee + referralFee;\n231:                 uint256 sellValue = price - protocolFee - subjectFee - referralFee - holderFee;\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\");\n233:                 if (!success1) revert CannotSendFunds();\n234:             }\n\n```\n",
          "loc": [
            "[228](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L228-L228)"
          ]
        },
        {
          "content": "```solidity\n235:             {\n236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}(\"\");\n237:                 if (!success2) revert CannotSendFunds();\n238:             }\n\n```\n",
          "loc": [
            "[235](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L235-L235)"
          ]
        },
        {
          "content": "```solidity\n239:             {\n240:                 (bool success3, ) = referralDefined\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}(\"\")\n242:                     : (true, bytes(\"\"));\n243:                 if (!success3) revert CannotSendFunds();\n244:             }\n\n```\n",
          "loc": [
            "[239](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L239-L239)"
          ]
        },
        {
          "content": "```solidity\n228:             {\n229:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}\n\n```\n",
          "loc": [
            "[228](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L228-L228)"
          ]
        },
        {
          "content": "```solidity\n239:             {\n240:                 (bool success3, ) = referralDefined\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}\n\n```\n",
          "loc": [
            "[239](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L239-L239)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "x + y is more efficient than using += for state variables (likewise for -=)",
      "description": "In instances found where either += or -= are used against state variables use x = x + y instead",
      "gasSavings": 5,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n338:     function _deployERC20(\n339:         address curvesTokenSubject,\n340:         string memory name,\n341:         string memory symbol\n342:     ) internal returns (address) {\n343:         \n344:         if (keccak256(bytes(symbol)) == keccak256(bytes(DEFAULT_SYMBOL))) {\n345:             _curvesTokenCounter += 1; // <= FOUND\n346:             name = string(abi.encodePacked(name, \" \", Strings.toString(_curvesTokenCounter)));\n347:             symbol = string(abi.encodePacked(symbol, Strings.toString(_curvesTokenCounter)));\n348:         }\n349: \n350:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();\n351: \n352:         address tokenContract = CurvesERC20Factory(curvesERC20Factory).deploy(name, symbol, address(this));\n353: \n354:         externalCurvesTokens[curvesTokenSubject].token = tokenContract;\n355:         externalCurvesTokens[curvesTokenSubject].name = name;\n356:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;\n357:         externalCurvesToSubject[tokenContract] = curvesTokenSubject;\n358:         symbolToSubject[symbol] = curvesTokenSubject;\n359: \n360:         emit TokenDeployed(curvesTokenSubject, tokenContract, name, symbol);\n361:         return address(tokenContract);\n362:     }\n\n```\n",
          "loc": [
            "[345](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L345-L345)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "There are comparisons to boolean literals (true and false), these can be simplified to save gas",
      "description": " In such instances you can simplify as follows: if (<x> == true) ==> if (<x>) | if (<x> == false) ==> if (!<x>) ",
      "gasSavings": 18,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n13:     modifier onlyManager() {\n14:         managers[msg.sender] == true; // <= FOUND\n15:         _;\n16:     }\n\n```\n",
          "loc": [
            "[14](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L14-L14)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Public functions not used internally can be marked as external to save gas",
      "description": "Public functions that aren't used internally in Solidity contracts should be made external to optimize gas usage and improve contract efficiency. External functions can only be called from outside the contract, and their arguments are directly read from the calldata, which is more gas-efficient than loading them into memory, as is the case for public functions. By using external visibility, developers can reduce gas consumption for external calls and ensure that the contract operates more cost-effectively for users. Moreover, setting the appropriate visibility level for functions also enhances code readability and maintainability, promoting a more secure and well-structured contract design.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n155:     function setReferralFeeDestination(\n156:         address curvesTokenSubject,\n157:         address referralFeeDestination_\n158:     ) public onlyTokenSubject(curvesTokenSubject) \n\n```\n",
          "loc": [
            "[155](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L155-L155)"
          ]
        },
        {
          "content": "```solidity\n197:     function getBuyPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) \n\n```\n",
          "loc": [
            "[197](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L197-L197)"
          ]
        },
        {
          "content": "```solidity\n204:     function getSellPriceAfterFee(address curvesTokenSubject, uint256 amount) public view returns (uint256) \n\n```\n",
          "loc": [
            "[204](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L204-L204)"
          ]
        },
        {
          "content": "```solidity\n364:     function buyCurvesTokenWithName(\n365:         address curvesTokenSubject,\n366:         uint256 amount,\n367:         string memory name,\n368:         string memory symbol\n369:     ) public payable \n\n```\n",
          "loc": [
            "[364](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L364-L364)"
          ]
        },
        {
          "content": "```solidity\n377:     function buyCurvesTokenForPresale(\n378:         address curvesTokenSubject,\n379:         uint256 amount,\n380:         uint256 startTime,\n381:         bytes32 merkleRoot,\n382:         uint256 maxBuy\n383:     ) public payable onlyTokenSubject(curvesTokenSubject) \n\n```\n",
          "loc": [
            "[377](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L377-L377)"
          ]
        },
        {
          "content": "```solidity\n404:     function buyCurvesTokenWhitelisted(\n405:         address curvesTokenSubject,\n406:         uint256 amount,\n407:         bytes32[] memory proof\n408:     ) public payable \n\n```\n",
          "loc": [
            "[404](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L404-L404)"
          ]
        },
        {
          "content": "```solidity\n465:     function withdraw(address curvesTokenSubject, uint256 amount) public \n\n```\n",
          "loc": [
            "[465](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L465-L465)"
          ]
        },
        {
          "content": "```solidity\n504:     function sellExternalCurvesToken(address curvesTokenSubject, uint256 amount) public \n\n```\n",
          "loc": [
            "[504](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L504-L504)"
          ]
        },
        {
          "content": "```solidity\n35:     function setCurves(Curves curves_) public \n\n```\n",
          "loc": [
            "[35](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L35-L35)"
          ]
        },
        {
          "content": "```solidity\n52:     function getUserTokensAndClaimable(address user) public view returns (UserClaimData[] memory) \n\n```\n",
          "loc": [
            "[52](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L52-L52)"
          ]
        },
        {
          "content": "```solidity\n89:     function addFees(address token) public payable onlyManager \n\n```\n",
          "loc": [
            "[89](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L89-L89)"
          ]
        },
        {
          "content": "```solidity\n23:     function setManager(address manager_, bool value) public onlyOwner \n\n```\n",
          "loc": [
            "[23](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L23-L23)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use != 0 instead of > 0",
      "description": "Replace spotted instances with != 0 for uints as this uses less gas",
      "gasSavings": 18,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n246: \n247:             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0)) { // <= FOUND\n\n```\n",
          "loc": [
            "[247](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L247-L247)"
          ]
        },
        {
          "content": "```solidity\n265:         if (!(supply > 0 || curvesTokenSubject == msg.sender)) revert UnauthorizedCurvesTokenSubject(); // <= FOUND\n\n```\n",
          "loc": [
            "[265](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L265-L265)"
          ]
        },
        {
          "content": "```solidity\n307:             if (amount > 0) { // <= FOUND\n\n```\n",
          "loc": [
            "[307](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L307-L307)"
          ]
        },
        {
          "content": "```solidity\n66:         if (balance > 0) { // <= FOUND\n\n```\n",
          "loc": [
            "[66](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L66-L66)"
          ]
        },
        {
          "content": "```solidity\n99:         if (balanceOf(token, account) > 0) userTokens[account].push(token); // <= FOUND\n\n```\n",
          "loc": [
            "[99](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L99-L99)"
          ]
        },
        {
          "content": "```solidity\n109:             if (claimable > 0) { // <= FOUND\n\n```\n",
          "loc": [
            "[109](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L109-L109)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Integer increments by one can be unchecked to save on gas fees",
      "description": "Using unchecked increments in Solidity can save on gas fees by bypassing built-in overflow checks, thus optimizing gas usage, but requires careful assessment of potential risks and edge cases to avoid unintended consequences.",
      "gasSavings": 480,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n302:     function transferAllCurvesTokens(address to) external {\n303:         if (to == address(this)) revert ContractCannotReceiveTransfer();\n304:         address[] storage subjects = ownedCurvesTokenSubjects[msg.sender];\n305:         for (uint256 i = 0; i < subjects.length; i++) { // <= FOUND\n306:             uint256 amount = curvesTokenBalance[subjects[i]][msg.sender];\n307:             if (amount > 0) {\n308:                 _transfer(subjects[i], msg.sender, to, amount);\n309:             }\n310:         }\n311:     }\n\n```\n",
          "loc": [
            "[305](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L305-L305)"
          ]
        },
        {
          "content": "```solidity\n328:     function _addOwnedCurvesTokenSubject(address owner_, address curvesTokenSubject) internal {\n329:         address[] storage subjects = ownedCurvesTokenSubjects[owner_];\n330:         for (uint256 i = 0; i < subjects.length; i++) { // <= FOUND\n331:             if (subjects[i] == curvesTokenSubject) {\n332:                 return;\n333:             }\n334:         }\n335:         subjects.push(curvesTokenSubject);\n336:     }\n\n```\n",
          "loc": [
            "[330](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L330-L330)"
          ]
        },
        {
          "content": "```solidity\n52:     function getUserTokensAndClaimable(address user) public view returns (UserClaimData[] memory) {\n53:         address[] memory tokens = getUserTokens(user);\n54:         UserClaimData[] memory result = new UserClaimData[](tokens.length);\n55:         for (uint256 i = 0; i < tokens.length; i++) { // <= FOUND\n56:             address token = tokens[i];\n57:             uint256 claimable = getClaimableFees(token, user);\n58:             result[i] = UserClaimData(claimable, token);\n59:         }\n60:         return result;\n61:     }\n\n```\n",
          "loc": [
            "[55](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L55-L55)"
          ]
        },
        {
          "content": "```solidity\n103:     function batchClaiming(address[] calldata tokenList) external {\n104:         uint256 totalClaimable = 0;\n105:         for (uint256 i = 0; i < tokenList.length; i++) { // <= FOUND\n106:             address token = tokenList[i];\n107:             updateFeeCredit(token, msg.sender);\n108:             uint256 claimable = getClaimableFees(token, msg.sender);\n109:             if (claimable > 0) {\n110:                 tokensData[token].unclaimedFees[msg.sender] = 0;\n111:                 totalClaimable += claimable;\n112:                 emit FeesClaimed(token, msg.sender, claimable);\n113:             }\n114:         }\n115:         if (totalClaimable == 0) revert NoFeesToClaim();\n116:         payable(msg.sender).transfer(totalClaimable);\n117:     }\n\n```\n",
          "loc": [
            "[105](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L105-L105)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use byte32 in place of string",
      "description": "For strings of 32 char strings and below you can use bytes32 instead as it's more gas efficient",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n44:     string public constant DEFAULT_NAME = \"Curves\"; // <= FOUND\n\n```\n",
          "loc": [
            "[44](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L44-L44)"
          ]
        },
        {
          "content": "```solidity\n45:     string public constant DEFAULT_SYMBOL = \"CURVES\"; // <= FOUND\n\n```\n",
          "loc": [
            "[45](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L45-L45)"
          ]
        },
        {
          "content": "```solidity\n346:             name = string(abi.encodePacked(name, \" \", Strings.toString(_curvesTokenCounter))); // <= FOUND\n\n```\n",
          "loc": [
            "[346](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L346-L346)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Default int values are manually reset",
      "description": "Using .delete is better than resetting a Solidity variable to its default value manually because it frees up storage space on the Ethereum blockchain, resulting in gas cost savings.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n84:         tokensData[token].unclaimedFees[msg.sender] = 0; // <= FOUND\n\n```\n",
          "loc": [
            "[84](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L84-L84)"
          ]
        },
        {
          "content": "```solidity\n110:                 tokensData[token].unclaimedFees[msg.sender] = 0; // <= FOUND\n\n```\n",
          "loc": [
            "[110](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L110-L110)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "<= or >= is more efficient than < or > ",
      "description": "Make such found comparisons to the <=/>= equivalent when comparing against integer literals",
      "gasSavings": 3,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n396:         if (supply > 1) revert CurveAlreadyExists(); // <= FOUND\n\n```\n",
          "loc": [
            "[396](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L396-L396)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Mappings used within a function more than once should be cached to save gas",
      "description": "Cache such mappings and perform operations on them, if operations include modifications to the mapping(s) then remember to equate the mapping to it's cached counterpart at the end",
      "gasSavings": 100,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n338:     function _deployERC20( // <= FOUND\n339:         address curvesTokenSubject,\n340:         string memory name,\n341:         string memory symbol\n342:     ) internal returns (address) {\n343:         \n344:         if (keccak256(bytes(symbol)) == keccak256(bytes(DEFAULT_SYMBOL))) {\n345:             _curvesTokenCounter += 1;\n346:             name = string(abi.encodePacked(name, \" \", Strings.toString(_curvesTokenCounter)));\n347:             symbol = string(abi.encodePacked(symbol, Strings.toString(_curvesTokenCounter)));\n348:         }\n349: \n350:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata(); // <= FOUND\n351: \n352:         address tokenContract = CurvesERC20Factory(curvesERC20Factory).deploy(name, symbol, address(this));\n353: \n354:         externalCurvesTokens[curvesTokenSubject].token = tokenContract;\n355:         externalCurvesTokens[curvesTokenSubject].name = name;\n356:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;\n357:         externalCurvesToSubject[tokenContract] = curvesTokenSubject;\n358:         symbolToSubject[symbol] = curvesTokenSubject; // <= FOUND\n359: \n360:         emit TokenDeployed(curvesTokenSubject, tokenContract, name, symbol);\n361:         return address(tokenContract);\n362:     }\n\n```\n",
          "loc": [
            "[338](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L338-L358)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use assembly to check for the zero address",
      "description": "\nUsing assembly for address comparisons in Solidity can save gas because it allows for more direct access to the Ethereum Virtual Machine (EVM), reducing the overhead of higher-level operations. Solidity's high-level abstraction simplifies coding but can introduce additional gas costs. Using assembly for simple operations like address comparisons can be more gas-efficient.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n128:     function setProtocolFeePercent(uint256 protocolFeePercent_, address protocolFeeDestination_) external onlyOwner {\n129:         if (\n130:             protocolFeePercent_ +\n131:                 feesEconomics.subjectFeePercent +\n132:                 feesEconomics.referralFeePercent +\n133:                 feesEconomics.holdersFeePercent >\n134:             feesEconomics.maxFeePercent ||\n135:             protocolFeeDestination_ == address(0) // <= FOUND\n136:         ) revert InvalidFeeDefinition();\n137:         feesEconomics.protocolFeePercent = protocolFeePercent_;\n138:         feesEconomics.protocolFeeDestination = protocolFeeDestination_;\n139:     }\n\n```\n",
          "loc": [
            "[128](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L128-L135)"
          ]
        },
        {
          "content": "```solidity\n218:     function _transferFees(\n219:         address curvesTokenSubject,\n220:         bool isBuy,\n221:         uint256 price,\n222:         uint256 amount,\n223:         uint256 supply\n224:     ) internal {\n225:         (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holderFee, ) = getFees(price);\n226:         {\n227:             bool referralDefined = referralFeeDestination[curvesTokenSubject] != address(0); // <= FOUND\n228:             {\n229:                 address firstDestination = isBuy ? feesEconomics.protocolFeeDestination : msg.sender;\n230:                 uint256 buyValue = referralDefined ? protocolFee : protocolFee + referralFee;\n231:                 uint256 sellValue = price - protocolFee - subjectFee - referralFee - holderFee;\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\");\n233:                 if (!success1) revert CannotSendFunds();\n234:             }\n235:             {\n236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}(\"\");\n237:                 if (!success2) revert CannotSendFunds();\n238:             }\n239:             {\n240:                 (bool success3, ) = referralDefined\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}(\"\")\n242:                     : (true, bytes(\"\"));\n243:                 if (!success3) revert CannotSendFunds();\n244:             }\n245: \n246:             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0)) { // <= FOUND\n247:                 feeRedistributor.onBalanceChange(curvesTokenSubject, msg.sender);\n248:                 feeRedistributor.addFees{value: holderFee}(curvesTokenSubject);\n249:             }\n250:         }\n251:         emit Trade(\n252:             msg.sender,\n253:             curvesTokenSubject,\n254:             isBuy,\n255:             amount,\n256:             price,\n257:             protocolFee,\n258:             subjectFee,\n259:             isBuy ? supply + amount : supply - amount\n260:         );\n261:     }\n\n```\n",
          "loc": [
            "[218](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L218-L246)"
          ]
        },
        {
          "content": "```solidity\n338:     function _deployERC20(\n339:         address curvesTokenSubject,\n340:         string memory name,\n341:         string memory symbol\n342:     ) internal returns (address) {\n343:         \n344:         if (keccak256(bytes(symbol)) == keccak256(bytes(DEFAULT_SYMBOL))) {\n345:             _curvesTokenCounter += 1;\n346:             name = string(abi.encodePacked(name, \" \", Strings.toString(_curvesTokenCounter)));\n347:             symbol = string(abi.encodePacked(symbol, Strings.toString(_curvesTokenCounter)));\n348:         }\n349: \n350:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata(); // <= FOUND\n351: \n352:         address tokenContract = CurvesERC20Factory(curvesERC20Factory).deploy(name, symbol, address(this));\n353: \n354:         externalCurvesTokens[curvesTokenSubject].token = tokenContract;\n355:         externalCurvesTokens[curvesTokenSubject].name = name;\n356:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;\n357:         externalCurvesToSubject[tokenContract] = curvesTokenSubject;\n358:         symbolToSubject[symbol] = curvesTokenSubject;\n359: \n360:         emit TokenDeployed(curvesTokenSubject, tokenContract, name, symbol);\n361:         return address(tokenContract);\n362:     }\n\n```\n",
          "loc": [
            "[338](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L338-L350)"
          ]
        },
        {
          "content": "```solidity\n428:     function setNameAndSymbol(\n429:         address curvesTokenSubject,\n430:         string memory name,\n431:         string memory symbol\n432:     ) external onlyTokenSubject(curvesTokenSubject) {\n433:         if (externalCurvesTokens[curvesTokenSubject].token != address(0)) revert ERC20TokenAlreadyMinted(); // <= FOUND\n434:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata(); // <= FOUND\n435:         externalCurvesTokens[curvesTokenSubject].name = name;\n436:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;\n437:     }\n\n```\n",
          "loc": [
            "[428](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L428-L434)"
          ]
        },
        {
          "content": "```solidity\n456:     function _mint(\n457:         address curvesTokenSubject,\n458:         string memory name,\n459:         string memory symbol\n460:     ) internal onlyTokenSubject(curvesTokenSubject) {\n461:         if (externalCurvesTokens[curvesTokenSubject].token != address(0)) revert ERC20TokenAlreadyMinted(); // <= FOUND\n462:         _deployERC20(curvesTokenSubject, name, symbol);\n463:     }\n\n```\n",
          "loc": [
            "[456](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L456-L461)"
          ]
        },
        {
          "content": "```solidity\n465:     function withdraw(address curvesTokenSubject, uint256 amount) public {\n466:         if (amount > curvesTokenBalance[curvesTokenSubject][msg.sender]) revert InsufficientBalance();\n467: \n468:         address externalToken = externalCurvesTokens[curvesTokenSubject].token;\n469:         if (externalToken == address(0)) { // <= FOUND\n470:             if (\n471:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].name)) ==\n472:                 keccak256(abi.encodePacked(\"\")) ||\n473:                 keccak256(abi.encodePacked(externalCurvesTokens[curvesTokenSubject].symbol)) ==\n474:                 keccak256(abi.encodePacked(\"\"))\n475:             ) {\n476:                 externalCurvesTokens[curvesTokenSubject].name = DEFAULT_NAME;\n477:                 externalCurvesTokens[curvesTokenSubject].symbol = DEFAULT_SYMBOL;\n478:             }\n479:             _deployERC20(\n480:                 curvesTokenSubject,\n481:                 externalCurvesTokens[curvesTokenSubject].name,\n482:                 externalCurvesTokens[curvesTokenSubject].symbol\n483:             );\n484:             externalToken = externalCurvesTokens[curvesTokenSubject].token;\n485:         }\n486:         _transfer(curvesTokenSubject, msg.sender, address(this), amount);\n487:         CurvesERC20(externalToken).mint(msg.sender, amount * 1 ether);\n488:     }\n\n```\n",
          "loc": [
            "[465](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L465-L469)"
          ]
        },
        {
          "content": "```solidity\n490:     function deposit(address curvesTokenSubject, uint256 amount) public {\n491:         if (amount % 1 ether != 0) revert NonIntegerDepositAmount();\n492: \n493:         address externalToken = externalCurvesTokens[curvesTokenSubject].token;\n494:         uint256 tokenAmount = amount / 1 ether;\n495: \n496:         if (externalToken == address(0)) revert TokenAbsentForCurvesTokenSubject(); // <= FOUND\n497:         if (amount > CurvesERC20(externalToken).balanceOf(msg.sender)) revert InsufficientBalance();\n498:         if (tokenAmount > curvesTokenBalance[curvesTokenSubject][address(this)]) revert InsufficientBalance();\n499: \n500:         CurvesERC20(externalToken).burn(msg.sender, amount);\n501:         _transfer(curvesTokenSubject, address(this), msg.sender, tokenAmount);\n502:     }\n\n```\n",
          "loc": [
            "[490](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L490-L496)"
          ]
        },
        {
          "content": "```solidity\n504:     function sellExternalCurvesToken(address curvesTokenSubject, uint256 amount) public {\n505:         if (externalCurvesTokens[curvesTokenSubject].token == address(0)) revert TokenAbsentForCurvesTokenSubject(); // <= FOUND\n506: \n507:         deposit(curvesTokenSubject, amount);\n508:         sellCurvesToken(curvesTokenSubject, amount / 1 ether);\n509:     }\n\n```\n",
          "loc": [
            "[504](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L504-L505)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Divisions which do not divide by -X cannot overflow or overflow so such operations can be unchecked to save gas",
      "description": "Make such found divisions are unchecked when ensured it is safe to do so",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n166:     function getFees(\n167:         uint256 price\n168:     )\n169:         public\n170:         view\n171:         returns (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holdersFee, uint256 totalFee)\n172:     {\n173:         protocolFee = (price * feesEconomics.protocolFeePercent) / 1 ether; // <= FOUND\n174:         subjectFee = (price * feesEconomics.subjectFeePercent) / 1 ether; // <= FOUND\n175:         referralFee = (price * feesEconomics.referralFeePercent) / 1 ether; // <= FOUND\n176:         holdersFee = (price * feesEconomics.holdersFeePercent) / 1 ether; // <= FOUND\n177:         totalFee = protocolFee + subjectFee + referralFee + holdersFee;\n178:     }\n\n```\n",
          "loc": [
            "[173](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L173-L176)"
          ]
        },
        {
          "content": "```solidity\n180:     function getPrice(uint256 supply, uint256 amount) public pure returns (uint256) {\n181:         uint256 sum1 = supply == 0 ? 0 : ((supply - 1) * (supply) * (2 * (supply - 1) + 1)) / 6; // <= FOUND\n182:         uint256 sum2 = supply == 0 && amount == 1\n183:             ? 0\n184:             : ((supply - 1 + amount) * (supply + amount) * (2 * (supply - 1 + amount) + 1)) / 6; // <= FOUND\n185:         uint256 summation = sum2 - sum1;\n186:         return (summation * 1 ether) / 16000; // <= FOUND\n187:     }\n\n```\n",
          "loc": [
            "[181](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L181-L186)"
          ]
        },
        {
          "content": "```solidity\n490:     function deposit(address curvesTokenSubject, uint256 amount) public {\n491:         if (amount % 1 ether != 0) revert NonIntegerDepositAmount();\n492: \n493:         address externalToken = externalCurvesTokens[curvesTokenSubject].token;\n494:         uint256 tokenAmount = amount / 1 ether; // <= FOUND\n495: \n496:         if (externalToken == address(0)) revert TokenAbsentForCurvesTokenSubject();\n497:         if (amount > CurvesERC20(externalToken).balanceOf(msg.sender)) revert InsufficientBalance();\n498:         if (tokenAmount > curvesTokenBalance[curvesTokenSubject][address(this)]) revert InsufficientBalance();\n499: \n500:         CurvesERC20(externalToken).burn(msg.sender, amount);\n501:         _transfer(curvesTokenSubject, address(this), msg.sender, tokenAmount);\n502:     }\n\n```\n",
          "loc": [
            "[494](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L494-L494)"
          ]
        },
        {
          "content": "```solidity\n504:     function sellExternalCurvesToken(address curvesTokenSubject, uint256 amount) public {\n505:         if (externalCurvesTokens[curvesTokenSubject].token == address(0)) revert TokenAbsentForCurvesTokenSubject();\n506: \n507:         deposit(curvesTokenSubject, amount);\n508:         sellCurvesToken(curvesTokenSubject, amount / 1 ether); // <= FOUND\n509:     }\n\n```\n",
          "loc": [
            "[508](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L508-L508)"
          ]
        },
        {
          "content": "```solidity\n63:     function updateFeeCredit(address token, address account) internal {\n64:         TokenData storage data = tokensData[token];\n65:         uint256 balance = balanceOf(token, account);\n66:         if (balance > 0) {\n67:             uint256 owed = (data.cumulativeFeePerToken - data.userFeeOffset[account]) * balance;\n68:             data.unclaimedFees[account] += owed / PRECISION; // <= FOUND\n69:             data.userFeeOffset[account] = data.cumulativeFeePerToken;\n70:         }\n71:     }\n\n```\n",
          "loc": [
            "[68](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L68-L68)"
          ]
        },
        {
          "content": "```solidity\n73:     function getClaimableFees(address token, address account) public view returns (uint256) {\n74:         TokenData storage data = tokensData[token];\n75:         uint256 balance = balanceOf(token, account);\n76:         uint256 owed = (data.cumulativeFeePerToken - data.userFeeOffset[account]) * balance;\n77:         return (owed / PRECISION) + data.unclaimedFees[account]; // <= FOUND\n78:     }\n\n```\n",
          "loc": [
            "[77](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L77-L77)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Struct variables can be packed into fewer storage slots",
      "description": "In Solidity, each storage slot has a size of 32 bytes. If a struct contains multiple uint values, it's efficient to pack these into as few storage slots as possible to optimize gas usage. The EVM (Ethereum Virtual Machine) charges gas for each storage operation, so minimizing the number of slots used can result in substantial gas savings. This can be achieved by ordering struct fields according to their size or by using smaller data types where possible. However, developers must balance these optimizations with the need for code clarity and the precision requirements of their application. Always ensure that data packing does not compromise the functionality or security of the contract.",
      "gasSavings": 5000,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n55:     struct PresaleMeta {\n56:         uint256 startTime; // <= FOUND\n57:         bytes32 merkleRoot;\n58:         uint256 maxBuy; // <= FOUND\n59:     }\n\n```\n",
          "loc": [
            "[55](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L55-L58)"
          ]
        },
        {
          "content": "```solidity\n68:     struct FeesEconomics {\n69:         address protocolFeeDestination;\n70:         uint256 protocolFeePercent; // <= FOUND\n71:         uint256 subjectFeePercent; // <= FOUND\n72:         uint256 referralFeePercent; // <= FOUND\n73:         uint256 holdersFeePercent; // <= FOUND\n74:         uint256 maxFeePercent; // <= FOUND\n75:     }\n\n```\n",
          "loc": [
            "[68](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L68-L74)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Consider activating via-ir for deploying",
      "description": "The Solidity compiler's Intermediate Representation (IR) based code generator, which can be activated using --via-ir on the command line or {\"viaIR\": true} in the options, serves a dual purpose. Firstly, it boosts the transparency and audibility of code generation, which enhances developers' comprehension and control over the contract's final bytecode. Secondly, it enables more sophisticated optimization passes that span multiple functions, thereby potentially leading to more efficient bytecode.\n\nIt's important to note that using the IR-based code generator may lengthen compile times due to the extra optimization steps. Therefore, it's advised to test your contract with and without this option enabled to measure the performance and gas cost implications. If the IR-based code generator significantly enhances your contract's performance or reduces gas costs, consider using the --via-ir flag during deployment. This way, you can leverage more advanced compiler optimizations without hindering your development workflow.",
      "gasSavings": 250,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n10: all\n\n```\n",
          "loc": [
            "[10](https://github.com/code-423n4/2024-01-curves/blob/main/package.json#L10-L10)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Add unchecked {} for subtractions where the operands cannot underflow",
      "description": "n Solidity 0.8.x and above, arithmetic operations like subtraction automatically check for underflows and overflows, and revert the transaction if such a condition is met. This built-in safety feature provides a layer of security against potential numerical errors. However, these automatic checks also come with additional gas costs.\n\nIn some situations, you may already have a guard condition, like a require() statement or an if statement, that ensures the safety of the arithmetic operation. In such cases, the automatic check becomes redundant and leads to unnecessary gas expenditure.\n\nFor example, you may have a function that subtracts a smaller number from a larger one, and you may have already verified that the smaller number is indeed smaller. In this case, you're already sure that the subtraction operation won't underflow, so there's no need for the automatic check.\n\nIn these situations, you can use the unchecked { } block around the subtraction operation to skip the automatic check. This will reduce gas costs and make your contract more efficient, without sacrificing security. However, it's critical to use unchecked { } only when you're absolutely sure that the operation is safe.",
      "gasSavings": 340,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n185:         uint256 summation = sum2 - sum1; // <= FOUND\n\n```\n",
          "loc": [
            "[185](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L185-L185)"
          ]
        },
        {
          "content": "```solidity\n231:                 uint256 sellValue = price - protocolFee - subjectFee - referralFee - holderFee; // <= FOUND\n\n```\n",
          "loc": [
            "[231](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L231-L231)"
          ]
        },
        {
          "content": "```solidity\n290:         curvesTokenSupply[curvesTokenSubject] = supply - amount; // <= FOUND\n\n```\n",
          "loc": [
            "[290](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L290-L290)"
          ]
        },
        {
          "content": "```solidity\n321: \n322:         curvesTokenBalance[curvesTokenSubject][from] = curvesTokenBalance[curvesTokenSubject][from] - amount; // <= FOUND\n\n```\n",
          "loc": [
            "[321](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L321-L322)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use bitmap to save gas",
      "description": "Bitmaps in Solidity are essentially a way of representing a set of boolean values within an integer type variable such as `uint256`. Each bit in the integer represents a true or false value (1 or 0), thus allowing efficient storage of multiple boolean values.\n\nBitmaps can save gas in the Ethereum network because they condense a lot of information into a small amount of storage. In Ethereum, storage is one of the most significant costs in terms of gas usage. By reducing the amount of storage space needed, you can potentially save on gas fees.\n\nHere's a quick comparison:\n\nIf you were to represent 256 different boolean values in the traditional way, you would have to declare 256 different `bool` variables. Given that each `bool` occupies a storage slot and each storage slot costs 20,000 gas to initialize, you would end up paying a considerable amount of gas.\n\nOn the other hand, if you were to use a bitmap, you could store these 256 boolean values within a single `uint256` variable. In other words, you'd only pay for a single storage slot, resulting in significant gas savings.\n\nHowever, it's important to note that while bitmaps can provide gas efficiencies, they do add complexity to the code, making it harder to read and maintain. Also, using bitmaps is efficient only when dealing with a large number of boolean variables that are frequently changed or accessed together. \n\nIn contrast, the straightforward counterpart to bitmaps would be using arrays or mappings to store boolean values, with each `bool` value occupying its own storage slot. This approach is simpler and more readable but could potentially be more expensive in terms of gas usage.",
      "gasSavings": 140,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n14:         managers[msg.sender] == true; // <= FOUND\n\n```\n",
          "loc": [
            "[14](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L14-L14)"
          ]
        },
        {
          "content": "```solidity\n20:         managers[msg.sender] = true; // <= FOUND\n\n```\n",
          "loc": [
            "[20](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L20-L20)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use assembly hashing",
      "description": "From a gas standpoint, the assembly version of the keccak256 hashing function can be more efficient than the high-level Solidity version. This is because Solidity has additional overhead when handling function calls and memory management, which can increase the gas cost.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n424:         \n425:         bytes32 leaf = keccak256(abi.encodePacked(caller)); // <= FOUND\n\n```\n",
          "loc": [
            "[424](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L424-L425)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Consider using OZ EnumerateSet in place of nested mappings",
      "description": "Nested mappings and multi-dimensional arrays in Solidity operate through a process of double hashing, wherein the original storage slot and the first key are concatenated and hashed, and then this hash is again concatenated with the second key and hashed. This process can be quite gas expensive due to the double-hashing operation and subsequent storage operation (sstore).\n\nA possible optimization involves manually concatenating the keys followed by a single hash operation and an sstore. However, this technique introduces the risk of storage collision, especially when there are other nested hash maps in the contract that use the same key types. Because Solidity is unaware of the number and structure of nested hash maps in a contract, it follows a conservative approach in computing the storage slot to avoid possible collisions.\n\nOpenZeppelin's EnumerableSet provides a potential solution to this problem. It creates a data structure that combines the benefits of set operations with the ability to enumerate stored elements, which is not natively available in Solidity. EnumerableSet handles the element uniqueness internally and can therefore provide a more gas-efficient and collision-resistant alternative to nested mappings or multi-dimensional arrays in certain scenarios. ",
      "gasSavings": 2000,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n66:     mapping(address => mapping(address => uint256)) public presalesBuys; // <= FOUND\n\n```\n",
          "loc": [
            "[66](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L66-L66)"
          ]
        },
        {
          "content": "```solidity\n96:     mapping(address => mapping(address => uint256)) public curvesTokenBalance; // <= FOUND\n\n```\n",
          "loc": [
            "[96](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L96-L96)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use assembly to emit events",
      "description": "With the use of inline assembly in Solidity, we can take advantage of low-level features like scratch space and the free memory pointer, offering more gas-efficient ways of emitting events. The scratch space is a certain area of memory where we can temporarily store data, and the free memory pointer indicates the next available memory slot. Using these, we can efficiently assemble event data without incurring additional memory expansion costs. However, safety is paramount: to avoid overwriting or leakage, we must cache the free memory pointer before use and restore it afterward, ensuring that it points to the correct memory location post-operation.",
      "gasSavings": 228,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n251:         emit Trade( // <= FOUND\n252:             msg.sender,\n253:             curvesTokenSubject,\n254:             isBuy,\n255:             amount,\n256:             price,\n257:             protocolFee,\n258:             subjectFee,\n259:             isBuy ? supply + amount : supply - amount\n260:         );\n\n```\n",
          "loc": [
            "[251](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L251-L251)"
          ]
        },
        {
          "content": "```solidity\n324: \n325:         emit Transfer(curvesTokenSubject, from, to, amount); // <= FOUND\n\n```\n",
          "loc": [
            "[325](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L325-L325)"
          ]
        },
        {
          "content": "```solidity\n360: \n361:         emit TokenDeployed(curvesTokenSubject, tokenContract, name, symbol); // <= FOUND\n\n```\n",
          "loc": [
            "[361](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L361-L361)"
          ]
        },
        {
          "content": "```solidity\n400:             emit WhitelistUpdated(msg.sender, merkleRoot); // <= FOUND\n\n```\n",
          "loc": [
            "[400](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L400-L400)"
          ]
        },
        {
          "content": "```solidity\n86:         emit FeesClaimed(token, msg.sender, claimable); // <= FOUND\n\n```\n",
          "loc": [
            "[86](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L86-L86)"
          ]
        },
        {
          "content": "```solidity\n112:                 emit FeesClaimed(token, msg.sender, claimable); // <= FOUND\n\n```\n",
          "loc": [
            "[112](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L112-L112)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use solady library where possible to save gas",
      "description": "The following OpenZeppelin imports have a Solady equivalent, as such they can be used to save GAS as Solady modules have been specifically designed to be as GAS efficient as possible",
      "gasSavings": 3000,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n4: import \"@openzeppelin/contracts/access/Ownable.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[4](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n7: import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[7](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L7-L7)"
          ]
        },
        {
          "content": "```solidity\n5: import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[5](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L5-L5)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Counting down in for statements is more gas efficient",
      "description": "Looping downwards in Solidity is more gas efficient due to how the EVM compares variables. In a 'for' loop that counts down, the end condition is usually to compare with zero, which is cheaper than comparing with another number. As such, restructure your loops to count downwards where possible.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n305:        for (uint256 i = 0; i < subjects.length; i++) { // <= FOUND\n306:             uint256 amount = curvesTokenBalance[subjects[i]][msg.sender];\n307:             if (amount > 0) {\n308:                 _transfer(subjects[i], msg.sender, to, amount);\n309:             }\n310:         }\n\n```\n",
          "loc": [
            "[305](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L305-L305)"
          ]
        },
        {
          "content": "```solidity\n330:        for (uint256 i = 0; i < subjects.length; i++) { // <= FOUND\n331:             if (subjects[i] == curvesTokenSubject) {\n332:                 return;\n333:             }\n334:         }\n\n```\n",
          "loc": [
            "[330](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L330-L330)"
          ]
        },
        {
          "content": "```solidity\n55:        for (uint256 i = 0; i < tokens.length; i++) { // <= FOUND\n56:             address token = tokens[i];\n57:             uint256 claimable = getClaimableFees(token, user);\n58:             result[i] = UserClaimData(claimable, token);\n59:         }\n\n```\n",
          "loc": [
            "[55](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L55-L55)"
          ]
        },
        {
          "content": "```solidity\n105:        for (uint256 i = 0; i < tokenList.length; i++) { // <= FOUND\n106:             address token = tokenList[i];\n107:             updateFeeCredit(token, msg.sender);\n108:             uint256 claimable = getClaimableFees(token, msg.sender);\n109:             if (claimable > 0) {\n110:                 tokensData[token].unclaimedFees[msg.sender] = 0;\n111:                 totalClaimable += claimable;\n112:                 emit FeesClaimed(token, msg.sender, claimable);\n113:             }\n114:         }\n\n```\n",
          "loc": [
            "[105](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L105-L105)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "State variables can be packed into fewer storage slots by truncating timestamp bytes",
      "description": "State variables in Solidity are typically stored in 32-byte storage slots. When dealing with timestamps, which generally fit into a smaller byte size, it can be beneficial to truncate these bytes and pack them with other variables. This reduces the number of required storage slots, saving both storage space and associated gas costs. For example, a timestamp generally fits into a uint32, so it can be combined with other small variables within a single storage slot. When designing a contract, carefully structuring state variables to utilize truncation and packing can lead to a more efficient and cost-effective implementation.",
      "gasSavings": 2500,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n55:     struct PresaleMeta { // <= FOUND\n56:         uint256 startTime; // <= FOUND\n57:         bytes32 merkleRoot;\n58:         uint256 maxBuy;\n59:     }\n\n```\n",
          "loc": [
            "[55](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L55-L56)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Using private rather than public for constants and immutables, saves gas",
      "description": "Using private visibility for constants and immutables in Solidity instead of public can save gas. This is because private elements are not included in the contract's ABI, reducing the deployment and interaction costs. To achieve better efficiency, it is recommended to use private visibility when external access is not needed.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n44: string public constant DEFAULT_NAME = \"Curves\"; // <= FOUND\n\n```\n",
          "loc": [
            "[44](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L44-L44)"
          ]
        },
        {
          "content": "```solidity\n45: string public constant DEFAULT_SYMBOL = \"CURVES\"; // <= FOUND\n\n```\n",
          "loc": [
            "[45](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L45-L45)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Identical Deployments Should be Replaced with Clone",
      "description": "In the context of smart contracts, deploying multiple identical contracts can lead to inefficient use of gas and unnecessarily duplicate code on the blockchain. A more gas-efficient approach is to use a \"clone\" pattern. By deploying a master contract and then creating clones of it, only the differences between the instances are stored for each clone. This approach leverages the EIP-1167 standard, which defines a minimal proxy contract that points to the implementation contract. Clones can be far cheaper to deploy compared to full instances. So, the resolution is to replace identical deployments with clones, saving on gas and storage space.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n352: \n353:         address tokenContract = CurvesERC20Factory(curvesERC20Factory).deploy(name, symbol, address(this)); // <= FOUND\n\n```\n",
          "loc": [
            "[352](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L352-L353)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Mark Functions That Revert For Normal Users As payable",
      "description": "In Solidity, marking functions as `payable` allows them to accept Ether. If a function is known to revert for regular users (non-admin or specific roles) but needs to be accessible to others, marking it as `payable` can be beneficial. This ensures that even if a regular user accidentally sends Ether to the function, the Ether won't be trapped, as the function reverts, returning the funds. This can save gas by avoiding unnecessary failure handling in the function itself. Resolution: Carefully assess the roles and access patterns, and mark functions that should revert for regular users as `payable` to handle accidental Ether transfers.",
      "gasSavings": 225,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner {\n114:         feeRedistributor = FeeSplitter(payable(feeRedistributor_));\n115:     }\n\n```\n",
          "loc": [
            "[113](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L113-L113)"
          ]
        },
        {
          "content": "```solidity\n128:     function setProtocolFeePercent(uint256 protocolFeePercent_, address protocolFeeDestination_) external onlyOwner {\n129:         if (\n130:             protocolFeePercent_ +\n131:                 feesEconomics.subjectFeePercent +\n132:                 feesEconomics.referralFeePercent +\n133:                 feesEconomics.holdersFeePercent >\n134:             feesEconomics.maxFeePercent ||\n135:             protocolFeeDestination_ == address(0)\n136:         ) revert InvalidFeeDefinition();\n137:         feesEconomics.protocolFeePercent = protocolFeePercent_;\n138:         feesEconomics.protocolFeeDestination = protocolFeeDestination_;\n139:     }\n\n```\n",
          "loc": [
            "[128](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L128-L128)"
          ]
        },
        {
          "content": "```solidity\n162:     function setERC20Factory(address factory_) external onlyOwner {\n163:         curvesERC20Factory = factory_;\n164:     }\n\n```\n",
          "loc": [
            "[162](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L162-L162)"
          ]
        },
        {
          "content": "```solidity\n23:     function setManager(address manager_, bool value) public onlyOwner {\n24:         managers[manager_] = value;\n25:     }\n\n```\n",
          "loc": [
            "[23](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L23-L23)"
          ]
        },
        {
          "content": "```solidity\n12:     function mint(address to, uint256 amount) public onlyOwner {\n13:         _mint(to, amount);\n14:     }\n\n```\n",
          "loc": [
            "[12](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L12-L12)"
          ]
        },
        {
          "content": "```solidity\n16:     function burn(address from, uint256 amount) public onlyOwner {\n17:         _burn(from, amount);\n18:     }\n\n```\n",
          "loc": [
            "[16](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L16-L16)"
          ]
        },
        {
          "content": "```solidity\n117:     function setMaxFeePercent(uint256 maxFeePercent_) external onlyManager {\n118:         if (\n119:             feesEconomics.protocolFeePercent +\n120:                 feesEconomics.subjectFeePercent +\n121:                 feesEconomics.referralFeePercent +\n122:                 feesEconomics.holdersFeePercent >\n123:             maxFeePercent_\n124:         ) revert InvalidFeeDefinition();\n125:         feesEconomics.maxFeePercent = maxFeePercent_;\n126:     }\n\n```\n",
          "loc": [
            "[117](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L117-L117)"
          ]
        },
        {
          "content": "```solidity\n141:     function setExternalFeePercent(\n142:         uint256 subjectFeePercent_,\n143:         uint256 referralFeePercent_,\n144:         uint256 holdersFeePercent_\n145:     ) external onlyManager {\n146:         if (\n147:             feesEconomics.protocolFeePercent + subjectFeePercent_ + referralFeePercent_ + holdersFeePercent_ >\n148:             feesEconomics.maxFeePercent\n149:         ) revert InvalidFeeDefinition();\n150:         feesEconomics.subjectFeePercent = subjectFeePercent_;\n151:         feesEconomics.referralFeePercent = referralFeePercent_;\n152:         feesEconomics.holdersFeePercent = holdersFeePercent_;\n153:     }\n\n```\n",
          "loc": [
            "[141](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L141-L141)"
          ]
        },
        {
          "content": "```solidity\n96:     function onBalanceChange(address token, address account) public onlyManager {\n97:         TokenData storage data = tokensData[token];\n98:         data.userFeeOffset[account] = data.cumulativeFeePerToken;\n99:         if (balanceOf(token, account) > 0) userTokens[account].push(token);\n100:     }\n\n```\n",
          "loc": [
            "[96](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L96-L96)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "State variable read in a loop",
      "description": "Reading a state variable inside a loop in Solidity can be gas-inefficient, particularly in older versions of the language. Each read from a state variable in a loop incurs a gas cost, and these costs can accumulate quickly if the loop iterates many times. As a resolution, developers often manually cache the state variable outside the loop, reducing the number of state reads. By reading the variable only once and using the cached value within the loop, the gas costs can be significantly reduced. This approach requires careful consideration of the code's logic but can lead to more efficient contract execution.",
      "gasSavings": 6,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n305:        for (uint256 i = 0; i < subjects.length; i++) {\n306:             uint256 amount = curvesTokenBalance[subjects[i]][msg.sender]; // <= FOUND\n307:             if (amount > 0) {\n308:                 _transfer(subjects[i], msg.sender, to, amount);\n309:             }\n310:         }\n\n```\n",
          "loc": [
            "[306](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L306-L306)"
          ]
        },
        {
          "content": "```solidity\n330:        for (uint256 i = 0; i < subjects.length; i++) {\n331:             if (subjects[i] == curvesTokenSubject) { // <= FOUND\n332:                 return;\n333:             }\n334:         }\n\n```\n",
          "loc": [
            "[331](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L331-L331)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Function names can be optimized",
      "description": "Function names in Solidity contracts can be optimized to save gas during both deployment and execution. Method IDs are the first four bytes of the keccak256 hash of the function signature, and having two leading zero bytes can save 128 gas each during deployment. Additionally, renaming functions to have lower method IDs can save 22 gas per call, per sorted position shifted. This optimization leverages the way EVM handles data storage, making the execution more efficient. While these savings might seem minor, they can add up in contracts with numerous calls, contributing to more economical and efficient code.",
      "gasSavings": 640,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n41: contract Curves is CurvesErrors, Security  // <= FOUND\n\n```\n",
          "loc": [
            "[41](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L41-L41)"
          ]
        },
        {
          "content": "```solidity\n9: contract FeeSplitter is Security  // <= FOUND\n\n```\n",
          "loc": [
            "[9](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L9-L9)"
          ]
        },
        {
          "content": "```solidity\n4: contract Security  // <= FOUND\n\n```\n",
          "loc": [
            "[4](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n7: contract CurvesERC20 is ERC20, Ownable  // <= FOUND\n\n```\n",
          "loc": [
            "[7](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L7-L7)"
          ]
        },
        {
          "content": "```solidity\n6: contract CurvesERC20Factory  // <= FOUND\n\n```\n",
          "loc": [
            "[6](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20Factory.sol#L6-L6)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use assembly to validate msg.sender",
      "description": "Utilizing assembly for validating `msg.sender` can potentially save gas as it allows for more direct and efficient access to Ethereum’s EVM opcodes, bypassing some of the overhead introduced by Solidity’s higher-level abstractions. However, this practice requires deep expertise in EVM, as incorrect implementation can introduce critical vulnerabilities. It is a trade-off between gas efficiency and code safety.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n104:         if (curvesTokenSubject != msg.sender) revert UnauthorizedCurvesTokenSubject(); // <= FOUND\n\n```\n",
          "loc": [
            "[104](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L104-L104)"
          ]
        },
        {
          "content": "```solidity\n265:         if (!(supply > 0 || curvesTokenSubject == msg.sender)) revert UnauthorizedCurvesTokenSubject(); // <= FOUND\n\n```\n",
          "loc": [
            "[265](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L265-L265)"
          ]
        },
        {
          "content": "```solidity\n285:         if (curvesTokenBalance[curvesTokenSubject][msg.sender] < amount) revert InsufficientBalance(); // <= FOUND\n\n```\n",
          "loc": [
            "[285](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L285-L285)"
          ]
        },
        {
          "content": "```solidity\n466:         if (amount > curvesTokenBalance[curvesTokenSubject][msg.sender]) revert InsufficientBalance(); // <= FOUND\n\n```\n",
          "loc": [
            "[466](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L466-L466)"
          ]
        },
        {
          "content": "```solidity\n497:         if (amount > CurvesERC20(externalToken).balanceOf(msg.sender)) revert InsufficientBalance(); // <= FOUND\n\n```\n",
          "loc": [
            "[497](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L497-L497)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Unnecessary casting as variable is already of the same type",
      "description": "Unnecessary casting of a variable to the same type is redundant and can contribute to gas inefficiency and code clutter. This situation commonly arises when developers, perhaps due to oversight or misunderstanding, explicitly cast a variable to its existing type. For example, casting a `uint256` variable to `uint256` again does not change its type or value but adds unnecessary operations to the code.\n\n**Resolution**: Developers should scrutinize their code to identify and remove any unnecessary type casting. Utilizing linters or static analysis tools can aid in detecting such redundancies. Ensuring that the code is clean and efficient not only saves gas but also enhances readability and maintainability.",
      "gasSavings": 22,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n338:     function _deployERC20(\n339:         address curvesTokenSubject,\n340:         string memory name,\n341:         string memory symbol\n342:     ) internal returns (address) {\n343:         \n344:         if (keccak256(bytes(symbol)) == keccak256(bytes(DEFAULT_SYMBOL))) {\n345:             _curvesTokenCounter += 1;\n346:             name = string(abi.encodePacked(name, \" \", Strings.toString(_curvesTokenCounter)));\n347:             symbol = string(abi.encodePacked(symbol, Strings.toString(_curvesTokenCounter)));\n348:         }\n349: \n350:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();\n351: \n352:         address tokenContract = CurvesERC20Factory(curvesERC20Factory).deploy(name, symbol, address(this));\n353: \n354:         externalCurvesTokens[curvesTokenSubject].token = tokenContract;\n355:         externalCurvesTokens[curvesTokenSubject].name = name;\n356:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;\n357:         externalCurvesToSubject[tokenContract] = curvesTokenSubject;\n358:         symbolToSubject[symbol] = curvesTokenSubject;\n359: \n360:         emit TokenDeployed(curvesTokenSubject, tokenContract, name, symbol);\n361:         return address(tokenContract); // <= FOUND\n362:     }\n\n```\n",
          "loc": [
            "[338](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L338-L361)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Simple checks for zero uint can be done using assembly to save gas",
      "description": "Using assembly for simple zero checks on unsigned integers can save gas due to lower-level, optimized operations. \n\n**Resolution**: Implement inline assembly with Solidity's `assembly` block to perform zero checks. Ensure thorough testing and verification, as assembly lacks the safety checks of high-level Solidity, potentially introducing vulnerabilities if not used carefully.",
      "gasSavings": 48,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n181:         uint256 sum1 = supply == 0 ? 0 : ((supply - 1) * (supply) * (2 * (supply - 1) + 1)) / 6; // <= FOUND\n\n```\n",
          "loc": [
            "[181](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L181-L181)"
          ]
        },
        {
          "content": "```solidity\n389:         presalesMeta[curvesTokenSubject].maxBuy = (maxBuy == 0 ? type(uint256).max : maxBuy); // <= FOUND\n\n```\n",
          "loc": [
            "[389](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L389-L389)"
          ]
        },
        {
          "content": "```solidity\n83:         if (claimable == 0) revert NoFeesToClaim(); // <= FOUND\n\n```\n",
          "loc": [
            "[83](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L83-L83)"
          ]
        },
        {
          "content": "```solidity\n91:         if (totalSupply_ == 0) revert NoTokenHolders(); // <= FOUND\n\n```\n",
          "loc": [
            "[91](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L91-L91)"
          ]
        },
        {
          "content": "```solidity\n115:         if (totalClaimable == 0) revert NoFeesToClaim(); // <= FOUND\n\n```\n",
          "loc": [
            "[115](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L115-L115)"
          ]
        },
        {
          "content": "```solidity\n371:         if (supply != 0) revert CurveAlreadyExists(); // <= FOUND\n\n```\n",
          "loc": [
            "[371](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L371-L371)"
          ]
        },
        {
          "content": "```solidity\n491:         if (amount % 1 ether != 0) revert NonIntegerDepositAmount(); // <= FOUND\n\n```\n",
          "loc": [
            "[491](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L491-L491)"
          ]
        },
        {
          "content": "```solidity\n99:         if (balanceOf(token, account) > 0) userTokens[account].push(token); // <= FOUND\n\n```\n",
          "loc": [
            "[99](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L99-L99)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Trade-offs Between Modifiers and Internal Functions",
      "description": "In Solidity, both modifiers and internal functions can be used to modularize and reuse code, but they have different trade-offs.\n\nModifiers are primarily used to augment the behavior of functions, often for checks or validations. They can access parameters of the function they modify and are integrated into the function’s code at compile time. This makes them syntactically cleaner for repetitive precondition checks. However, modifiers can sometimes lead to less readable code, especially when the logic is complex or when multiple modifiers are used on a single function.\n\nInternal functions, on the other hand, offer more flexibility. They can contain complex logic, return values, and be called from other functions. This makes them more suitable for reusable chunks of business logic. Since internal functions are separate entities, they can be more readable and easier to test in isolation compared to modifiers.\n\nUsing internal functions can result in slightly more gas consumption, as it involves an internal function call. However, this cost is usually minimal and can be a worthwhile trade-off for increased code clarity and maintainability.\n\nIn summary, while modifiers offer a concise way to include checks and simple logic across multiple functions, internal functions provide more flexibility and are better suited for complex and reusable code. The choice between the two should be based on the specific use case, considering factors like code complexity, readability, and gas efficiency.",
      "gasSavings": 105000,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n218:     function _transferFees( // <= FOUND\n219:         address curvesTokenSubject, // <= FOUND\n220:         bool isBuy, // <= FOUND\n221:         uint256 price, // <= FOUND\n222:         uint256 amount, // <= FOUND\n223:         uint256 supply // <= FOUND\n224:     ) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[218](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L218-L224)"
          ]
        },
        {
          "content": "```solidity\n263:     function _buyCurvesToken(address curvesTokenSubject, uint256 amount) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[263](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L263-L263)"
          ]
        },
        {
          "content": "```solidity\n313:     function _transfer(address curvesTokenSubject, address from, address to, uint256 amount) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[313](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L313-L313)"
          ]
        },
        {
          "content": "```solidity\n328:     function _addOwnedCurvesTokenSubject(address owner_, address curvesTokenSubject) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[328](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L328-L328)"
          ]
        },
        {
          "content": "```solidity\n338:     function _deployERC20( // <= FOUND\n339:         address curvesTokenSubject, // <= FOUND\n340:         string memory name, // <= FOUND\n341:         string memory symbol // <= FOUND\n342:     ) internal returns (address)  // <= FOUND\n\n```\n",
          "loc": [
            "[338](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L338-L342)"
          ]
        },
        {
          "content": "```solidity\n456:     function _mint( // <= FOUND\n457:         address curvesTokenSubject, // <= FOUND\n458:         string memory name, // <= FOUND\n459:         string memory symbol // <= FOUND\n460:     ) internal onlyTokenSubject(curvesTokenSubject)  // <= FOUND\n\n```\n",
          "loc": [
            "[456](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L456-L460)"
          ]
        },
        {
          "content": "```solidity\n63:     function updateFeeCredit(address token, address account) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[63](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L63-L63)"
          ]
        },
        {
          "content": "```solidity\n103:     modifier onlyTokenSubject(address curvesTokenSubject)  // <= FOUND\n\n```\n",
          "loc": [
            "[103](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L103-L103)"
          ]
        },
        {
          "content": "```solidity\n8:     modifier onlyOwner()  // <= FOUND\n\n```\n",
          "loc": [
            "[8](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L8-L8)"
          ]
        },
        {
          "content": "```solidity\n13:     modifier onlyManager()  // <= FOUND\n\n```\n",
          "loc": [
            "[13](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L13-L13)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Using nested if to save gas",
      "description": "Using nested `if` statements instead of logical AND (`&&`) operators can potentially save gas in Solidity contracts. When a series of conditions are connected with `&&`, all conditions must be evaluated even if the first one fails. In contrast, nested `if` statements allow for short-circuiting; if the first condition fails, the rest are skipped, saving gas. This approach is more gas-efficient, especially when dealing with complex or gas-intensive conditions. However, it's crucial to balance gas savings with code readability and maintainability, ensuring that the code remains clear and easy to understand.",
      "gasSavings": 12,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n246:             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0)) { // <= FOUND\n247:                 feeRedistributor.onBalanceChange(curvesTokenSubject, msg.sender);\n248:                 feeRedistributor.addFees{value: holderFee}(curvesTokenSubject);\n249:             }\n\n```\n",
          "loc": [
            "[246](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L246-L246)"
          ]
        },
        {
          "content": "```solidity\n246:             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0)) { // <= FOUND\n247:                 feeRedistributor.onBalanceChange(curvesTokenSubject, msg.sender);\n248:                 feeRedistributor.addFees{value: holderFee}\n\n```\n",
          "loc": [
            "[246](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L246-L246)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Optimize Deployment Size by Fine-tuning IPFS Hash",
      "description": "Optimizing the deployment size of a smart contract is vital to minimize gas costs, and one way to achieve this is by fine-tuning the IPFS hash appended by the Solidity compiler as metadata. This metadata, consisting of 53 bytes, increases the gas required for contract deployment by approximately 10,600 gas due to bytecode costs, and additionally, up to 848 gas due to calldata costs, depending on the proportion of zero and non-zero bytes. Utilize the --no-cbor-metadata compiler flag to prevent the compiler from appending metadata. However, this approach has a drawback as it can complicate the contract verification process on block explorers like Etherscan, potentially reducing transparency.",
      "gasSavings": 53000,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n41: contract Curves is CurvesErrors, Security  // <= FOUND\n\n```\n",
          "loc": [
            "[41](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L41-L41)"
          ]
        },
        {
          "content": "```solidity\n9: contract FeeSplitter is Security  // <= FOUND\n\n```\n",
          "loc": [
            "[9](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L9-L9)"
          ]
        },
        {
          "content": "```solidity\n4: contract Security  // <= FOUND\n\n```\n",
          "loc": [
            "[4](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n7: contract CurvesERC20 is ERC20, Ownable  // <= FOUND\n\n```\n",
          "loc": [
            "[7](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L7-L7)"
          ]
        },
        {
          "content": "```solidity\n6: contract CurvesERC20Factory  // <= FOUND\n\n```\n",
          "loc": [
            "[6](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20Factory.sol#L6-L6)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Avoid Unnecessary Public Variables",
      "description": "Public state variables in Solidity automatically generate getter functions, increasing contract size and potentially leading to higher deployment and interaction costs. To optimize gas usage and contract efficiency, minimize the use of public variables unless external access is necessary. Instead, use internal or private visibility combined with explicit getter functions when required. This practice not only reduces contract size but also provides better control over data access and manipulation, enhancing security and readability. Prioritize lean, efficient contracts to ensure cost-effectiveness and better performance on the blockchain.",
      "gasSavings": 154000,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n42: address public curvesERC20Factory; // <= FOUND\n\n```\n",
          "loc": [
            "[42](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L42-L42)"
          ]
        },
        {
          "content": "```solidity\n43: FeeSplitter public feeRedistributor; // <= FOUND\n\n```\n",
          "loc": [
            "[43](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L43-L43)"
          ]
        },
        {
          "content": "```solidity\n44: string public constant DEFAULT_NAME = \"Curves\"; // <= FOUND\n\n```\n",
          "loc": [
            "[44](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L44-L44)"
          ]
        },
        {
          "content": "```solidity\n45: string public constant DEFAULT_SYMBOL = \"CURVES\"; // <= FOUND\n\n```\n",
          "loc": [
            "[45](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L45-L45)"
          ]
        },
        {
          "content": "```solidity\n77: FeesEconomics public feesEconomics; // <= FOUND\n\n```\n",
          "loc": [
            "[77](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L77-L77)"
          ]
        },
        {
          "content": "```solidity\n10: Curves public curves; // <= FOUND\n\n```\n",
          "loc": [
            "[10](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L10-L10)"
          ]
        },
        {
          "content": "```solidity\n5: address public owner; // <= FOUND\n\n```\n",
          "loc": [
            "[5](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L5-L5)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Avoid emitting event on every iteration",
      "description": "Emitting events within a loop can cause significant gas consumption due to repeated I/O operations. Instead, accumulate changes in memory and emit a single event post-loop with aggregated data. This approach improves contract efficiency, reduces gas costs, and simplifies event tracking for event listeners.",
      "gasSavings": 375,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n105:        for (uint256 i = 0; i < tokenList.length; i++) {\n106:             address token = tokenList[i];\n107:             updateFeeCredit(token, msg.sender);\n108:             uint256 claimable = getClaimableFees(token, msg.sender);\n109:             if (claimable > 0) {\n110:                 tokensData[token].unclaimedFees[msg.sender] = 0;\n111:                 totalClaimable += claimable;\n112:                 emit FeesClaimed(token, msg.sender, claimable); // <= FOUND\n113:             }\n114:         }\n\n```\n",
          "loc": [
            "[112](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L112-L112)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "++X costs slightly less gas than X++ (same with --)",
      "description": "Move the ++/-- action to the left of the variable",
      "gasSavings": 15,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n305:         for (uint256 i = 0; i < subjects.length; i++) { // <= FOUND\n\n```\n",
          "loc": [
            "[305](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L305-L305)"
          ]
        },
        {
          "content": "```solidity\n55:         for (uint256 i = 0; i < tokens.length; i++) { // <= FOUND\n\n```\n",
          "loc": [
            "[55](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L55-L55)"
          ]
        },
        {
          "content": "```solidity\n105:         for (uint256 i = 0; i < tokenList.length; i++) { // <= FOUND\n\n```\n",
          "loc": [
            "[105](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L105-L105)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Solidity versions 0.8.19 and above are more gas efficient",
      "description": "Solidity version 0.8.19 introduced a array of gas optimizations which make contracts which use it more efficient. Provided compatability it may be beneficial to upgrade to this version",
      "gasSavings": 2000,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n2: pragma solidity 0.8.7;\n\n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L2-L2)"
          ]
        },
        {
          "content": "```solidity\n2: pragma solidity ^0.8.7;\n\n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L2-L2)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Variable declared within iteration",
      "description": "Please elaborate and generalise the following with detail and  feel free to use your own knowledge and lmit ur words to 100 words please: ",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n305:        for (uint256 i = 0; i < subjects.length; i++) { // <= FOUND\n306:             uint256 amount = curvesTokenBalance[subjects[i]][msg.sender];\n307:             if (amount > 0) {\n308:                 _transfer(subjects[i], msg.sender, to, amount);\n309:             }\n310:         }\n\n```\n",
          "loc": [
            "[305](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L305-L305)"
          ]
        },
        {
          "content": "```solidity\n55:        for (uint256 i = 0; i < tokens.length; i++) { // <= FOUND\n56:             address token = tokens[i];\n57:             uint256 claimable = getClaimableFees(token, user); // <= FOUND\n58:             result[i] = UserClaimData(claimable, token);\n59:         }\n\n```\n",
          "loc": [
            "[55](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L55-L57)"
          ]
        },
        {
          "content": "```solidity\n105:        for (uint256 i = 0; i < tokenList.length; i++) { // <= FOUND\n106:             address token = tokenList[i];\n107:             updateFeeCredit(token, msg.sender);\n108:             uint256 claimable = getClaimableFees(token, msg.sender); // <= FOUND\n109:             if (claimable > 0) {\n110:                 tokensData[token].unclaimedFees[msg.sender] = 0;\n111:                 totalClaimable += claimable;\n112:                 emit FeesClaimed(token, msg.sender, claimable);\n113:             }\n114:         }\n\n```\n",
          "loc": [
            "[105](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L105-L108)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "The use of a logical AND in place of double if is slightly less gas efficient in instances where there isn't a corresponding else statement for the given if statement",
      "description": "Using a double if statement instead of logical AND (&&) can provide similar short-circuiting behavior whereas double if is slightly more efficient.",
      "gasSavings": 45,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n182:         uint256 sum2 = supply == 0 && amount == 1 // <= FOUND\n183:             ? 0\n184:             : ((supply - 1 + amount) * (supply + amount) * (2 * (supply - 1 + amount) + 1)) / 6;\n\n```\n",
          "loc": [
            "[182](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L182-L182)"
          ]
        },
        {
          "content": "```solidity\n213:         if (startTime != 0 && startTime >= block.timestamp) revert SaleNotOpen(); // <= FOUND\n\n```\n",
          "loc": [
            "[213](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L213-L213)"
          ]
        },
        {
          "content": "```solidity\n246: \n247:             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0)) { // <= FOUND\n\n```\n",
          "loc": [
            "[247](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L247-L247)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Calling .length in a for loop wastes gas",
      "description": "Rather than calling .length for an array in a for loop declaration, it is far more gas efficient to cache this length before and use that instead. This will prevent the array length from being called every loop iteration",
      "gasSavings": 291,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n305: for (uint256 i = 0; i < subjects.length; i++)  // <= FOUND\n\n```\n",
          "loc": [
            "[305](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L305-L305)"
          ]
        },
        {
          "content": "```solidity\n55: for (uint256 i = 0; i < tokens.length; i++)  // <= FOUND\n\n```\n",
          "loc": [
            "[55](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L55-L55)"
          ]
        },
        {
          "content": "```solidity\n105: for (uint256 i = 0; i < tokenList.length; i++)  // <= FOUND\n\n```\n",
          "loc": [
            "[105](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L105-L105)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Constructors can be marked as payable to save deployment gas",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n108:     constructor(address curvesERC20Factory_, address feeRedistributor_) Security() {\n109:         curvesERC20Factory = curvesERC20Factory_;\n110:         feeRedistributor = FeeSplitter(payable(feeRedistributor_));\n111:     }\n\n```\n",
          "loc": [
            "[108](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L108-L108)"
          ]
        },
        {
          "content": "```solidity\n33:     constructor() Security() {}\n\n```\n",
          "loc": [
            "[33](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L33-L33)"
          ]
        },
        {
          "content": "```solidity\n18:     constructor() {\n19:         owner = msg.sender;\n20:         managers[msg.sender] = true;\n21:     }\n\n```\n",
          "loc": [
            "[18](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L18-L18)"
          ]
        },
        {
          "content": "```solidity\n8:     constructor(string memory name_, string memory symbol_, address owner) ERC20(name_, symbol_) {\n9:         transferOwnership(owner);\n10:     }\n\n```\n",
          "loc": [
            "[8](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/CurvesERC20.sol#L8-L8)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use assembly scratch space to build calldata for external calls",
      "description": "Using Solidity's assembly scratch space for constructing calldata in external calls with one or two arguments can be a gas-efficient approach. This method leverages the designated memory area (the first 64 bytes of memory) for temporary data storage during assembly operations. By directly writing arguments into this scratch space, it eliminates the need for additional memory allocation typically required for calldata preparation. This technique can lead to notable gas savings, especially in high-frequency or gas-sensitive operations. However, it requires careful implementation to avoid data corruption and should be used with a thorough understanding of low-level EVM operations and memory handling. Proper testing and validation are crucial when employing such optimizations.",
      "gasSavings": 3520,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n247:                 feeRedistributor.onBalanceChange(curvesTokenSubject, msg.sender); // <= FOUND\n\n```\n",
          "loc": [
            "[247](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L247-L247)"
          ]
        },
        {
          "content": "```solidity\n486:         _transfer(curvesTokenSubject, msg.sender, address(this), amount); // <= FOUND\n\n```\n",
          "loc": [
            "[486](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L486-L486)"
          ]
        },
        {
          "content": "```solidity\n487:         CurvesERC20(externalToken).mint(msg.sender, amount * 1 ether); // <= FOUND\n\n```\n",
          "loc": [
            "[487](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L487-L487)"
          ]
        },
        {
          "content": "```solidity\n500: \n501:         CurvesERC20(externalToken).burn(msg.sender, amount); // <= FOUND\n\n```\n",
          "loc": [
            "[500](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L500-L501)"
          ]
        },
        {
          "content": "```solidity\n40:         return curves.curvesTokenBalance(token, account) * PRECISION; // <= FOUND\n\n```\n",
          "loc": [
            "[40](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L40-L40)"
          ]
        },
        {
          "content": "```solidity\n45:         \n46:         return (curves.curvesTokenSupply(token) - curves.curvesTokenBalance(token, address(curves))) * PRECISION; // <= FOUND\n\n```\n",
          "loc": [
            "[45](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L45-L46)"
          ]
        },
        {
          "content": "```solidity\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\"); // <= FOUND\n\n```\n",
          "loc": [
            "[232](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L232-L232)"
          ]
        },
        {
          "content": "```solidity\n236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}(\"\"); // <= FOUND\n\n```\n",
          "loc": [
            "[236](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L236-L236)"
          ]
        },
        {
          "content": "```solidity\n240:                 (bool success3, ) = referralDefined // <= FOUND\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}(\"\") // <= FOUND\n\n```\n",
          "loc": [
            "[240](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L240-L241)"
          ]
        },
        {
          "content": "```solidity\n248:                 feeRedistributor.addFees{value: holderFee}(curvesTokenSubject); // <= FOUND\n\n```\n",
          "loc": [
            "[248](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L248-L248)"
          ]
        },
        {
          "content": "```solidity\n335:         subjects.push(curvesTokenSubject); // <= FOUND\n\n```\n",
          "loc": [
            "[335](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L335-L335)"
          ]
        },
        {
          "content": "```solidity\n389:         presalesMeta[curvesTokenSubject].maxBuy = (maxBuy == 0 ? type(uint256).max : maxBuy); // <= FOUND\n\n```\n",
          "loc": [
            "[389](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L389-L389)"
          ]
        },
        {
          "content": "```solidity\n85:         payable(msg.sender).transfer(claimable); // <= FOUND\n\n```\n",
          "loc": [
            "[85](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L85-L85)"
          ]
        },
        {
          "content": "```solidity\n93:         data.cumulativeFeePerToken += (msg.value * PRECISION) / totalSupply_; // <= FOUND\n\n```\n",
          "loc": [
            "[93](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L93-L93)"
          ]
        },
        {
          "content": "```solidity\n99:         if (balanceOf(token, account) > 0) userTokens[account].push(token); // <= FOUND\n\n```\n",
          "loc": [
            "[99](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L99-L99)"
          ]
        },
        {
          "content": "```solidity\n116:         payable(msg.sender).transfer(totalClaimable); // <= FOUND\n\n```\n",
          "loc": [
            "[116](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L116-L116)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use assembly scratch space to build calldata for event emits",
      "description": "Utilizing Solidity's assembly scratch space to build calldata for emitting events with just one or two arguments can optimize gas usage. The scratch space, a designated area in the first 64 bytes of memory, is ideal for temporary storage during assembly-level operations. By directly writing the event arguments into this area, developers can bypass the standard memory allocation process required for event emission. This approach results in gas savings, particularly for contracts where events are frequently emitted. However, such low-level optimization requires a deep understanding of Ethereum Virtual Machine (EVM) mechanics and careful coding to prevent data mishandling. Rigorous testing is essential to ensure the integrity and correct functionality of the contract.",
      "gasSavings": 220,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n400:             emit WhitelistUpdated(msg.sender, merkleRoot); // <= FOUND\n\n```\n",
          "loc": [
            "[400](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L400-L400)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Consider using solady's \"FixedPointMathLib\"",
      "description": "Using Solady's \"FixedPointMathLib\" for multiplication or division operations in Solidity can lead to significant gas savings. This library is designed to optimize fixed-point arithmetic operations, which are common in financial calculations involving tokens or currencies. By implementing more efficient algorithms and assembly optimizations, \"FixedPointMathLib\" minimizes the computational resources required for these operations. For contracts that frequently perform such calculations, integrating this library can reduce transaction costs, thereby enhancing overall performance and cost-effectiveness. However, developers must ensure compatibility with their existing codebase and thoroughly test for accuracy and expected behavior to avoid any unintended consequences.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n173:         protocolFee = (price * feesEconomics.protocolFeePercent) / 1 ether; // <= FOUND\n\n```\n",
          "loc": [
            "[173](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L173-L173)"
          ]
        },
        {
          "content": "```solidity\n174:         subjectFee = (price * feesEconomics.subjectFeePercent) / 1 ether; // <= FOUND\n\n```\n",
          "loc": [
            "[174](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L174-L174)"
          ]
        },
        {
          "content": "```solidity\n175:         referralFee = (price * feesEconomics.referralFeePercent) / 1 ether; // <= FOUND\n\n```\n",
          "loc": [
            "[175](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L175-L175)"
          ]
        },
        {
          "content": "```solidity\n176:         holdersFee = (price * feesEconomics.holdersFeePercent) / 1 ether; // <= FOUND\n\n```\n",
          "loc": [
            "[176](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L176-L176)"
          ]
        },
        {
          "content": "```solidity\n181:         uint256 sum1 = supply == 0 ? 0 : ((supply - 1) * (supply) * (2 * (supply - 1) + 1)) / 6; // <= FOUND\n\n```\n",
          "loc": [
            "[181](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L181-L181)"
          ]
        },
        {
          "content": "```solidity\n182:         uint256 sum2 = supply == 0 && amount == 1\n183:             ? 0\n184:             : ((supply - 1 + amount) * (supply + amount) * (2 * (supply - 1 + amount) + 1)) / 6; // <= FOUND\n\n```\n",
          "loc": [
            "[184](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L184-L184)"
          ]
        },
        {
          "content": "```solidity\n186:         return (summation * 1 ether) / 16000; // <= FOUND\n\n```\n",
          "loc": [
            "[186](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L186-L186)"
          ]
        },
        {
          "content": "```solidity\n494:         uint256 tokenAmount = amount / 1 ether; // <= FOUND\n\n```\n",
          "loc": [
            "[494](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L494-L494)"
          ]
        },
        {
          "content": "```solidity\n508:         sellCurvesToken(curvesTokenSubject, amount / 1 ether); // <= FOUND\n\n```\n",
          "loc": [
            "[508](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L508-L508)"
          ]
        },
        {
          "content": "```solidity\n68:             data.unclaimedFees[account] += owed / PRECISION; // <= FOUND\n\n```\n",
          "loc": [
            "[68](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L68-L68)"
          ]
        },
        {
          "content": "```solidity\n77:         return (owed / PRECISION) + data.unclaimedFees[account]; // <= FOUND\n\n```\n",
          "loc": [
            "[77](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L77-L77)"
          ]
        },
        {
          "content": "```solidity\n93:         data.cumulativeFeePerToken += (msg.value * PRECISION) / totalSupply_; // <= FOUND\n\n```\n",
          "loc": [
            "[93](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L93-L93)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Same cast is done multiple times",
      "description": "Repeatedly casting the same variable to the same type within a function is redundant and can be optimized for better gas efficiency and code readability. Each unnecessary cast operation, while minor, adds to the gas cost and clutters the code. To optimize, the best practice is to perform the cast once and store the result in a temporary variable, which can then be used wherever needed in the function.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n218:     function _transferFees(\n219:         address curvesTokenSubject,\n220:         bool isBuy,\n221:         uint256 price,\n222:         uint256 amount,\n223:         uint256 supply\n224:     ) internal {\n225:         (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holderFee, ) = getFees(price);\n226:         {\n227:             bool referralDefined = referralFeeDestination[curvesTokenSubject] != address(0); // <= FOUND 'address(0)'\n228:             {\n229:                 address firstDestination = isBuy ? feesEconomics.protocolFeeDestination : msg.sender;\n230:                 uint256 buyValue = referralDefined ? protocolFee : protocolFee + referralFee;\n231:                 uint256 sellValue = price - protocolFee - subjectFee - referralFee - holderFee;\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\");\n233:                 if (!success1) revert CannotSendFunds();\n234:             }\n235:             {\n236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}(\"\");\n237:                 if (!success2) revert CannotSendFunds();\n238:             }\n239:             {\n240:                 (bool success3, ) = referralDefined\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}(\"\")\n242:                     : (true, bytes(\"\"));\n243:                 if (!success3) revert CannotSendFunds();\n244:             }\n245: \n246:             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0)) { // <= FOUND 'address(0)'\n247:                 feeRedistributor.onBalanceChange(curvesTokenSubject, msg.sender);\n248:                 feeRedistributor.addFees{value: holderFee}(curvesTokenSubject);\n249:             }\n250:         }\n251:         emit Trade(\n252:             msg.sender,\n253:             curvesTokenSubject,\n254:             isBuy,\n255:             amount,\n256:             price,\n257:             protocolFee,\n258:             subjectFee,\n259:             isBuy ? supply + amount : supply - amount\n260:         );\n261:     }\n\n```\n",
          "loc": [
            "[218](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L218-L246)"
          ]
        },
        {
          "content": "```solidity\n428:     function setNameAndSymbol(\n429:         address curvesTokenSubject,\n430:         string memory name,\n431:         string memory symbol\n432:     ) external onlyTokenSubject(curvesTokenSubject) {\n433:         if (externalCurvesTokens[curvesTokenSubject].token != address(0)) revert ERC20TokenAlreadyMinted(); // <= FOUND 'address(0)'\n434:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata(); // <= FOUND 'address(0)'\n435:         externalCurvesTokens[curvesTokenSubject].name = name;\n436:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;\n437:     }\n\n```\n",
          "loc": [
            "[428](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L428-L434)"
          ]
        },
        {
          "content": "```solidity\n490:     function deposit(address curvesTokenSubject, uint256 amount) public {\n491:         if (amount % 1 ether != 0) revert NonIntegerDepositAmount();\n492: \n493:         address externalToken = externalCurvesTokens[curvesTokenSubject].token;\n494:         uint256 tokenAmount = amount / 1 ether;\n495: \n496:         if (externalToken == address(0)) revert TokenAbsentForCurvesTokenSubject(); // <= FOUND 'address(0)'\n497:         if (amount > CurvesERC20(externalToken).balanceOf(msg.sender)) revert InsufficientBalance();\n498:         if (tokenAmount > curvesTokenBalance[curvesTokenSubject][address(this)]) revert InsufficientBalance(); // <= FOUND 'address(this)'\n499: \n500:         CurvesERC20(externalToken).burn(msg.sender, amount);\n501:         _transfer(curvesTokenSubject, address(this), msg.sender, tokenAmount); // <= FOUND 'address(this)'\n502:     }\n\n```\n",
          "loc": [
            "[490](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L490-L501)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Cache address(this) when used more than once",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n490:     function deposit(address curvesTokenSubject, uint256 amount) public {\n491:         if (amount % 1 ether != 0) revert NonIntegerDepositAmount();\n492: \n493:         address externalToken = externalCurvesTokens[curvesTokenSubject].token;\n494:         uint256 tokenAmount = amount / 1 ether;\n495: \n496:         if (externalToken == address(0)) revert TokenAbsentForCurvesTokenSubject();\n497:         if (amount > CurvesERC20(externalToken).balanceOf(msg.sender)) revert InsufficientBalance();\n498:         if (tokenAmount > curvesTokenBalance[curvesTokenSubject][address(this)]) revert InsufficientBalance(); // <= FOUND\n499: \n500:         CurvesERC20(externalToken).burn(msg.sender, amount);\n501:         _transfer(curvesTokenSubject, address(this), msg.sender, tokenAmount); // <= FOUND\n502:     }\n\n```\n",
          "loc": [
            "[490](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L490-L501)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "bytes.concat() can be used in place of abi.encodePacked",
      "description": "Given concatenation is not going to be used for hashing bytes.concat is the preferred method to use as its more gas efficient when used with bytes variables",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n424:         \n425:         bytes32 leaf = keccak256(abi.encodePacked(caller)); // <= FOUND\n\n```\n",
          "loc": [
            "[424](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L424-L425)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Subtraction may underflow if multiplication is too large [EXP]",
      "description": "In arithmetic operations involving subtraction and multiplication, an underflow may occur if a subtraction result is negative, or if a multiplication result exceeds the maximum value representable in the data type. For instance, if a large multiplication precedes a subtraction, it may create a value too large to subtract from, causing an underflow. This could lead to unexpected and incorrect results in the calculation.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n180:     function getPrice(uint256 supply, uint256 amount) public pure returns (uint256) { // <= FOUND\n181:         uint256 sum1 = supply == 0 ? 0 : ((supply - 1) * (supply) * (2 * (supply - 1) + 1)) / 6; // <= FOUND\n182:         uint256 sum2 = supply == 0 && amount == 1\n183:             ? 0\n184:             : ((supply - 1 + amount) * (supply + amount) * (2 * (supply - 1 + amount) + 1)) / 6;\n185:         uint256 summation = sum2 - sum1;\n186:         return (summation * 1 ether) / 16000;\n187:     }\n\n```\n",
          "loc": [
            "[180](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L180-L181)"
          ]
        },
        {
          "content": "```solidity\n180:     function getPrice(uint256 supply, uint256 amount) public pure returns (uint256) { // <= FOUND\n181:         uint256 sum1 = supply == 0 ? 0 : ((supply - 1) * (supply) * (2 * (supply - 1) + 1)) / 6; // <= FOUND\n182:         uint256 sum2 = supply == 0 && amount == 1\n183:             ? 0\n184:             : ((supply - 1 + amount) * (supply + amount) * (2 * (supply - 1 + amount) + 1)) / 6;\n185:         uint256 summation = sum2 - sum1;\n186:         return (summation * 1 ether) / 16000;\n187:     }\n\n```\n",
          "loc": [
            "[180](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L180-L181)"
          ]
        },
        {
          "content": "```solidity\n180:     function getPrice(uint256 supply, uint256 amount) public pure returns (uint256) { // <= FOUND\n181:         uint256 sum1 = supply == 0 ? 0 : ((supply - 1) * (supply) * (2 * (supply - 1) + 1)) / 6; // <= FOUND\n182:         uint256 sum2 = supply == 0 && amount == 1\n183:             ? 0\n184:             : ((supply - 1 + amount) * (supply + amount) * (2 * (supply - 1 + amount) + 1)) / 6;\n185:         uint256 summation = sum2 - sum1;\n186:         return (summation * 1 ether) / 16000;\n187:     }\n\n```\n",
          "loc": [
            "[180](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L180-L181)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Code does not follow the best practice of check-effects-interaction [EXP]",
      "description": "The \"check-effects-interaction\" pattern is a best practice in smart contract development, emphasizing the order of operations in functions to prevent reentrancy attacks. Violations arise when a function interacts with external contracts before settling internal state changes or checks. This misordering can expose the contract to potential threats. To adhere to this pattern, first ensure all conditions or checks are satisfied, then update any internal states, and only after these steps, interact with external contracts or addresses. Rearranging operations to this recommended sequence bolsters contract security and aligns with established best practices in the Ethereum community.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n218:     function _transferFees(\n219:         address curvesTokenSubject,\n220:         bool isBuy,\n221:         uint256 price,\n222:         uint256 amount,\n223:         uint256 supply\n224:     ) internal {\n225:         (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holderFee, ) = getFees(price);\n226:         {\n227:             bool referralDefined = referralFeeDestination[curvesTokenSubject] != address(0);\n228:             {\n229:                 address firstDestination = isBuy ? feesEconomics.protocolFeeDestination : msg.sender;\n230:                 uint256 buyValue = referralDefined ? protocolFee : protocolFee + referralFee;\n231:                 uint256 sellValue = price - protocolFee - subjectFee - referralFee - holderFee;\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\"); // <= FOUND\n233:                 if (!success1) revert CannotSendFunds();\n234:             }\n235:             {\n236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}(\"\"); // <= FOUND\n237:                 if (!success2) revert CannotSendFunds();\n238:             }\n239:             {\n240:                 (bool success3, ) = referralDefined\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}(\"\")\n242:                     : (true, bytes(\"\"));\n243:                 if (!success3) revert CannotSendFunds();\n244:             }\n245: \n246:             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0)) {\n247:                 feeRedistributor.onBalanceChange(curvesTokenSubject, msg.sender);\n248:                 feeRedistributor.addFees{value: holderFee}(curvesTokenSubject);\n249:             }\n250:         }\n251:         emit Trade(\n252:             msg.sender,\n253:             curvesTokenSubject,\n254:             isBuy,\n255:             amount,\n256:             price,\n257:             protocolFee,\n258:             subjectFee,\n259:             isBuy ? supply + amount : supply - amount\n260:         );\n261:     }\n\n```\n",
          "loc": [
            "[218](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L218-L236)"
          ]
        },
        {
          "content": "```solidity\n218:     function _transferFees(\n219:         address curvesTokenSubject,\n220:         bool isBuy,\n221:         uint256 price,\n222:         uint256 amount,\n223:         uint256 supply\n224:     ) internal {\n225:         (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holderFee, ) = getFees(price);\n226:         {\n227:             bool referralDefined = referralFeeDestination[curvesTokenSubject] != address(0);\n228:             {\n229:                 address firstDestination = isBuy ? feesEconomics.protocolFeeDestination : msg.sender;\n230:                 uint256 buyValue = referralDefined ? protocolFee : protocolFee + referralFee;\n231:                 uint256 sellValue = price - protocolFee - subjectFee - referralFee - holderFee;\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\"); // <= FOUND\n233:                 if (!success1) revert CannotSendFunds();\n234:             }\n235:             {\n236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}(\"\"); // <= FOUND\n237:                 if (!success2) revert CannotSendFunds();\n238:             }\n239:             {\n240:                 (bool success3, ) = referralDefined\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}(\"\")\n242:                     : (true, bytes(\"\"));\n243:                 if (!success3) revert CannotSendFunds();\n244:             }\n245: \n246:             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0)) {\n247:                 feeRedistributor.onBalanceChange(curvesTokenSubject, msg.sender);\n248:                 feeRedistributor.addFees{value: holderFee}(curvesTokenSubject);\n249:             }\n250:         }\n251:         emit Trade(\n252:             msg.sender,\n253:             curvesTokenSubject,\n254:             isBuy,\n255:             amount,\n256:             price,\n257:             protocolFee,\n258:             subjectFee,\n259:             isBuy ? supply + amount : supply - amount\n260:         );\n261:     }\n\n```\n",
          "loc": [
            "[218](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L218-L236)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Avoid updating storage when the value hasn't changed [EXP]",
      "description": "",
      "gasSavings": 4800,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n302:     function transferAllCurvesTokens(address to) external { // <= FOUND\n303:         if (to == address(this)) revert ContractCannotReceiveTransfer();\n304:         address[] storage subjects = ownedCurvesTokenSubjects[msg.sender]; // <= FOUND\n305:         for (uint256 i = 0; i < subjects.length; i++) { // <= FOUND\n306:             uint256 amount = curvesTokenBalance[subjects[i]][msg.sender]; // <= FOUND\n307:             if (amount > 0) {\n308:                 _transfer(subjects[i], msg.sender, to, amount);\n309:             }\n310:         }\n311:     }\n\n```\n",
          "loc": [
            "[302](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L302-L306)"
          ]
        },
        {
          "content": "```solidity\n302:     function transferAllCurvesTokens(address to) external { // <= FOUND\n303:         if (to == address(this)) revert ContractCannotReceiveTransfer();\n304:         address[] storage subjects = ownedCurvesTokenSubjects[msg.sender]; // <= FOUND\n305:         for (uint256 i = 0; i < subjects.length; i++) { // <= FOUND\n306:             uint256 amount = curvesTokenBalance[subjects[i]][msg.sender]; // <= FOUND\n307:             if (amount > 0) {\n308:                 _transfer(subjects[i], msg.sender, to, amount);\n309:             }\n310:         }\n311:     }\n\n```\n",
          "loc": [
            "[302](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L302-L306)"
          ]
        },
        {
          "content": "```solidity\n302:     function transferAllCurvesTokens(address to) external { // <= FOUND\n303:         if (to == address(this)) revert ContractCannotReceiveTransfer();\n304:         address[] storage subjects = ownedCurvesTokenSubjects[msg.sender]; // <= FOUND\n305:         for (uint256 i = 0; i < subjects.length; i++) { // <= FOUND\n306:             uint256 amount = curvesTokenBalance[subjects[i]][msg.sender]; // <= FOUND\n307:             if (amount > 0) {\n308:                 _transfer(subjects[i], msg.sender, to, amount);\n309:             }\n310:         }\n311:     }\n\n```\n",
          "loc": [
            "[302](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L302-L306)"
          ]
        },
        {
          "content": "```solidity\n302:     function transferAllCurvesTokens(address to) external { // <= FOUND\n303:         if (to == address(this)) revert ContractCannotReceiveTransfer();\n304:         address[] storage subjects = ownedCurvesTokenSubjects[msg.sender]; // <= FOUND\n305:         for (uint256 i = 0; i < subjects.length; i++) { // <= FOUND\n306:             uint256 amount = curvesTokenBalance[subjects[i]][msg.sender]; // <= FOUND\n307:             if (amount > 0) {\n308:                 _transfer(subjects[i], msg.sender, to, amount);\n309:             }\n310:         }\n311:     }\n\n```\n",
          "loc": [
            "[302](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L302-L306)"
          ]
        },
        {
          "content": "```solidity\n302:     function transferAllCurvesTokens(address to) external { // <= FOUND\n303:         if (to == address(this)) revert ContractCannotReceiveTransfer();\n304:         address[] storage subjects = ownedCurvesTokenSubjects[msg.sender]; // <= FOUND\n305:         for (uint256 i = 0; i < subjects.length; i++) { // <= FOUND\n306:             uint256 amount = curvesTokenBalance[subjects[i]][msg.sender]; // <= FOUND\n307:             if (amount > 0) {\n308:                 _transfer(subjects[i], msg.sender, to, amount);\n309:             }\n310:         }\n311:     }\n\n```\n",
          "loc": [
            "[302](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L302-L306)"
          ]
        },
        {
          "content": "```solidity\n302:     function transferAllCurvesTokens(address to) external { // <= FOUND\n303:         if (to == address(this)) revert ContractCannotReceiveTransfer();\n304:         address[] storage subjects = ownedCurvesTokenSubjects[msg.sender]; // <= FOUND\n305:         for (uint256 i = 0; i < subjects.length; i++) { // <= FOUND\n306:             uint256 amount = curvesTokenBalance[subjects[i]][msg.sender]; // <= FOUND\n307:             if (amount > 0) {\n308:                 _transfer(subjects[i], msg.sender, to, amount);\n309:             }\n310:         }\n311:     }\n\n```\n",
          "loc": [
            "[302](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L302-L306)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Using abi.encodePacked can result in hash collision when used in hashing functions [EXP-2]",
      "description": "Consider using abi.encode as this pads data to 32 byte segments",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n338:     function _deployERC20(\n339:         address curvesTokenSubject,\n340:         string memory name,\n341:         string memory symbol\n342:     ) internal returns (address) {\n343:         \n344:         if (keccak256(bytes(symbol)) == keccak256(bytes(DEFAULT_SYMBOL))) {\n345:             _curvesTokenCounter += 1;\n346:             name = string(abi.encodePacked(name, \" \", Strings.toString(_curvesTokenCounter))); // <= FOUND\n347:             symbol = string(abi.encodePacked(symbol, Strings.toString(_curvesTokenCounter))); // <= FOUND\n348:         }\n349: \n350:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();\n351: \n352:         address tokenContract = CurvesERC20Factory(curvesERC20Factory).deploy(name, symbol, address(this));\n353: \n354:         externalCurvesTokens[curvesTokenSubject].token = tokenContract;\n355:         externalCurvesTokens[curvesTokenSubject].name = name;\n356:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;\n357:         externalCurvesToSubject[tokenContract] = curvesTokenSubject;\n358:         symbolToSubject[symbol] = curvesTokenSubject;\n359: \n360:         emit TokenDeployed(curvesTokenSubject, tokenContract, name, symbol);\n361:         return address(tokenContract);\n362:     }\n\n```\n",
          "loc": [
            "[346](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L346-L347)"
          ]
        },
        {
          "content": "```solidity\n338:     function _deployERC20(\n339:         address curvesTokenSubject,\n340:         string memory name,\n341:         string memory symbol\n342:     ) internal returns (address) {\n343:         \n344:         if (keccak256(bytes(symbol)) == keccak256(bytes(DEFAULT_SYMBOL))) {\n345:             _curvesTokenCounter += 1;\n346:             name = string(abi.encodePacked(name, \" \", Strings.toString(_curvesTokenCounter))); // <= FOUND\n347:             symbol = string(abi.encodePacked(symbol, Strings.toString(_curvesTokenCounter))); // <= FOUND\n348:         }\n349: \n350:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();\n351: \n352:         address tokenContract = CurvesERC20Factory(curvesERC20Factory).deploy(name, symbol, address(this));\n353: \n354:         externalCurvesTokens[curvesTokenSubject].token = tokenContract;\n355:         externalCurvesTokens[curvesTokenSubject].name = name;\n356:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;\n357:         externalCurvesToSubject[tokenContract] = curvesTokenSubject;\n358:         symbolToSubject[symbol] = curvesTokenSubject;\n359: \n360:         emit TokenDeployed(curvesTokenSubject, tokenContract, name, symbol);\n361:         return address(tokenContract);\n362:     }\n\n```\n",
          "loc": [
            "[346](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L346-L347)"
          ]
        },
        {
          "content": "```solidity\n338:     function _deployERC20(\n339:         address curvesTokenSubject,\n340:         string memory name,\n341:         string memory symbol\n342:     ) internal returns (address) {\n343:         \n344:         if (keccak256(bytes(symbol)) == keccak256(bytes(DEFAULT_SYMBOL))) {\n345:             _curvesTokenCounter += 1;\n346:             name = string(abi.encodePacked(name, \" \", Strings.toString(_curvesTokenCounter))); // <= FOUND\n347:             symbol = string(abi.encodePacked(symbol, Strings.toString(_curvesTokenCounter))); // <= FOUND\n348:         }\n349: \n350:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();\n351: \n352:         address tokenContract = CurvesERC20Factory(curvesERC20Factory).deploy(name, symbol, address(this));\n353: \n354:         externalCurvesTokens[curvesTokenSubject].token = tokenContract;\n355:         externalCurvesTokens[curvesTokenSubject].name = name;\n356:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;\n357:         externalCurvesToSubject[tokenContract] = curvesTokenSubject;\n358:         symbolToSubject[symbol] = curvesTokenSubject;\n359: \n360:         emit TokenDeployed(curvesTokenSubject, tokenContract, name, symbol);\n361:         return address(tokenContract);\n362:     }\n\n```\n",
          "loc": [
            "[346](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L346-L347)"
          ]
        },
        {
          "content": "```solidity\n338:     function _deployERC20(\n339:         address curvesTokenSubject,\n340:         string memory name,\n341:         string memory symbol\n342:     ) internal returns (address) {\n343:         \n344:         if (keccak256(bytes(symbol)) == keccak256(bytes(DEFAULT_SYMBOL))) {\n345:             _curvesTokenCounter += 1;\n346:             name = string(abi.encodePacked(name, \" \", Strings.toString(_curvesTokenCounter))); // <= FOUND\n347:             symbol = string(abi.encodePacked(symbol, Strings.toString(_curvesTokenCounter))); // <= FOUND\n348:         }\n349: \n350:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();\n351: \n352:         address tokenContract = CurvesERC20Factory(curvesERC20Factory).deploy(name, symbol, address(this));\n353: \n354:         externalCurvesTokens[curvesTokenSubject].token = tokenContract;\n355:         externalCurvesTokens[curvesTokenSubject].name = name;\n356:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;\n357:         externalCurvesToSubject[tokenContract] = curvesTokenSubject;\n358:         symbolToSubject[symbol] = curvesTokenSubject;\n359: \n360:         emit TokenDeployed(curvesTokenSubject, tokenContract, name, symbol);\n361:         return address(tokenContract);\n362:     }\n\n```\n",
          "loc": [
            "[346](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L346-L347)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Overly complicated arithmetic [EXP-2]",
      "description": "To maintain readability in code, particularly in Solidity which can involve complex mathematical operations, it is often recommended to limit the number of arithmetic operations to a maximum of 2-3 per line. Too many operations in a single line can make the code difficult to read and understand, increase the likelihood of mistakes, and complicate the process of debugging and reviewing the code. Consider splitting such operations over more than one line, take special care when dealing with division however. Try to limit the number of arithmetic operations to a maximum of 3 per line.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n218:     function _transferFees(\n219:         address curvesTokenSubject,\n220:         bool isBuy,\n221:         uint256 price,\n222:         uint256 amount,\n223:         uint256 supply\n224:     ) internal {\n225:         (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holderFee, ) = getFees(price);\n226:         {\n227:             bool referralDefined = referralFeeDestination[curvesTokenSubject] != address(0);\n228:             {\n229:                 address firstDestination = isBuy ? feesEconomics.protocolFeeDestination : msg.sender;\n230:                 uint256 buyValue = referralDefined ? protocolFee : protocolFee + referralFee;\n231:                 uint256 sellValue = price - protocolFee - subjectFee - referralFee - holderFee; // <= FOUND\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\");\n233:                 if (!success1) revert CannotSendFunds();\n234:             }\n235:             {\n236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}(\"\");\n237:                 if (!success2) revert CannotSendFunds();\n238:             }\n239:             {\n240:                 (bool success3, ) = referralDefined\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}(\"\")\n242:                     : (true, bytes(\"\"));\n243:                 if (!success3) revert CannotSendFunds();\n244:             }\n245: \n246:             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0)) {\n247:                 feeRedistributor.onBalanceChange(curvesTokenSubject, msg.sender);\n248:                 feeRedistributor.addFees{value: holderFee}(curvesTokenSubject);\n249:             }\n250:         }\n251:         emit Trade(\n252:             msg.sender,\n253:             curvesTokenSubject,\n254:             isBuy,\n255:             amount,\n256:             price,\n257:             protocolFee,\n258:             subjectFee,\n259:             isBuy ? supply + amount : supply - amount\n260:         );\n261:     }\n\n```\n",
          "loc": [
            "[231](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L231-L231)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "No limits when setting fees [EXP-3]",
      "description": "When settings fees state variables, ensure there a require checks in place to prevent incorrect values from being set. This is particularly important when dealing with fee values as without checks fees can be set to 100%",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner {\n114:         feeRedistributor = FeeSplitter(payable(feeRedistributor_));\n115:     }\n\n```\n",
          "loc": [
            "[113](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L113-L113)"
          ]
        },
        {
          "content": "```solidity\n113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner {\n114:         feeRedistributor = FeeSplitter(payable(feeRedistributor_));\n115:     }\n\n```\n",
          "loc": [
            "[113](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L113-L113)"
          ]
        },
        {
          "content": "```solidity\n113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner {\n114:         feeRedistributor = FeeSplitter(payable(feeRedistributor_));\n115:     }\n\n```\n",
          "loc": [
            "[113](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L113-L113)"
          ]
        },
        {
          "content": "```solidity\n113:     function setFeeRedistributor(address feeRedistributor_) external onlyOwner {\n114:         feeRedistributor = FeeSplitter(payable(feeRedistributor_));\n115:     }\n\n```\n",
          "loc": [
            "[113](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L113-L113)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Employ Explicit Casting to Bytes or Bytes32 for Enhanced Code Clarity and Meaning [EXP-3]",
      "description": "Smart contracts are complex entities, and clarity in their operations is fundamental to ensure that they function as intended. Casting a single argument instead of utilizing 'abi.encodePacked()' improves the transparency of the operation. It elucidates the intent of the code, reducing ambiguity and making it easier for auditors and developers to understand the code’s purpose. Such practices promote readability and maintainability, thus reducing the likelihood of errors and misunderstandings. Therefore, it's recommended to employ explicit casts for single arguments where possible, to increase the contract's comprehensibility and ensure a smoother review process.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n338:     function _deployERC20(\n339:         address curvesTokenSubject,\n340:         string memory name,\n341:         string memory symbol\n342:     ) internal returns (address) {\n343:         \n344:         if (keccak256(bytes(symbol)) == keccak256(bytes(DEFAULT_SYMBOL))) {\n345:             _curvesTokenCounter += 1;\n346:             name = string(abi.encodePacked(name, \" \", Strings.toString(_curvesTokenCounter))); // <= FOUND\n347:             symbol = string(abi.encodePacked(symbol, Strings.toString(_curvesTokenCounter))); // <= FOUND\n348:         }\n349: \n350:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();\n351: \n352:         address tokenContract = CurvesERC20Factory(curvesERC20Factory).deploy(name, symbol, address(this));\n353: \n354:         externalCurvesTokens[curvesTokenSubject].token = tokenContract;\n355:         externalCurvesTokens[curvesTokenSubject].name = name;\n356:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;\n357:         externalCurvesToSubject[tokenContract] = curvesTokenSubject;\n358:         symbolToSubject[symbol] = curvesTokenSubject;\n359: \n360:         emit TokenDeployed(curvesTokenSubject, tokenContract, name, symbol);\n361:         return address(tokenContract);\n362:     }\n\n```\n",
          "loc": [
            "[346](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L346-L347)"
          ]
        },
        {
          "content": "```solidity\n338:     function _deployERC20(\n339:         address curvesTokenSubject,\n340:         string memory name,\n341:         string memory symbol\n342:     ) internal returns (address) {\n343:         \n344:         if (keccak256(bytes(symbol)) == keccak256(bytes(DEFAULT_SYMBOL))) {\n345:             _curvesTokenCounter += 1;\n346:             name = string(abi.encodePacked(name, \" \", Strings.toString(_curvesTokenCounter))); // <= FOUND\n347:             symbol = string(abi.encodePacked(symbol, Strings.toString(_curvesTokenCounter))); // <= FOUND\n348:         }\n349: \n350:         if (symbolToSubject[symbol] != address(0)) revert InvalidERC20Metadata();\n351: \n352:         address tokenContract = CurvesERC20Factory(curvesERC20Factory).deploy(name, symbol, address(this));\n353: \n354:         externalCurvesTokens[curvesTokenSubject].token = tokenContract;\n355:         externalCurvesTokens[curvesTokenSubject].name = name;\n356:         externalCurvesTokens[curvesTokenSubject].symbol = symbol;\n357:         externalCurvesToSubject[tokenContract] = curvesTokenSubject;\n358:         symbolToSubject[symbol] = curvesTokenSubject;\n359: \n360:         emit TokenDeployed(curvesTokenSubject, tokenContract, name, symbol);\n361:         return address(tokenContract);\n362:     }\n\n```\n",
          "loc": [
            "[346](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L346-L347)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Duplicated revert() checks should be refactored to a modifier or function [EXP-3]",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n371:         if (supply != 0) revert CurveAlreadyExists(); // <= FOUND\n\n```\n",
          "loc": [
            "[371](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L371-L371)"
          ]
        },
        {
          "content": "```solidity\n371:         if (supply != 0) revert CurveAlreadyExists(); // <= FOUND\n\n```\n",
          "loc": [
            "[371](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L371-L371)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Missing events in sensitive functions [EXP-3]",
      "description": "Sensitive setter functions in smart contracts often alter critical state variables. Without events emitted in these functions, external observers or dApps cannot easily track or react to these state changes. Missing events can obscure contract activity, hampering transparency and making integration more challenging. To resolve this, incorporate appropriate event emissions within these functions. Events offer an efficient way to log crucial changes, aiding in real-time tracking and post-transaction verification.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n35:     function setCurves(Curves curves_) public { // <= FOUND\n36:         curves = curves_;\n37:     }\n\n```\n",
          "loc": [
            "[35](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L35-L35)"
          ]
        },
        {
          "content": "```solidity\n23:     function setManager(address manager_, bool value) public onlyOwner { // <= FOUND\n24:         managers[manager_] = value;\n25:     }\n\n```\n",
          "loc": [
            "[23](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Security.sol#L23-L23)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Optimize by Using Assembly for Low-Level Calls' Return Data",
      "description": "Using assembly for low-level calls in Solidity can provide gas savings, especially when dealing with return data. High-level Solidity calls include overhead for decoding return data, which can be bypassed with assembly. By directly accessing return data in assembly, you can eliminate unnecessary memory allocation and data copying, leading to a more gas-efficient execution. However, this approach requires a deep understanding of the Ethereum Virtual Machine (EVM) and is prone to errors. It’s crucial to ensure security and correctness in the implementation. This technique is best suited for advanced users aiming to optimize contract performance in specific, gas-critical scenarios.",
      "gasSavings": 477,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\"); // <= FOUND\n\n```\n",
          "loc": [
            "[232](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L232-L232)"
          ]
        },
        {
          "content": "```solidity\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\"); // <= FOUND\n\n```\n",
          "loc": [
            "[232](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L232-L232)"
          ]
        },
        {
          "content": "```solidity\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\"); // <= FOUND\n\n```\n",
          "loc": [
            "[232](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L232-L232)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "External call recipient may consume all transaction gas",
      "description": "When making external calls, the called contract can intentionally or unintentionally consume all provided gas, leading to unintended transaction reversion. To mitigate this risk, it's crucial to specify a gas limit when making the call. By using `addr.call{gas: <amount>}(\"\")`, you allocate a specific amount of gas to the external call, ensuring the parent transaction has gas left for post-call operations. This approach safeguards against malevolent contracts aiming to exhaust gas and provides greater control over transaction execution.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\"); // <= FOUND\n\n```\n",
          "loc": [
            "[232](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L232-L232)"
          ]
        },
        {
          "content": "```solidity\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\"); // <= FOUND\n\n```\n",
          "loc": [
            "[232](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L232-L232)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Use of abi.encodePacked with dynamic types inside keccak256",
      "description": "Using abi.encodePacked with dynamic types for hashing functions like keccak256 can be risky due to the potential for hash collisions. This function concatenates arguments tightly, without padding, which might lead to different inputs producing the same hash. This is especially problematic with dynamic types, where the boundaries between inputs can blur. To mitigate this, use abi.encode instead. abi.encode pads its arguments to 32 bytes, creating clear distinctions between different inputs and significantly reducing the chance of hash collisions. This approach ensures more reliable and collision-resistant hashing, crucial for maintaining data integrity and security in smart contracts.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n424:         \n425:         bytes32 leaf = keccak256(abi.encodePacked(caller)); // <= FOUND\n\n```\n",
          "loc": [
            "[425](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L425-L425)"
          ]
        },
        {
          "content": "```solidity\n424:         \n425:         bytes32 leaf = keccak256(abi.encodePacked(caller)); // <= FOUND\n\n```\n",
          "loc": [
            "[425](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L425-L425)"
          ]
        },
        {
          "content": "```solidity\n424:         \n425:         bytes32 leaf = keccak256(abi.encodePacked(caller)); // <= FOUND\n\n```\n",
          "loc": [
            "[425](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L425-L425)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Inconsistent checks of address params against address(0)",
      "description": "Only some address parameters are checked against address(0), to ensure consistency ensure all address parameters are checked.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n218:     function _transferFees(\n219:         address curvesTokenSubject, // <= FOUND 'address curvesTokenSubject'\n220:         bool isBuy,\n221:         uint256 price,\n222:         uint256 amount,\n223:         uint256 supply\n224:     ) internal {\n225:         (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holderFee, ) = getFees(price);\n226:         {\n227:             bool referralDefined = referralFeeDestination[curvesTokenSubject] != address(0);\n228:             {\n229:                 address firstDestination = isBuy ? feesEconomics.protocolFeeDestination : msg.sender;\n230:                 uint256 buyValue = referralDefined ? protocolFee : protocolFee + referralFee;\n231:                 uint256 sellValue = price - protocolFee - subjectFee - referralFee - holderFee;\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\");\n233:                 if (!success1) revert CannotSendFunds();\n234:             }\n235:             {\n236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}(\"\");\n237:                 if (!success2) revert CannotSendFunds();\n238:             }\n239:             {\n240:                 (bool success3, ) = referralDefined\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}(\"\")\n242:                     : (true, bytes(\"\"));\n243:                 if (!success3) revert CannotSendFunds();\n244:             }\n245: \n246:             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0)) {\n247:                 feeRedistributor.onBalanceChange(curvesTokenSubject, msg.sender);\n248:                 feeRedistributor.addFees{value: holderFee}(curvesTokenSubject);\n249:             }\n250:         }\n251:         emit Trade(\n252:             msg.sender,\n253:             curvesTokenSubject,\n254:             isBuy,\n255:             amount,\n256:             price,\n257:             protocolFee,\n258:             subjectFee,\n259:             isBuy ? supply + amount : supply - amount\n260:         );\n261:     }\n\n```\n",
          "loc": [
            "[218](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L218-L219)"
          ]
        },
        {
          "content": "```solidity\n218:     function _transferFees(\n219:         address curvesTokenSubject, // <= FOUND 'address curvesTokenSubject'\n220:         bool isBuy,\n221:         uint256 price,\n222:         uint256 amount,\n223:         uint256 supply\n224:     ) internal {\n225:         (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holderFee, ) = getFees(price);\n226:         {\n227:             bool referralDefined = referralFeeDestination[curvesTokenSubject] != address(0);\n228:             {\n229:                 address firstDestination = isBuy ? feesEconomics.protocolFeeDestination : msg.sender;\n230:                 uint256 buyValue = referralDefined ? protocolFee : protocolFee + referralFee;\n231:                 uint256 sellValue = price - protocolFee - subjectFee - referralFee - holderFee;\n232:                 (bool success1, ) = firstDestination.call{value: isBuy ? buyValue : sellValue}(\"\");\n233:                 if (!success1) revert CannotSendFunds();\n234:             }\n235:             {\n236:                 (bool success2, ) = curvesTokenSubject.call{value: subjectFee}(\"\");\n237:                 if (!success2) revert CannotSendFunds();\n238:             }\n239:             {\n240:                 (bool success3, ) = referralDefined\n241:                     ? referralFeeDestination[curvesTokenSubject].call{value: referralFee}(\"\")\n242:                     : (true, bytes(\"\"));\n243:                 if (!success3) revert CannotSendFunds();\n244:             }\n245: \n246:             if (feesEconomics.holdersFeePercent > 0 && address(feeRedistributor) != address(0)) {\n247:                 feeRedistributor.onBalanceChange(curvesTokenSubject, msg.sender);\n248:                 feeRedistributor.addFees{value: holderFee}(curvesTokenSubject);\n249:             }\n250:         }\n251:         emit Trade(\n252:             msg.sender,\n253:             curvesTokenSubject,\n254:             isBuy,\n255:             amount,\n256:             price,\n257:             protocolFee,\n258:             subjectFee,\n259:             isBuy ? supply + amount : supply - amount\n260:         );\n261:     }\n\n```\n",
          "loc": [
            "[218](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L218-L219)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Division in comparison",
      "description": "To ensure accuracy in comparisons within programming, especially when dealing with integers, it's often more efficient to use multiplication rather than division. This approach stems from the fact that division operations are generally slower and more complex than multiplication. And in the context of solidity they can cause precision errors.\n\nSuppose you want to compare if a/b is greater than c/d (where a, b, c, and d are integers). Instead of performing division, which is prone to precision errors, you can cross-multiply to avoid division. The comparison a/b > c/d is equivalent to a*d > b*c. This way, you only use multiplication, which is faster and avoids potential inaccuracies or complexities associated with division.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n181:         uint256 sum1 = supply == 0 ? 0 : ((supply - 1) * (supply) * (2 * (supply - 1) + 1)) / 6; // <= FOUND\n\n```\n",
          "loc": [
            "[181](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L181-L181)"
          ]
        }
      ]
    }
  ],
  "createdAt": "2024-01-08T21:41:40.121Z",
  "updatedAt": "2024-01-08T21:41:40.820Z"
}